src/main.js
import './app.css'
import App from './App.svelte'

const app = new App({
  target: document.getElementById('app'),
})

export default app
src/lib/api.js
const API_BASE = '/api';

class ApiClient {
  constructor() {
    this.token = localStorage.getItem('token');
  }

  setToken(token) {
    this.token = token;
    if (token) {
      localStorage.setItem('token', token);
    } else {
      localStorage.removeItem('token');
    }
  }

  getHeaders() {
    const headers = {
      'Content-Type': 'application/json',
    };
    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }
    return headers;
  }

  async request(endpoint, options = {}) {
    const url = `${API_BASE}${endpoint}`;
    const config = {
      ...options,
      headers: {
        ...this.getHeaders(),
        ...options.headers,
      },
    };

    try {
      const response = await fetch(url, config);
      
      // Handle non-JSON responses
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return { success: true };
      }

      const data = await response.json();

      if (!response.ok) {
        if (response.status === 401) {
          // Don't redirect here, just throw error
          this.setToken(null);
        }
        throw new Error(data.error || data.message || 'Request failed');
      }

      return data;
    } catch (error) {
      console.error('API Error:', error);
      throw error;
    }
  }

  // Auth endpoints
  async login(email, password, totpCode = null) {
    const data = await this.request('/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password, totp_code: totpCode }),
    });
    if (data.data && data.data.token) {
      this.setToken(data.data.token);
    }
    return data;
  }

  async register(userData) {
    return this.request('/auth/register', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
  }

  async getCurrentUser() {
    return this.request('/auth/me');
  }

  async logout() {
    try {
      await this.request('/auth/logout', { method: 'POST' });
    } catch (error) {
      // Ignore logout errors
    } finally {
      this.setToken(null);
    }
  }

  // Attendance endpoints
  async checkIn(latitude, longitude, reason = null) {
    const body = { latitude, longitude };
    if (reason) {
      body.reason = reason;
    }
    return this.request('/attendance/checkin', {
      method: 'POST',
      body: JSON.stringify(body),
    });
  }

  async checkOut(latitude, longitude) {
    return this.request('/attendance/checkout', {
      method: 'POST',
      body: JSON.stringify({ latitude, longitude }),
    });
  }

async getTodayAttendance() {
  // Add a cache-busting query parameter
  const cacheBuster = new Date().getTime();
  return this.request(`/attendance/today?t=${cacheBuster}`);
}

  async getAttendanceHistory(internId, page = 1, limit = 30) {
    return this.request(`/attendance/intern/${internId}?page=${page}&limit=${limit}`);
  }

  // Analytics endpoints
  async getWeeklyTrends(internId, weekOffset = 0) {
    return this.request(`/analytics/trends/weekly/${internId}?week_offset=${weekOffset}`);
  }

  async getCheckInPatterns(internId, days = 30) {
    return this.request(`/analytics/patterns/checkin/${internId}?days=${days}`);
  }

  async getPerformanceInsights(internId) {
    return this.request(`/analytics/insights/${internId}`);
  }

  // Task endpoints
  async getTasks(internId = null, page = 1) {
    const endpoint = internId 
      ? `/tasks/intern/${internId}?page=${page}` 
      : `/tasks?page=${page}`;
    return this.request(endpoint);
  }

  async getTask(taskId) {
    return this.request(`/tasks/${taskId}`);
  }

  async createTask(taskData) {
    return this.request('/tasks', {
      method: 'POST',
      body: JSON.stringify(taskData),
    });
  }

  async uploadTaskAttachment(taskId, file) {
    const formData = new FormData();
    formData.append('file', file);

    return fetch(`${API_BASE}/tasks/${taskId}/attachments`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.token}`,
      },
      body: formData,
    }).then(res => res.json());
  }

  // Leave endpoints
  async getLeaveRequests(internId = null) {
    const endpoint = internId 
      ? `/leaves/intern/${internId}` 
      : `/leaves`;
    return this.request(endpoint);
  }

  async createLeaveRequest(leaveData) {
    return this.request('/leaves', {
      method: 'POST',
      body: JSON.stringify(leaveData),
    });
  }

  async approveLeave(leaveId) {
    return this.request(`/leaves/${leaveId}/approve`, {
      method: 'POST',
      body: JSON.stringify({ status: 'approved' }),
    });
  }

  async rejectLeave(leaveId) {
    return this.request(`/leaves/${leaveId}/reject`, {
      method: 'POST',
      body: JSON.stringify({ status: 'rejected' }),
    });
  }

  // Assessment endpoints
  async getAssessments(internId = null) {
    const endpoint = internId 
      ? `/assessments/intern/${internId}` 
      : `/assessments`;
    return this.request(endpoint);
  }

  async createAssessment(assessmentData) {
    return this.request('/assessments', {
      method: 'POST',
      body: JSON.stringify(assessmentData),
    });
  }
}

export const api = new ApiClient();
src/lib/stores.js
import { writable } from 'svelte/store';
import { api } from './api';

// Auth store
function createAuthStore() {
  const { subscribe, set, update } = writable({
    user: null,
    loading: true,
    isAuthenticated: false,
  });

  return {
    subscribe,
    update, // <--- EXPOSE UPDATE METHOD (THIS WAS MISSING!)
    
    login: async (email, password, totpCode = null) => {
      const response = await api.login(email, password, totpCode);
      
      // Handle the response properly
      const data = response.data || response; // Handle wrapped/unwrapped

      // CRITICAL FIX: Only set authenticated if NO 2FA is required
      if (data && data.user && !data.require_2fa) {
          set({
            user: data.user,
            loading: false,
            isAuthenticated: true,
          });
      }
      
      return response;
    },
    
    logout: async () => {
      await api.logout();
      set({
        user: null,
        loading: false,
        isAuthenticated: false,
      });
    },
    
    checkAuth: async () => {
      try {
        const response = await api.getCurrentUser();
        set({
          user: response.data,
          loading: false,
          isAuthenticated: true,
        });
        return response.data;
      } catch (error) {
        console.log('Not authenticated');
        set({
          user: null,
          loading: false,
          isAuthenticated: false,
        });
        return null;
      }
    },
    
    setUser: (user) => {
      set({
        user,
        loading: false,
        isAuthenticated: !!user,
      });
    },
    
    // Add method to refresh user data
    refreshUser: async () => {
      try {
        const response = await api.getCurrentUser();
        set({
          user: response.data,
          loading: false,
          isAuthenticated: true,
        });
        return response.data;
      } catch (error) {
        console.error('Failed to refresh user:', error);
        return null;
      }
    },
  };
}

export const auth = createAuthStore();

// Attendance store
export const todayAttendance = writable(null);
export const attendanceLoading = writable(false);

// Toast notifications store
function createToastStore() {
  const { subscribe, update } = writable([]);

  return {
    subscribe,
    add: (message, type = 'info', duration = 3000) => {
      const id = Date.now();
      update(toasts => [...toasts, { id, message, type }]);
      
      if (duration > 0) {
        setTimeout(() => {
          update(toasts => toasts.filter(t => t.id !== id));
        }, duration);
      }
      return id;
    },
    remove: (id) => {
      update(toasts => toasts.filter(t => t.id !== id));
    },
  };
}

export const toast = createToastStore();

// Convenience methods for toast
toast.success = (message, duration) => toast.add(message, 'success', duration);
toast.error = (message, duration) => toast.add(message, 'error', duration);
toast.info = (message, duration) => toast.add(message, 'info', duration);

// Location store for geolocation
export const location = writable({
  latitude: null,
  longitude: null,
  error: null,
  loading: false,
});

export function getCurrentLocation() {
  location.update(loc => ({ ...loc, loading: true, error: null }));

  if (!navigator.geolocation) {
    location.update(loc => ({ 
      ...loc, 
      loading: false, 
      error: 'Geolocation is not supported by your browser' 
    }));
    return;
  }

  navigator.geolocation.getCurrentPosition(
    (position) => {
      location.set({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        error: null,
        loading: false,
      });
    },
    (error) => {
      let errorMessage = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          errorMessage = 'Location permission denied';
          break;
        case error.POSITION_UNAVAILABLE:
          errorMessage = 'Location information unavailable';
          break;
        case error.TIMEOUT:
          errorMessage = 'Location request timed out';
          break;
      }
      location.update(loc => ({ 
        ...loc, 
        loading: false, 
        error: errorMessage 
      }));
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    }
  );
}{
  "name": "interna-frontend",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^3.0.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "svelte": "^4.2.8",
    "tailwindcss": "^3.4.0",
    "vite": "^5.0.8"
  },
  "dependencies": {
    "chart.js": "^4.4.1",
    "geist": "^1.5.1",
    "svelte-routing": "^2.0.0"
  }
}
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  }
})
