./cmd/server/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/database"
	"dsi_interna_sys/internal/routes"

	"github.com/gorilla/mux"
	"github.com/rs/cors"
)

func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	log.Printf("Starting %s in %s mode", cfg.App.Name, cfg.App.Env)

	// Connect to database
	db, err := database.Connect(cfg)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer database.Close()

	// Create upload directories
	if err := createUploadDirs(cfg); err != nil {
		log.Fatalf("Failed to create upload directories: %v", err)
	}

	// Setup router
	router := mux.NewRouter()

	// Setup routes
	routes.SetupRoutes(router, db)

	// Setup CORS
	corsHandler := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"}, // Configure properly for production
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Content-Type", "Authorization"},
		AllowCredentials: true,
		MaxAge:           300,
	})

	handler := corsHandler.Handler(router)

	// Create server
	addr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)
	server := &http.Server{
		Addr:         addr,
		Handler:      handler,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server in goroutine
	go func() {
		log.Printf("Server starting on http://%s", addr)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server failed to start: %v", err)
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Println("Server shutting down...")
	log.Println("Server stopped")
}

// createUploadDirs creates necessary upload directories
func createUploadDirs(cfg *config.Config) error {
	dirs := []string{
		cfg.Upload.Dir,
		fmt.Sprintf("%s/tasks", cfg.Upload.Dir),
		fmt.Sprintf("%s/leaves", cfg.Upload.Dir),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	log.Println("Upload directories created successfully")
	return nil
}
./internal/utils/random.go
package utils

import (
	"crypto/rand"
	"encoding/base64"
)

func GenerateToken(length int) (string, error) {
	if length < 16 {
		length = 16
	}
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}
./internal/utils/response.go
package utils

import (
	"encoding/json"
	"net/http"
)

// Response represents a standard API response
type Response struct {
	Success bool        `json:"success"`
	Message string      `json:"message,omitempty"`
	Data    interface{} `json:"data,omitempty"`
	Error   string      `json:"error,omitempty"`
}

// PaginatedResponse represents a paginated API response
type PaginatedResponse struct {
	Success    bool        `json:"success"`
	Message    string      `json:"message,omitempty"`
	Data       interface{} `json:"data"`
	Pagination Pagination  `json:"pagination"`
}

// Pagination contains pagination metadata
type Pagination struct {
	Page       int   `json:"page"`
	Limit      int   `json:"limit"`
	TotalItems int64 `json:"total_items"`
	TotalPages int   `json:"total_pages"`
}

// RespondJSON sends a JSON response
func RespondJSON(w http.ResponseWriter, status int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(payload)
}

// RespondSuccess sends a success response
func RespondSuccess(w http.ResponseWriter, message string, data interface{}) {
	RespondJSON(w, http.StatusOK, Response{
		Success: true,
		Message: message,
		Data:    data,
	})
}

// RespondCreated sends a created response
func RespondCreated(w http.ResponseWriter, message string, data interface{}) {
	RespondJSON(w, http.StatusCreated, Response{
		Success: true,
		Message: message,
		Data:    data,
	})
}

// RespondError sends an error response
func RespondError(w http.ResponseWriter, status int, message string) {
	RespondJSON(w, status, Response{
		Success: false,
		Error:   message,
	})
}

// RespondBadRequest sends a bad request error
func RespondBadRequest(w http.ResponseWriter, message string) {
	RespondError(w, http.StatusBadRequest, message)
}

// RespondUnauthorized sends an unauthorized error
func RespondUnauthorized(w http.ResponseWriter, message string) {
	RespondError(w, http.StatusUnauthorized, message)
}

// RespondForbidden sends a forbidden error
func RespondForbidden(w http.ResponseWriter, message string) {
	RespondError(w, http.StatusForbidden, message)
}

// RespondNotFound sends a not found error
func RespondNotFound(w http.ResponseWriter, message string) {
	RespondError(w, http.StatusNotFound, message)
}

// RespondInternalError sends an internal server error
func RespondInternalError(w http.ResponseWriter, message string) {
	RespondError(w, http.StatusInternalServerError, message)
}

// RespondPaginated sends a paginated response
func RespondPaginated(w http.ResponseWriter, data interface{}, pagination Pagination) {
	RespondJSON(w, http.StatusOK, PaginatedResponse{
		Success:    true,
		Data:       data,
		Pagination: pagination,
	})
}

// ParseJSON parses JSON request body
func ParseJSON(r *http.Request, v interface{}) error {
	return json.NewDecoder(r.Body).Decode(v)
}

// CalculatePagination calculates pagination metadata
func CalculatePagination(page, limit int, totalItems int64) Pagination {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}
	
	totalPages := int(totalItems) / limit
	if int(totalItems)%limit > 0 {
		totalPages++
	}
	
	return Pagination{
		Page:       page,
		Limit:      limit,
		TotalItems: totalItems,
		TotalPages: totalPages,
	}
}
./internal/utils/file.go
package utils

import (
	"fmt"
	"io"
	"mime/multipart"
	"os"
	"path/filepath"
	"strings"
	"time"

	"dsi_interna_sys/internal/config"
)

// UploadFile handles file upload with validation
func UploadFile(file multipart.File, header *multipart.FileHeader, subdir string) (string, error) {
	cfg := config.Loaded

	// Validate file size
	if header.Size > cfg.Upload.MaxSize {
		return "", fmt.Errorf("file size exceeds maximum allowed size of %d bytes", cfg.Upload.MaxSize)
	}

	// Validate file extension
	ext := strings.ToLower(filepath.Ext(header.Filename))
	if !isAllowedExtension(ext, cfg.Upload.AllowedExts) {
		return "", fmt.Errorf("file type %s is not allowed. Allowed types: %v", ext, cfg.Upload.AllowedExts)
	}

	// Create upload directory if not exists
	uploadPath := filepath.Join(cfg.Upload.Dir, subdir)
	if err := os.MkdirAll(uploadPath, 0755); err != nil {
		return "", fmt.Errorf("failed to create upload directory: %w", err)
	}

	// Generate unique filename
	filename := generateUniqueFilename(header.Filename)
	filePath := filepath.Join(uploadPath, filename)

	// Create destination file
	dst, err := os.Create(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to create file: %w", err)
	}
	defer dst.Close()

	// Copy file content
	if _, err := io.Copy(dst, file); err != nil {
		return "", fmt.Errorf("failed to save file: %w", err)
	}

	// Return relative path from upload directory
	relativePath := filepath.Join(subdir, filename)
	return relativePath, nil
}

// DeleteFile deletes a file from upload directory
func DeleteFile(relativePath string) error {
	cfg := config.Loaded
	fullPath := filepath.Join(cfg.Upload.Dir, relativePath)

	if _, err := os.Stat(fullPath); os.IsNotExist(err) {
		return nil // File doesn't exist, consider it deleted
	}

	return os.Remove(fullPath)
}

// GetFileExtension returns file extension from filename
func GetFileExtension(filename string) string {
	ext := filepath.Ext(filename)
	return strings.ToLower(strings.TrimPrefix(ext, "."))
}

// isAllowedExtension checks if file extension is allowed
func isAllowedExtension(ext string, allowedExts []string) bool {
	for _, allowed := range allowedExts {
		if ext == allowed || ext == strings.TrimPrefix(allowed, ".") {
			return true
		}
	}
	return false
}

// generateUniqueFilename generates a unique filename with timestamp
func generateUniqueFilename(originalFilename string) string {
	ext := filepath.Ext(originalFilename)
	nameWithoutExt := strings.TrimSuffix(originalFilename, ext)

	// Clean filename (remove special characters)
	nameWithoutExt = strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' {
			return r
		}
		return '_'
	}, nameWithoutExt)

	timestamp := time.Now().Unix()
	return fmt.Sprintf("%s_%d%s", nameWithoutExt, timestamp, ext)
}

// ValidateFileType validates file type based on extension
func ValidateFileType(filename string, allowedTypes []string) error {
	ext := GetFileExtension(filename)

	for _, allowed := range allowedTypes {
		if ext == allowed {
			return nil
		}
	}

	return fmt.Errorf("file type .%s is not allowed. Allowed types: %v", ext, allowedTypes)
}
./internal/utils/email.go
package utils

import (
	"crypto/tls"
	"fmt"
	"net/smtp"
	"strings"

	"dsi_interna_sys/internal/config"
)

func SendMail(to, subject, body string) error {
	cfg := config.Loaded.SMTP
	if cfg.Host == "" || cfg.From == "" {
		return fmt.Errorf("smtp not configured")
	}

	addr := fmt.Sprintf("%s:%s", cfg.Host, cfg.Port)
	from := cfg.From
	if strings.TrimSpace(to) == "" {
		return fmt.Errorf("recipient missing")
	}

	headers := []string{
		"From: " + from,
		"To: " + to,
		"Subject: " + subject,
		"MIME-Version: 1.0",
		"Content-Type: text/plain; charset=UTF-8",
		"",
	}
	message := strings.Join(headers, "\r\n") + body

	var auth smtp.Auth
	if cfg.Username != "" {
		auth = smtp.PlainAuth("", cfg.Username, cfg.Password, cfg.Host)
	}

	if cfg.UseTLS {
		tlsConfig := &tls.Config{ServerName: cfg.Host}
		conn, err := tls.Dial("tcp", addr, tlsConfig)
		if err != nil {
			return err
		}
		client, err := smtp.NewClient(conn, cfg.Host)
		if err != nil {
			return err
		}
		defer client.Quit()

		if auth != nil {
			if err := client.Auth(auth); err != nil {
				return err
			}
		}
		if err := client.Mail(from); err != nil {
			return err
		}
		if err := client.Rcpt(to); err != nil {
			return err
		}
		w, err := client.Data()
		if err != nil {
			return err
		}
		if _, err := w.Write([]byte(message)); err != nil {
			return err
		}
		return w.Close()
	}

	return smtp.SendMail(addr, auth, from, []string{to}, []byte(message))
}
./internal/utils/geo.go
package utils

import (
	"math"
)

const earthRadiusKm = 6371.0

// HaversineDistance calculates the distance between two points on Earth
// using the Haversine formula. Returns distance in meters.
func HaversineDistance(lat1, lon1, lat2, lon2 float64) float64 {
	// Convert degrees to radians
	lat1Rad := degreesToRadians(lat1)
	lon1Rad := degreesToRadians(lon1)
	lat2Rad := degreesToRadians(lat2)
	lon2Rad := degreesToRadians(lon2)

	// Differences
	dLat := lat2Rad - lat1Rad
	dLon := lon2Rad - lon1Rad

	// Haversine formula
	a := math.Sin(dLat/2)*math.Sin(dLat/2) +
		math.Cos(lat1Rad)*math.Cos(lat2Rad)*
			math.Sin(dLon/2)*math.Sin(dLon/2)

	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

	// Distance in kilometers
	distanceKm := earthRadiusKm * c

	// Convert to meters
	return distanceKm * 1000
}

// IsWithinRadius checks if a point is within a certain radius of another point
func IsWithinRadius(lat1, lon1, lat2, lon2, radiusMeters float64) bool {
	distance := HaversineDistance(lat1, lon1, lat2, lon2)
	return distance <= radiusMeters
}

// degreesToRadians converts degrees to radians
func degreesToRadians(degrees float64) float64 {
	return degrees * math.Pi / 180
}

// ValidateCoordinates checks if coordinates are valid
func ValidateCoordinates(lat, lon float64) bool {
	return lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180
}
./internal/models/setting.go
package models

import "time"

type Setting struct {
	ID          int64     `json:"id"`
	Key         string    `json:"key"`
	Value       string    `json:"value"`
	Type        string    `json:"type"` // string, time, boolean, integer
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}
./internal/models/leave.go
package models

import (
	"time"
)

type LeaveRequest struct {
	ID             int64      `json:"id"`
	InternID       int64      `json:"intern_id"`
	LeaveType      string     `json:"leave_type"` // sick, permission, other
	StartDate      time.Time  `json:"start_date"`
	EndDate        time.Time  `json:"end_date"`
	Reason         string     `json:"reason"`
	AttachmentPath *string    `json:"attachment_path,omitempty"` // Pointer for JSON null handling
	Status         string     `json:"status"`                    // pending, approved, rejected
	ApprovedBy     *int64     `json:"approved_by,omitempty"`
	ApprovedAt     *time.Time `json:"approved_at,omitempty"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`

	// Joined Fields
	InternName   string `json:"intern_name,omitempty"`
	ApproverName string `json:"approver_name,omitempty"`
}

// CreateLeaveRequest struct is not strictly used for Multipart forms
// but useful for validation reference
type CreateLeaveRequest struct {
	LeaveType string `validate:"required,oneof=sick permission other"`
	StartDate string `validate:"required"` // Receive as string "2006-01-02", parse manually
	EndDate   string `validate:"required"`
	Reason    string `validate:"required,min=5"`
}
./internal/models/analytics.go
package models

import (
	"time"
)

// AttendanceTrends represents weekly attendance analysis
type AttendanceTrends struct {
	InternID        int64                  `json:"intern_id"`
	InternName      string                 `json:"intern_name"`
	WeekStart       time.Time              `json:"week_start"`
	WeekEnd         time.Time              `json:"week_end"`
	DailyRecords    []DailyAttendanceStats `json:"daily_records"`
	Summary         WeeklySummary          `json:"summary"`
}

// DailyAttendanceStats represents a single day's attendance stats
type DailyAttendanceStats struct {
	Date          time.Time `json:"date"`
	DayOfWeek     string    `json:"day_of_week"`
	CheckInTime   *time.Time `json:"check_in_time,omitempty"`
	CheckInHour   *int      `json:"check_in_hour,omitempty"`
	CheckInMinute *int      `json:"check_in_minute,omitempty"`
	Status        string    `json:"status"` // present, late, absent, on_leave
	MinutesLate   *int      `json:"minutes_late,omitempty"`
	LateReason    *string   `json:"late_reason,omitempty"`
}

// WeeklySummary contains aggregated weekly statistics
type WeeklySummary struct {
	TotalDays         int     `json:"total_days"`
	PresentDays       int     `json:"present_days"`
	LateDays          int     `json:"late_days"`
	AbsentDays        int     `json:"absent_days"`
	OnLeaveDays       int     `json:"on_leave_days"`
	AttendanceRate    float64 `json:"attendance_rate"`    // Percentage
	PunctualityRate   float64 `json:"punctuality_rate"`   // Percentage
	AverageCheckInTime string `json:"average_check_in_time"` // Format: "HH:MM"
	EarliestCheckIn   *time.Time `json:"earliest_check_in,omitempty"`
	LatestCheckIn     *time.Time `json:"latest_check_in,omitempty"`
	Tendency          string  `json:"tendency"` // "early_bird", "on_time", "frequently_late", "inconsistent"
}

// MonthlyTrends represents monthly attendance analysis
type MonthlyTrends struct {
	InternID      int64                  `json:"intern_id"`
	InternName    string                 `json:"intern_name"`
	Month         time.Time              `json:"month"` // First day of month
	WeeklyData    []WeeklySummary        `json:"weekly_data"`
	MonthlySummary MonthlySummary        `json:"monthly_summary"`
}

// MonthlySummary contains aggregated monthly statistics
type MonthlySummary struct {
	TotalWorkingDays   int     `json:"total_working_days"`
	PresentDays        int     `json:"present_days"`
	LateDays           int     `json:"late_days"`
	AbsentDays         int     `json:"absent_days"`
	OnLeaveDays        int     `json:"on_leave_days"`
	AttendanceRate     float64 `json:"attendance_rate"`
	PunctualityRate    float64 `json:"punctuality_rate"`
	OverallTendency    string  `json:"overall_tendency"`
	ImprovementTrend   string  `json:"improvement_trend"` // "improving", "declining", "stable"
}

// CheckInPattern represents hourly distribution of check-ins
type CheckInPattern struct {
	Hour      int     `json:"hour"`       // 0-23
	Count     int     `json:"count"`      // Number of check-ins at this hour
	Percentage float64 `json:"percentage"` // Percentage of total
}

// PerformanceInsights provides AI-like insights
type PerformanceInsights struct {
	InternID     int64    `json:"intern_id"`
	InternName   string   `json:"intern_name"`
	Period       string   `json:"period"` // e.g., "Last 4 weeks"
	Strengths    []string `json:"strengths"`
	Concerns     []string `json:"concerns"`
	Suggestions  []string `json:"suggestions"`
	OverallScore int      `json:"overall_score"` // 0-100
}
./internal/models/attendance.go
package models

import (
	"time"
)

type Attendance struct {
	ID       int64     `json:"id"`
	InternID int64     `json:"intern_id"`
	Date     time.Time `json:"date"`

	// FIX: Use Pointers (*) instead of sql.Null types for clean JSON
	CheckInTime       *time.Time `json:"check_in_time"`
	CheckInLatitude   *float64   `json:"check_in_latitude"`
	CheckInLongitude  *float64   `json:"check_in_longitude"`
	CheckOutTime      *time.Time `json:"check_out_time"`
	CheckOutLatitude  *float64   `json:"check_out_latitude"`
	CheckOutLongitude *float64   `json:"check_out_longitude"`

	Status        string   `json:"status"`
	LateReason    *string  `json:"late_reason"`
	Notes         *string  `json:"notes,omitempty"`
	DistanceMeters *int    `json:"distance_meters,omitempty"`
	ProofFile     *string  `json:"proof_file,omitempty"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`

	InternName string `json:"intern_name,omitempty"`
}

type CheckInRequest struct {
	Latitude  float64 `json:"latitude" validate:"required,latitude"`
	Longitude float64 `json:"longitude" validate:"required,longitude"`
	Reason    string  `json:"reason,omitempty"`
}

// CheckOutRequest: We removed Latitude/Longitude requirements!
type CheckOutRequest struct {
	Latitude  float64 `json:"latitude"`  // Optional now
	Longitude float64 `json:"longitude"` // Optional now
}

type OfficeSettings struct {
	ID                   int64     `json:"id"`
	Latitude             float64   `json:"latitude"`
	Longitude            float64   `json:"longitude"`
	RadiusMeters         int       `json:"radius_meters"`
	CheckInTime          string    `json:"check_in_time"`
	CheckOutTime         string    `json:"check_out_time"`
	LateToleranceMinutes int       `json:"late_tolerance_minutes"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
}
./internal/models/user.go
package models

import (
	"database/sql"
	"time"
)

type User struct {
	ID                int64          `json:"id"`
	Name              sql.NullString `json:"name"`
	Email             string         `json:"email"`
	EmailVerifiedAt   sql.NullTime   `json:"email_verified_at,omitempty"`
	PasswordHash      sql.NullString `json:"-"` // Never expose password hash
	Role              string         `json:"role"` // admin, supervisor, pembimbing, intern
	Avatar            sql.NullString `json:"avatar,omitempty"`
	GoogleID          sql.NullString `json:"-"`
	Provider          sql.NullString `json:"-"`
	TOTPSecret        sql.NullString `json:"-"` // Never expose TOTP secret
	Is2FAEnabled      bool           `json:"is_2fa_enabled"`
	Google2FASecret   sql.NullString `json:"-"`
	Google2FAEnabled  bool           `json:"google2fa_enabled"`
	TwoFactorSecret   sql.NullString `json:"-"`
	TwoFactorRecovery sql.NullString `json:"-"`
	TwoFactorConfirmed sql.NullTime  `json:"-"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
}

type Supervisor struct {
	ID           int64   `json:"id"`
	UserID       int64   `json:"user_id"`
	FullName     string  `json:"full_name"`
	Email        string  `json:"email"`
	NIP          *string `json:"nip,omitempty"`
	Phone        *string `json:"phone,omitempty"`
	Position     *string `json:"position,omitempty"`
	Address      *string `json:"address,omitempty"`
	Institution  *string `json:"institution,omitempty"`
	Status       string  `json:"status"`
	InternsCount int64   `json:"interns_count,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

type Institution struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	Address   string    `json:"address"`
	Phone     string    `json:"phone"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}
./internal/models/task.go
package models

import "time"

type SubmissionLink struct {
	Label string `json:"label"`
	URL   string `json:"url"`
}

type Task struct {
	ID               int64            `json:"id"`
	TaskAssignmentID *int64           `json:"task_assignment_id,omitempty"`
	InternID         *int64           `json:"intern_id,omitempty"`
	AssignedBy       int64            `json:"assigned_by"` // user_id (admin/pembimbing)
	Title            string           `json:"title"`
	Description      *string          `json:"description,omitempty"`
	Priority         string           `json:"priority"` // low, medium, high
	Status           string           `json:"status"`   // pending, scheduled, in_progress, submitted, revision, completed
	StartDate        *time.Time       `json:"start_date,omitempty"`
	Deadline         *time.Time       `json:"deadline,omitempty"`
	DeadlineTime     *string          `json:"deadline_time,omitempty"` // HH:MM:SS
	StartedAt        *time.Time       `json:"started_at,omitempty"`
	SubmittedAt      *time.Time       `json:"submitted_at,omitempty"`
	CompletedAt      *time.Time       `json:"completed_at,omitempty"`
	ApprovedAt       *time.Time       `json:"approved_at,omitempty"`
	IsLate           bool             `json:"is_late"`
	SubmissionNotes  *string          `json:"submission_notes,omitempty"`
	SubmissionLinks  []SubmissionLink `json:"submission_links,omitempty"`
	Score            *int             `json:"score,omitempty"`
	AdminFeedback    *string          `json:"admin_feedback,omitempty"`
	CreatedAt        time.Time        `json:"created_at"`
	UpdatedAt        time.Time        `json:"updated_at"`

	// Related data (optional joins)
	InternName     string `json:"intern_name,omitempty"`
	AssignedByName string `json:"assigned_by_name,omitempty"`
}

type TaskAssignment struct {
	ID           int64       `json:"id"`
	Title        string      `json:"title"`
	Description  *string     `json:"description,omitempty"`
	AssignedBy   int64       `json:"assigned_by"`
	Priority     string      `json:"priority"`
	StartDate    *time.Time  `json:"start_date,omitempty"`
	Deadline     *time.Time  `json:"deadline,omitempty"`
	DeadlineTime *string     `json:"deadline_time,omitempty"`
	AssignToAll  bool        `json:"assign_to_all"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`

	AssignedByName string `json:"assigned_by_name,omitempty"`
	TasksCount     int    `json:"tasks_count,omitempty"`
}

type TaskAttachment struct {
	ID         int64     `json:"id"`
	TaskID     int64     `json:"task_id"`
	FileName   string    `json:"file_name"`
	FilePath   string    `json:"file_path"`
	FileType   string    `json:"file_type"` // jpg, jpeg, png, pdf
	FileSize   int64     `json:"file_size"`
	UploadedAt time.Time `json:"uploaded_at"`
}
./internal/models/intern.go
package models

import (
	"database/sql"
	"time"
)

type Intern struct {
	ID                  int64         `json:"id"`
	UserID              int64         `json:"user_id"`
	InstitutionID       sql.NullInt64 `json:"institution_id"`
	SupervisorID        sql.NullInt64 `json:"supervisor_id"`
	FullName            string         `json:"full_name"`
	NIS                 sql.NullString `json:"nis"`
	StudentID           sql.NullString `json:"student_id"`
	School              sql.NullString `json:"school"`
	Department          sql.NullString `json:"department"`
	DateOfBirth         sql.NullTime  `json:"date_of_birth"`
	Gender              string        `json:"gender"` // male, female
	Phone               sql.NullString `json:"phone"`
	Address             sql.NullString `json:"address"`
	StartDate           time.Time     `json:"start_date"`
	EndDate             time.Time     `json:"end_date"`
	Status              string        `json:"status"` // pending, active, completed, cancelled, terminated
	CertificateNumber   sql.NullString `json:"certificate_number,omitempty"`
	CertificateIssuedAt sql.NullTime   `json:"certificate_issued_at,omitempty"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	
	// Related data (for joins)
	User        *User        `json:"user,omitempty"`
	Institution *Institution `json:"institution,omitempty"`
	Supervisor  *Supervisor  `json:"supervisor,omitempty"`
}

type InternWithDetails struct {
	Intern
	SupervisorName   string `json:"supervisor_name"`
	InstitutionName  string `json:"institution_name"`
	Email            string `json:"email"`
}
./internal/models/report.go
package models

import (
	"time"
)

type Report struct {
	ID          int64     `json:"id"`
	InternID    int64     `json:"intern_id"`
	CreatedBy   int64     `json:"created_by"`
	Title       string    `json:"title"`
	Content     string    `json:"content"`
	Type        string    `json:"type"`   // weekly, monthly, final
	PeriodStart time.Time `json:"period_start"`
	PeriodEnd   time.Time `json:"period_end"`
	Status      string    `json:"status"` // draft, submitted, reviewed
	Feedback    string    `json:"feedback,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`

	// Related data
	InternName   string `json:"intern_name,omitempty"`
	CreatedByName string `json:"created_by_name,omitempty"`
}
./internal/models/notification.go
package models

import (
	"database/sql"
	"time"
)

// Notification types
const (
	NotificationTaskAssigned       = "task_assigned"
	NotificationTaskDeadline       = "task_deadline"
	NotificationTaskApproved       = "task_approved"
	NotificationTaskRevision       = "task_revision"
	NotificationTaskSubmitted      = "task_submitted"
	NotificationNewIntern          = "new_intern_registration"
	NotificationNewSupervisor      = "new_supervisor_registration"
)

type Notification struct {
	ID        int64          `json:"id"`
	UserID    int64          `json:"user_id"`
	Type      string         `json:"type"`
	Title     string         `json:"title"`
	Message   string         `json:"message"`
	Icon      sql.NullString `json:"icon,omitempty"`
	Link      sql.NullString `json:"link,omitempty"`
	Data      sql.NullString `json:"data,omitempty"` // JSON string
	ReadAt    sql.NullTime   `json:"read_at,omitempty"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
}
./internal/models/assessment.go
package models

import (
	"database/sql"
	"time"
)

type Assessment struct {
	ID             int64          `json:"id"`
	InternID       int64          `json:"intern_id"`
	TaskID         sql.NullInt64  `json:"task_id,omitempty"`
	AssessedBy     int64          `json:"assessed_by"` // user_id (admin/pembimbing)
	Score          int            `json:"score"`       // 0-100 (average of criteria)
	Category       string         `json:"category"`    // auto-calculated: very_good, good, not_good, very_bad
	Aspect         string         `json:"aspect"`      // legacy: discipline, work_quality, attitude
	QualityScore   sql.NullInt64  `json:"quality_score,omitempty"`
	SpeedScore     sql.NullInt64  `json:"speed_score,omitempty"`
	InitiativeScore sql.NullInt64 `json:"initiative_score,omitempty"`
	TeamworkScore  sql.NullInt64  `json:"teamwork_score,omitempty"`
	CommunicationScore sql.NullInt64 `json:"communication_score,omitempty"`
	Strengths      sql.NullString `json:"strengths,omitempty"`
	Improvements   sql.NullString `json:"improvements,omitempty"`
	Comments       sql.NullString `json:"comments,omitempty"`
	Notes          sql.NullString `json:"notes,omitempty"`
	AssessmentDate time.Time      `json:"assessment_date"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	
	// Related data
	InternName    string `json:"intern_name,omitempty"`
	AssessorName  string `json:"assessor_name,omitempty"`
	TaskTitle     string `json:"task_title,omitempty"`
}

type CreateAssessmentRequest struct {
	InternID           int64   `json:"intern_id" validate:"required"`
	TaskID             *int64  `json:"task_id,omitempty"`
	QualityScore       int     `json:"quality_score" validate:"required,min=0,max=100"`
	SpeedScore         int     `json:"speed_score" validate:"required,min=0,max=100"`
	InitiativeScore    int     `json:"initiative_score" validate:"required,min=0,max=100"`
	TeamworkScore      int     `json:"teamwork_score" validate:"required,min=0,max=100"`
	CommunicationScore int     `json:"communication_score" validate:"required,min=0,max=100"`
	Strengths          string  `json:"strengths,omitempty"`
	Improvements       string  `json:"improvements,omitempty"`
	Comments           string  `json:"comments,omitempty"`
	Aspect             string  `json:"aspect,omitempty"`
	Notes              string  `json:"notes,omitempty"`
	AssessmentDate     time.Time `json:"assessment_date" validate:"required"`
}

type UpdateAssessmentRequest struct {
	QualityScore       int       `json:"quality_score,omitempty" validate:"omitempty,min=0,max=100"`
	SpeedScore         int       `json:"speed_score,omitempty" validate:"omitempty,min=0,max=100"`
	InitiativeScore    int       `json:"initiative_score,omitempty" validate:"omitempty,min=0,max=100"`
	TeamworkScore      int       `json:"teamwork_score,omitempty" validate:"omitempty,min=0,max=100"`
	CommunicationScore int       `json:"communication_score,omitempty" validate:"omitempty,min=0,max=100"`
	Strengths          string    `json:"strengths,omitempty"`
	Improvements       string    `json:"improvements,omitempty"`
	Comments           string    `json:"comments,omitempty"`
	Aspect             string    `json:"aspect,omitempty"`
	Notes              string    `json:"notes,omitempty"`
	AssessmentDate     time.Time `json:"assessment_date,omitempty"`
}

// GetCategory returns the category based on score
func (a *Assessment) GetCategory() string {
	if a.Score >= 85 {
		return "very_good"
	} else if a.Score >= 70 {
		return "good"
	} else if a.Score >= 50 {
		return "not_good"
	}
	return "very_bad"
}

// GetCategoryIndo returns Indonesian translation
func (a *Assessment) GetCategoryIndo() string {
	switch a.Category {
	case "very_good":
		return "Sangat Baik"
	case "good":
		return "Baik"
	case "not_good":
		return "Tidak Baik"
	case "very_bad":
		return "Sangat Tidak Baik"
	default:
		return ""
	}
}
./internal/database/mysql.go
package database

import (
	"database/sql"
	"fmt"
	"log"
	"time"

	"dsi_interna_sys/internal/config"

	_ "github.com/go-sql-driver/mysql"
)

var DB *sql.DB

// Connect establishes database connection
func Connect(cfg *config.Config) (*sql.DB, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true&charset=utf8mb4&collation=utf8mb4_unicode_ci",
		cfg.Database.User,
		cfg.Database.Password,
		cfg.Database.Host,
		cfg.Database.Port,
		cfg.Database.DBName,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, fmt.Errorf("error opening database: %w", err)
	}

	// Set connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	// Test connection
	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	log.Println("Database connected successfully")
	DB = db
	return db, nil
}

// Close closes the database connection
func Close() error {
	if DB != nil {
		return DB.Close()
	}
	return nil
}
./internal/config/config.go
package config

import (
	"log"
	"os"
	"strconv"
	"time"

	"github.com/joho/godotenv"
)

type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	JWT      JWTConfig
	Upload   UploadConfig
	Office   OfficeConfig
	App      AppConfig
	OAuth    OAuthConfig
	SMTP     SMTPConfig
}

type ServerConfig struct {
	Port string
	Host string
}

type DatabaseConfig struct {
	Host     string
	Port     string
	User     string
	Password string
	DBName   string
}

type JWTConfig struct {
	Secret string
	Expiry time.Duration
}

type UploadConfig struct {
	Dir         string
	MaxSize     int64
	AllowedExts []string
}

type OfficeConfig struct {
	Latitude             float64
	Longitude            float64
	Radius               float64
	AttendanceOpenTime   string // <--- NEW FIELD
	CheckInTime          string
	CheckOutTime         string
	LateToleranceMinutes int
}

type AppConfig struct {
	Name string
	Env  string
}

type OAuthConfig struct {
	GoogleClientID     string
	GoogleClientSecret string
	GoogleRedirectURL  string
	FrontendURL        string
}

type SMTPConfig struct {
	Host     string
	Port     string
	Username string
	Password string
	From     string
	UseTLS   bool
}

var Loaded *Config

// Load loads configuration from environment variables
func Load() (*Config, error) {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	jwtExpiry, err := time.ParseDuration(getEnv("JWT_EXPIRY", "24h"))
	if err != nil {
		jwtExpiry = 24 * time.Hour
	}

	maxUploadSize, err := strconv.ParseInt(getEnv("MAX_UPLOAD_SIZE", "5242880"), 10, 64)
	if err != nil {
		maxUploadSize = 5242880
	}

	latitude, err := strconv.ParseFloat(getEnv("OFFICE_LATITUDE", "-7.035549620262833"), 64)
	if err != nil {
		latitude = -7.035549620262833
	}

	longitude, err := strconv.ParseFloat(getEnv("OFFICE_LONGITUDE", "110.47464898482643"), 64)
	if err != nil {
		longitude = 110.47464898482643
	}

	radius, err := strconv.ParseFloat(getEnv("OFFICE_RADIUS", "1000"), 64)
	if err != nil {
		radius = 1000
	}

	lateTolerance, err := strconv.Atoi(getEnv("LATE_TOLERANCE_MINUTES", "15"))
	if err != nil {
		lateTolerance = 15
	}

	config := &Config{
		Server: ServerConfig{
			Port: getEnv("SERVER_PORT", "8080"),
			Host: getEnv("SERVER_HOST", "localhost"),
		},
		Database: DatabaseConfig{
			Host:     getEnv("DB_HOST", "localhost"),
			Port:     getEnv("DB_PORT", "3306"),
			User:     getEnv("DB_USER", "root"),
			Password: getEnv("DB_PASSWORD", ""),
			DBName:   getEnv("DB_NAME", "interna_db"),
		},
		JWT: JWTConfig{
			Secret: getEnv("JWT_SECRET", "change-this-secret-key"),
			Expiry: jwtExpiry,
		},
		Upload: UploadConfig{
			Dir:         getEnv("UPLOAD_DIR", "./uploads"),
			MaxSize:     maxUploadSize,
			AllowedExts: []string{".jpg", ".jpeg", ".png", ".pdf"},
		},
		Office: OfficeConfig{
			Latitude:             latitude,
			Longitude:            longitude,
			Radius:               radius,
			AttendanceOpenTime:   getEnv("ATTENDANCE_OPEN_TIME", "07:00:00"), // <--- NEW VALUE
			CheckInTime:          getEnv("CHECK_IN_TIME", "08:30:00"),
			CheckOutTime:         getEnv("CHECK_OUT_TIME", "16:00:00"),
			LateToleranceMinutes: lateTolerance,
		},
		App: AppConfig{
			Name: getEnv("APP_NAME", "INTERNA"),
			Env:  getEnv("APP_ENV", "development"),
		},
		OAuth: OAuthConfig{
			GoogleClientID:     getEnv("GOOGLE_CLIENT_ID", ""),
			GoogleClientSecret: getEnv("GOOGLE_CLIENT_SECRET", ""),
			GoogleRedirectURL:  getEnv("GOOGLE_REDIRECT_URL", ""),
			FrontendURL:        getEnv("FRONTEND_URL", "http://localhost:5173"),
		},
		SMTP: SMTPConfig{
			Host:     getEnv("SMTP_HOST", ""),
			Port:     getEnv("SMTP_PORT", "587"),
			Username: getEnv("SMTP_USERNAME", ""),
			Password: getEnv("SMTP_PASSWORD", ""),
			From:     getEnv("SMTP_FROM", ""),
			UseTLS:   getEnv("SMTP_USE_TLS", "false") == "true",
		},
	}

	Loaded = config
	return config, nil
}

func getEnv(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}
./internal/holiday/holiday.go
package holiday

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

const (
	apiURL = "https://api-harilibur.vercel.app/api"
)

// Holiday represents a single holiday.
type Holiday struct {
	Date string `json:"date"`
	Name string `json:"name"`
}

// APIHoliday represents the structure of a holiday from the external API.
type APIHoliday struct {
	HolidayDate     string `json:"holiday_date"`
	HolidayName     string `json:"holiday_name"`
	IsNationalHoliday bool   `json:"is_national_holiday"`
}

// GetHolidays fetches Indonesian national holidays for a given year.
// It uses an external API and has a fallback to a hardcoded list.
func GetHolidays(year int) ([]Holiday, error) {
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(apiURL)
	if err != nil {
		return getFallbackHolidays(year), fmt.Errorf("failed to get holidays from API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return getFallbackHolidays(year), fmt.Errorf("holiday API returned non-200 status code: %d", resp.StatusCode)
	}

	var apiHolidays []APIHoliday
	if err := json.NewDecoder(resp.Body).Decode(&apiHolidays); err != nil {
		return getFallbackHolidays(year), fmt.Errorf("failed to decode holiday API response: %w", err)
	}

	var holidays []Holiday
	for _, h := range apiHolidays {
		if !h.IsNationalHoliday {
			continue
		}
		holidayTime, err := time.Parse("2006-01-02", h.HolidayDate)
		if err != nil {
			// Skip invalid dates
			continue
		}
		if year != 0 && holidayTime.Year() != year {
			continue
		}
		holidays = append(holidays, Holiday{
			Date: holidayTime.Format("2006-01-02"),
			Name: h.HolidayName,
		})
	}

	return holidays, nil
}

// getFallbackHolidays returns a hardcoded list of holidays for a given year.
func getFallbackHolidays(year int) []Holiday {
	if year == 0 {
		year = time.Now().Year()
	}
	return []Holiday{
		{Date: fmt.Sprintf("%d-01-01", year), Name: "Tahun Baru Masehi"},
		{Date: fmt.Sprintf("%d-05-01", year), Name: "Hari Buruh Internasional"},
		{Date: fmt.Sprintf("%d-06-01", year), Name: "Hari Lahir Pancasila"},
		{Date: fmt.Sprintf("%d-08-17", year), Name: "Hari Kemerdekaan RI"},
		{Date: fmt.Sprintf("%d-12-25", year), Name: "Hari Raya Natal"},
	}
}
./internal/handlers/setting.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"
)

type SettingHandler struct {
	db *sql.DB
}

func NewSettingHandler(db *sql.DB) *SettingHandler {
	return &SettingHandler{db: db}
}

func (h *SettingHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if middleware.NormalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can view settings")
		return
	}

	rows, err := h.db.Query("SELECT id, `key`, `value`, `type`, description, created_at, updated_at FROM settings")
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch settings")
		return
	}
	defer rows.Close()

	var settings []models.Setting
	for rows.Next() {
		var s models.Setting
		if err := rows.Scan(&s.ID, &s.Key, &s.Value, &s.Type, &s.Description, &s.CreatedAt, &s.UpdatedAt); err == nil {
			settings = append(settings, s)
		}
	}

	utils.RespondSuccess(w, "Settings retrieved", settings)
}

func (h *SettingHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if middleware.NormalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update settings")
		return
	}

	var payload map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	for key, value := range payload {
		val := fmt.Sprint(value)
		query := "INSERT INTO settings (`key`, `value`) VALUES (?, ?) ON DUPLICATE KEY UPDATE `value` = VALUES(`value`)"
		if _, err := tx.Exec(query, key, val); err != nil {
			utils.RespondInternalError(w, "Failed to update settings")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit settings")
		return
	}

	utils.RespondSuccess(w, "Settings updated", nil)
}
./internal/handlers/dashboard.go
package handlers

import (
	"database/sql"
	"net/http"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/utils"
)

type DashboardHandler struct {
	db *sql.DB
}

func NewDashboardHandler(db *sql.DB) *DashboardHandler {
	return &DashboardHandler{db: db}
}

// GetInternDashboard returns dashboard data for intern view
func (h *DashboardHandler) GetInternDashboard(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	if claims.Role != "intern" {
		utils.RespondForbidden(w, "Only interns can access this dashboard")
		return
	}

	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	cfg := config.Loaded
	now := time.Now()
	weekStart := now.AddDate(0, 0, -6)

	// 1. Today's Attendance
	today := now.Format("2006-01-02")
	var todayAttendance struct {
		ID             sql.NullInt64
		CheckInTime    sql.NullTime
		CheckOutTime   sql.NullTime
		Status         sql.NullString
		LateReason     sql.NullString
		DistanceMeters sql.NullInt64
	}

	err = h.db.QueryRow(`
		SELECT id, check_in_time, check_out_time, status, late_reason, distance_meters
		FROM attendances WHERE intern_id = ? AND date = ?`, internID, today).Scan(
		&todayAttendance.ID, &todayAttendance.CheckInTime, &todayAttendance.CheckOutTime,
		&todayAttendance.Status, &todayAttendance.LateReason, &todayAttendance.DistanceMeters,
	)

	todayAtt := map[string]interface{}{
		"checked_in":    false,
		"checked_out":   false,
		"status":        nil,
		"check_in_time": nil,
		"distance":      nil,
	}

	if err == nil && todayAttendance.ID.Valid {
		todayAtt["checked_in"] = true
		if todayAttendance.CheckInTime.Valid {
			todayAtt["check_in_time"] = todayAttendance.CheckInTime.Time.Format("15:04")
		}
		if todayAttendance.Status.Valid {
			todayAtt["status"] = todayAttendance.Status.String
		}
		if todayAttendance.DistanceMeters.Valid {
			todayAtt["distance"] = int(todayAttendance.DistanceMeters.Int64)
		}
		if todayAttendance.CheckOutTime.Valid {
			todayAtt["checked_out"] = true
		}
	}

	// 2. Task Statistics
	var totalTasks, pendingTasks, inProgressTasks, completedTasks int
	err = h.db.QueryRow(`
		SELECT 
			COUNT(*) as total,
			SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
			SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
			SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed
		FROM task_assignments WHERE intern_id = ?`, internID).Scan(
		&totalTasks, &pendingTasks, &inProgressTasks, &completedTasks,
	)

	taskStats := map[string]interface{}{
		"total":       totalTasks,
		"pending":     pendingTasks,
		"in_progress": inProgressTasks,
		"completed":   completedTasks,
		"percentage":  0,
	}
	if totalTasks > 0 {
		taskStats["percentage"] = int(float64(completedTasks) / float64(totalTasks) * 100)
	}

	// 2.1 Task Breakdown for Pie Chart (including submitted and revision)
	var submittedTasks, revisionTasks int
	h.db.QueryRow(`
		SELECT 
			SUM(CASE WHEN status = 'submitted' THEN 1 ELSE 0 END) as submitted,
			SUM(CASE WHEN status = 'revision' THEN 1 ELSE 0 END) as revision
		FROM task_assignments WHERE intern_id = ?`, internID).Scan(&submittedTasks, &revisionTasks)

	taskBreakdown := map[string]interface{}{
		"pending":     pendingTasks,
		"in_progress": inProgressTasks,
		"submitted":   submittedTasks,
		"completed":   completedTasks,
		"revision":    revisionTasks,
	}

	// 2.2 Weekly Attendance Counts for Bar Chart (formatted for CSS charts)
	weeklyLabels := []string{}
	weeklyData := []int{}
	weeklyColors := []string{}

	for i := 0; i < 7; i++ {
		dayName := weekStart.AddDate(0, 0, i).Format("Mon")
		dayDate := weekStart.AddDate(0, 0, i).Format("2006-01-02")
		var attStatus sql.NullString

		h.db.QueryRow(`
			SELECT status FROM attendances WHERE intern_id = ? AND date = ?`, internID, dayDate).Scan(&attStatus)

		status := "absent"
		if attStatus.Valid {
			status = attStatus.String
		}

		weeklyLabels = append(weeklyLabels, dayName)

		// Color based on status for chart (Vercel-inspired colors)
		color := "#f43f5e" // absent - rose/red
		switch status {
		case "present":
			color = "#10b981" // emerald/green
		case "late":
			color = "#f59e0b" // amber/yellow
		case "sick", "permission":
			color = "#6366f1" // indigo/blue
		}
		weeklyColors = append(weeklyColors, color)

		// Data value: 1 for present/late/sick/permission, 0 for absent
		presentVal := 0
		if status != "absent" {
			presentVal = 1
		}
		weeklyData = append(weeklyData, presentVal)
	}

	weeklyAttendanceCounts := map[string]interface{}{
		"labels": weeklyLabels,
		"data":   weeklyData,
		"colors": weeklyColors,
	}

	// 3. Recent Tasks (5 latest)
	tasksRows, err := h.db.Query(`
		SELECT id, title, status, priority, deadline, deadline_time, submitted_at, grade, is_late
		FROM task_assignments 
		WHERE intern_id = ? 
		ORDER BY created_at DESC LIMIT 5`, internID)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch tasks")
		return
	}
	defer tasksRows.Close()

	var recentTasks []map[string]interface{}
	for tasksRows.Next() {
		var t struct {
			ID           sql.NullInt64
			Title        sql.NullString
			Status       sql.NullString
			Priority     sql.NullString
			Deadline     sql.NullTime
			DeadlineTime sql.NullString
			SubmittedAt  sql.NullTime
			Grade        sql.NullString
			IsLate       sql.NullBool
		}
		tasksRows.Scan(&t.ID, &t.Title, &t.Status, &t.Priority, &t.Deadline, &t.DeadlineTime, &t.SubmittedAt, &t.Grade, &t.IsLate)

		task := map[string]interface{}{
			"id":       int(t.ID.Int64),
			"title":    t.Title.String,
			"status":   t.Status.String,
			"priority": t.Priority.String,
		}

		if t.Deadline.Valid {
			task["deadline"] = t.Deadline.Time.Format("2006-01-02")
		}
		if t.DeadlineTime.Valid {
			task["deadline_time"] = t.DeadlineTime.String
		}
		if t.SubmittedAt.Valid {
			task["submitted_at"] = t.SubmittedAt.Time.Format("2006-01-02T15:04:05")
		}
		if t.Grade.Valid {
			task["grade"] = t.Grade.String
		}
		task["is_late"] = t.IsLate.Bool

		recentTasks = append(recentTasks, task)
	}

	// 4. Weekly Attendance (last 7 days) - detailed version for list
	weeklyAttendance := []map[string]interface{}{}

	for i := 0; i < 7; i++ {
		date := weekStart.AddDate(0, 0, i).Format("2006-01-02")
		var attStatus sql.NullString

		h.db.QueryRow(`
			SELECT status FROM attendances WHERE intern_id = ? AND date = ?`, internID, date).Scan(&attStatus)

		status := "absent"
		if attStatus.Valid {
			status = attStatus.String
		}

		dayName := weekStart.AddDate(0, 0, i).Format("Mon")
		weeklyAttendance = append(weeklyAttendance, map[string]interface{}{
			"date":   date,
			"day":    dayName,
			"status": status,
		})
	}

	// 5. Attendance Percentage (last 30 days)
	var totalDays, presentDays int
	h.db.QueryRow(`
		SELECT 
			COUNT(*) as total,
			SUM(CASE WHEN status IN ('present', 'late') THEN 1 ELSE 0 END) as present
		FROM attendances 
		WHERE intern_id = ? AND date >= ?`,
		internID, now.AddDate(0, 0, -30).Format("2006-01-02")).Scan(&totalDays, &presentDays)

	attendancePercentage := 0
	if totalDays > 0 {
		attendancePercentage = int(float64(presentDays) / float64(totalDays) * 100)
	}

	// 6. Recent Attendance History (last 5)
	attendanceRows, err := h.db.Query(`
		SELECT date, status, check_in_time 
		FROM attendances 
		WHERE intern_id = ? 
		ORDER BY date DESC LIMIT 5`, internID)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch attendance history")
		return
	}
	defer attendanceRows.Close()

	var attendanceHistory []map[string]interface{}
	for attendanceRows.Next() {
		var date sql.NullTime
		var status, checkInTime sql.NullString

		attendanceRows.Scan(&date, &status, &checkInTime)

		attendanceHistory = append(attendanceHistory, map[string]interface{}{
			"date":     date.Time.Format("2006-01-02"),
			"status":   status.String,
			"check_in": checkInTime.String,
		})
	}

	// 7. Office config for map
	officeConfig := map[string]interface{}{
		"latitude":  cfg.Office.Latitude,
		"longitude": cfg.Office.Longitude,
		"radius":    cfg.Office.Radius,
		"name":      "PT. DUTA SOLUSI INFORMATIKA",
	}

	// Get user name from database
	var userName string
	h.db.QueryRow("SELECT name FROM users WHERE id = ?", claims.UserID).Scan(&userName)

	utils.RespondSuccess(w, "Dashboard data retrieved", map[string]interface{}{
		"today_attendance":         todayAtt,
		"task_stats":               taskStats,
		"task_breakdown":           taskBreakdown,
		"recent_tasks":             recentTasks,
		"weekly_attendance":        weeklyAttendance,
		"weekly_attendance_counts": weeklyAttendanceCounts,
		"attendance_percentage":    attendancePercentage,
		"attendance_history":       attendanceHistory,
		"office":                   officeConfig,
		"user": map[string]interface{}{
			"name": userName,
			"role": claims.Role,
		},
	})
}

// GetAdminDashboard returns dashboard data for admin/supervisor view
func (h *DashboardHandler) GetAdminDashboard(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	if claims.Role == "intern" {
		utils.RespondForbidden(w, "Access denied")
		return
	}

	now := time.Now()

	// 1. Total Interns
	var totalInterns int
	h.db.QueryRow("SELECT COUNT(*) FROM interns WHERE status = 'active'").Scan(&totalInterns)

	// 2. Total Tasks
	var totalTasks int
	h.db.QueryRow("SELECT COUNT(*) FROM task_assignments").Scan(&totalTasks)

	// 3. Task Completion Stats
	var completedOnTime, completedLate, pendingTasks int
	h.db.QueryRow(`
		SELECT 
			SUM(CASE WHEN status = 'completed' AND is_late = 0 THEN 1 ELSE 0 END) as on_time,
			SUM(CASE WHEN status = 'completed' AND is_late = 1 THEN 1 ELSE 0 END) as late,
			SUM(CASE WHEN status IN ('pending', 'in_progress', 'submitted') THEN 1 ELSE 0 END) as pending
		FROM task_assignments`).Scan(&completedOnTime, &completedLate, &pendingTasks)

	// 4. Today's Attendance
	today := now.Format("2006-01-02")
	var presentToday, totalToday int
	h.db.QueryRow(`
		SELECT 
			COUNT(CASE WHEN status IN ('present', 'late') THEN 1 END) as present,
			COUNT(*) as total
		FROM attendances WHERE date = ?`, today).Scan(&presentToday, &totalToday)

	// 5. Recent Tasks
	tasksRows, err := h.db.Query(`
		SELECT ta.id, ta.title, ta.status, ta.deadline, ta.is_late, u.name as intern_name
		FROM task_assignments ta
		JOIN interns i ON ta.intern_id = i.id
		JOIN users u ON i.user_id = u.id
		ORDER BY ta.created_at DESC LIMIT 5`)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch tasks")
		return
	}
	defer tasksRows.Close()

	var recentTasks []map[string]interface{}
	for tasksRows.Next() {
		var t struct {
			ID         sql.NullInt64
			Title      sql.NullString
			Status     sql.NullString
			Deadline   sql.NullTime
			IsLate     sql.NullBool
			InternName sql.NullString
		}
		tasksRows.Scan(&t.ID, &t.Title, &t.Status, &t.Deadline, &t.IsLate, &t.InternName)

		recentTasks = append(recentTasks, map[string]interface{}{
			"id":          int(t.ID.Int64),
			"title":       t.Title.String,
			"status":      t.Status.String,
			"intern_name": t.InternName.String,
			"is_late":     t.IsLate.Bool,
		})
	}

	// 6. Today's Attendance Records
	attendanceRows, err := h.db.Query(`
		SELECT a.id, a.status, a.check_in_time, u.name, a.distance_meters
		FROM attendances a
		JOIN interns i ON a.intern_id = i.id
		JOIN users u ON i.user_id = u.id
		WHERE a.date = ?
		ORDER BY a.created_at DESC`, today)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch attendance")
		return
	}
	defer attendanceRows.Close()

	var todayAttendance []map[string]interface{}
	for attendanceRows.Next() {
		var a struct {
			ID             sql.NullInt64
			Status         sql.NullString
			CheckInTime    sql.NullTime
			InternName     sql.NullString
			DistanceMeters sql.NullInt64
		}
		attendanceRows.Scan(&a.ID, &a.Status, &a.CheckInTime, &a.InternName, &a.DistanceMeters)

		att := map[string]interface{}{
			"intern_name": a.InternName.String,
			"status":      a.Status.String,
		}
		if a.CheckInTime.Valid {
			att["check_in_time"] = a.CheckInTime.Time.Format("15:04")
		}
		if a.DistanceMeters.Valid {
			att["distance"] = int(a.DistanceMeters.Int64)
		}
		todayAttendance = append(todayAttendance, att)
	}

	// 7. Weekly Attendance Trend
	weeklyTrend := []map[string]interface{}{}
	weekStart := now.AddDate(0, 0, -6)

	for i := 0; i < 7; i++ {
		date := weekStart.AddDate(0, 0, i).Format("2006-01-02")
		var present, absent int
		h.db.QueryRow(`
			SELECT 
				COUNT(CASE WHEN status IN ('present', 'late') THEN 1 END) as present,
				COUNT(CASE WHEN status NOT IN ('present', 'late', 'sick', 'permission') THEN 1 END) as absent
			FROM attendances WHERE date = ?`, date).Scan(&present, &absent)

		dayName := weekStart.AddDate(0, 0, i).Format("Mon")
		weeklyTrend = append(weeklyTrend, map[string]interface{}{
			"date":    date,
			"day":     dayName,
			"present": present,
			"absent":  absent,
		})
	}

	utils.RespondSuccess(w, "Admin dashboard data retrieved", map[string]interface{}{
		"stats": map[string]interface{}{
			"total_interns":     totalInterns,
			"total_tasks":       totalTasks,
			"completed_on_time": completedOnTime,
			"completed_late":    completedLate,
			"pending_tasks":     pendingTasks,
			"present_today":     presentToday,
			"total_today":       totalToday,
		},
		"recent_tasks":     recentTasks,
		"today_attendance": todayAttendance,
		"weekly_trend":     weeklyTrend,
	})
}
./internal/handlers/leave.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type LeaveHandler struct {
	db *sql.DB
}

func NewLeaveHandler(db *sql.DB) *LeaveHandler {
	return &LeaveHandler{db: db}
}

// Create handles the submission of Sick/Permission letters
// It expects multipart/form-data
func (h *LeaveHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	// 1. Parse Multipart Form (10MB max memory)
	if err := r.ParseMultipartForm(10 << 20); err != nil {
		utils.RespondBadRequest(w, "Failed to parse form data")
		return
	}

	// 2. Extract Fields
	leaveType := r.FormValue("leave_type")
	reason := r.FormValue("reason")
	startDateStr := r.FormValue("start_date")
	endDateStr := r.FormValue("end_date")

	// 3. Validate Inputs
	if leaveType != "sick" && leaveType != "permission" && leaveType != "other" {
		utils.RespondBadRequest(w, "Invalid leave type. Must be: sick, permission, other")
		return
	}
	if reason == "" {
		utils.RespondBadRequest(w, "Reason is required")
		return
	}

	startDate, err := time.Parse("2006-01-02", startDateStr)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid start_date format (YYYY-MM-DD)")
		return
	}
	endDate, err := time.Parse("2006-01-02", endDateStr)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid end_date format (YYYY-MM-DD)")
		return
	}
	if endDate.Before(startDate) {
		utils.RespondBadRequest(w, "End date cannot be before start date")
		return
	}

	// 4. Handle File Upload (Proof)
	var attachmentPath sql.NullString
	file, header, err := r.FormFile("attachment")

	// If Sick, file is mandatory (Logic ported from Laravel)
	if leaveType == "sick" && err != nil {
		utils.RespondBadRequest(w, "Attachment (Doctor's Note) is required for sick leave")
		return
	}

	if err == nil {
		defer file.Close()
		// Use existing utils.UploadFile
		path, err := utils.UploadFile(file, header, "leaves")
		if err != nil {
			utils.RespondInternalError(w, "Failed to upload file: "+err.Error())
			return
		}
		attachmentPath = sql.NullString{String: path, Valid: true}
	}

	// 5. Get Intern ID
	var internID int64
	err = h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID)
	if err != nil {
		utils.RespondNotFound(w, "Intern profile not found")
		return
	}

	// 6. Insert into DB
	query := `
		INSERT INTO leave_requests (intern_id, leave_type, start_date, end_date, reason, attachment_path, status, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, 'pending', NOW(), NOW())
	`
	res, err := h.db.Exec(query, internID, leaveType, startDate, endDate, reason, attachmentPath)
	if err != nil {
		utils.RespondInternalError(w, "Database error: "+err.Error())
		return
	}

	id, _ := res.LastInsertId()
	utils.RespondCreated(w, "Leave request submitted successfully", map[string]int64{"id": id})
}

func (h *LeaveHandler) GetByInternID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	// Security: Interns can only see their own leaves
	if claims.Role == "intern" {
		var myInternID int64
		h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID)
		if internID != myInternID {
			utils.RespondForbidden(w, "You can only view your own requests")
			return
		}
	}

	rows, err := h.db.Query(`
		SELECT id, leave_type, start_date, end_date, reason, attachment_path, status, created_at 
		FROM leave_requests 
		WHERE intern_id = ? 
		ORDER BY created_at DESC`, internID)
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	defer rows.Close()

	var leaves []models.LeaveRequest
	for rows.Next() {
		var l models.LeaveRequest
		var att sql.NullString
		if err := rows.Scan(&l.ID, &l.LeaveType, &l.StartDate, &l.EndDate, &l.Reason, &att, &l.Status, &l.CreatedAt); err != nil {
			continue
		}
		if att.Valid {
			path := att.String
			l.AttachmentPath = &path
		}
		l.InternID = internID
		leaves = append(leaves, l)
	}

	utils.RespondSuccess(w, "Leave requests retrieved", leaves)
}

// Approve handles Supervisor approval
func (h *LeaveHandler) Approve(w http.ResponseWriter, r *http.Request) {
	h.updateStatus(w, r, "approved")
}

// Reject handles Supervisor rejection
func (h *LeaveHandler) Reject(w http.ResponseWriter, r *http.Request) {
	h.updateStatus(w, r, "rejected")
}

func (h *LeaveHandler) updateStatus(w http.ResponseWriter, r *http.Request, status string) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	// Only Supervisors/Admins can approve
	if claims.Role == "intern" {
		utils.RespondForbidden(w, "Interns cannot approve requests")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		UPDATE leave_requests 
		SET status = ?, approved_by = ?, approved_at = NOW(), updated_at = NOW() 
		WHERE id = ?`

	_, err := h.db.Exec(query, status, claims.UserID, id) // Note: approved_by stores UserID of supervisor
	if err != nil {
		utils.RespondInternalError(w, "Failed to update status")
		return
	}

	utils.RespondSuccess(w, "Leave request "+status, nil)
}

// GetAll lists leave requests (admin/pembimbing)
func (h *LeaveHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can view all leaves")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	status := r.URL.Query().Get("status")
	internFilter := r.URL.Query().Get("intern_id")

	where := []string{}
	args := []interface{}{}
	if status != "" {
		where = append(where, "l.status = ?")
		args = append(args, status)
	}
	if internFilter != "" {
		if id, err := strconv.ParseInt(internFilter, 10, 64); err == nil {
			where = append(where, "l.intern_id = ?")
			args = append(args, id)
		}
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
		FROM leave_requests l
		LEFT JOIN interns i ON l.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON l.approved_by = au.id
	`

	var total int64
	if err := h.db.QueryRow("SELECT COUNT(*) "+baseFrom+" "+whereClause, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count leave requests")
		return
	}

	query := `
		SELECT l.id, l.intern_id, l.leave_type, l.start_date, l.end_date, l.reason, l.attachment_path, l.status,
		       l.approved_by, l.approved_at, l.created_at, l.updated_at,
		       iu.name, au.name
	` + baseFrom + " " + whereClause + " ORDER BY l.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)
	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch leave requests")
		return
	}
	defer rows.Close()

	var leaves []models.LeaveRequest
	for rows.Next() {
		var l models.LeaveRequest
		var attachment sql.NullString
		var approverID sql.NullInt64
		var approverAt sql.NullTime
		var internName, approverName sql.NullString

		if err := rows.Scan(
			&l.ID, &l.InternID, &l.LeaveType, &l.StartDate, &l.EndDate, &l.Reason, &attachment, &l.Status,
			&approverID, &approverAt, &l.CreatedAt, &l.UpdatedAt,
			&internName, &approverName,
		); err == nil {
			if attachment.Valid {
				path := attachment.String
				l.AttachmentPath = &path
			}
			if approverID.Valid {
				id := approverID.Int64
				l.ApprovedBy = &id
			}
			if approverAt.Valid {
				t := approverAt.Time
				l.ApprovedAt = &t
			}
			if internName.Valid {
				l.InternName = internName.String
			}
			if approverName.Valid {
				l.ApproverName = approverName.String
			}
			leaves = append(leaves, l)
		}
	}

	utils.RespondPaginated(w, leaves, utils.CalculatePagination(page, limit, total))
}

func (h *LeaveHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		SELECT l.id, l.intern_id, l.leave_type, l.start_date, l.end_date, l.reason, l.attachment_path, l.status,
		       l.approved_by, l.approved_at, l.created_at, l.updated_at,
		       iu.name, au.name
		FROM leave_requests l
		LEFT JOIN interns i ON l.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON l.approved_by = au.id
		WHERE l.id = ?
	`

	var l models.LeaveRequest
	var attachment sql.NullString
	var approverID sql.NullInt64
	var approverAt sql.NullTime
	var internName, approverName sql.NullString

	err := h.db.QueryRow(query, id).Scan(
		&l.ID, &l.InternID, &l.LeaveType, &l.StartDate, &l.EndDate, &l.Reason, &attachment, &l.Status,
		&approverID, &approverAt, &l.CreatedAt, &l.UpdatedAt,
		&internName, &approverName,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Leave request not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	// Access check for interns
	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != l.InternID {
			utils.RespondForbidden(w, "You do not have access to this request")
			return
		}
	}

	if attachment.Valid {
		path := attachment.String
		l.AttachmentPath = &path
	}
	if approverID.Valid {
		id := approverID.Int64
		l.ApprovedBy = &id
	}
	if approverAt.Valid {
		t := approverAt.Time
		l.ApprovedAt = &t
	}
	if internName.Valid {
		l.InternName = internName.String
	}
	if approverName.Valid {
		l.ApproverName = approverName.String
	}

	utils.RespondSuccess(w, "Leave request retrieved", l)
}

func (h *LeaveHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	// Load existing request
	var existing struct {
		InternID int64
		Status   string
	}
	err := h.db.QueryRow("SELECT intern_id, status FROM leave_requests WHERE id = ?", id).Scan(&existing.InternID, &existing.Status)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Leave request not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != existing.InternID {
			utils.RespondForbidden(w, "You do not have access to this request")
			return
		}
		if existing.Status != "pending" {
			utils.RespondForbidden(w, "Only pending requests can be updated")
			return
		}
	}

	var payload struct {
		LeaveType string `json:"leave_type"`
		Reason    string `json:"reason"`
		StartDate string `json:"start_date"`
		EndDate   string `json:"end_date"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	updates := []string{}
	args := []interface{}{}
	if payload.LeaveType != "" {
		updates = append(updates, "leave_type = ?")
		args = append(args, payload.LeaveType)
	}
	if payload.Reason != "" {
		updates = append(updates, "reason = ?")
		args = append(args, payload.Reason)
	}
	if payload.StartDate != "" {
		if parsed, err := time.Parse("2006-01-02", payload.StartDate); err == nil {
			updates = append(updates, "start_date = ?")
			args = append(args, parsed)
		}
	}
	if payload.EndDate != "" {
		if parsed, err := time.Parse("2006-01-02", payload.EndDate); err == nil {
			updates = append(updates, "end_date = ?")
			args = append(args, parsed)
		}
	}

	if len(updates) == 0 {
		utils.RespondBadRequest(w, "No updates provided")
		return
	}

	args = append(args, id)
	if _, err := h.db.Exec("UPDATE leave_requests SET "+strings.Join(updates, ", ")+" WHERE id = ?", args...); err != nil {
		utils.RespondInternalError(w, "Failed to update request")
		return
	}

	utils.RespondSuccess(w, "Leave request updated", nil)
}

func (h *LeaveHandler) UploadAttachment(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	// Ensure access
	var internID int64
	if err := h.db.QueryRow("SELECT intern_id FROM leave_requests WHERE id = ?", id).Scan(&internID); err != nil {
		utils.RespondNotFound(w, "Leave request not found")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != internID {
			utils.RespondForbidden(w, "You do not have access to this request")
			return
		}
	}

	if err := r.ParseMultipartForm(10 << 20); err != nil {
		utils.RespondBadRequest(w, "Failed to parse form data")
		return
	}

	file, header, err := r.FormFile("attachment")
	if err != nil {
		utils.RespondBadRequest(w, "Missing attachment")
		return
	}
	defer file.Close()

	path, err := utils.UploadFile(file, header, "leaves")
	if err != nil {
		utils.RespondInternalError(w, "Failed to upload attachment")
		return
	}

	if _, err := h.db.Exec("UPDATE leave_requests SET attachment_path = ? WHERE id = ?", path, id); err != nil {
		utils.RespondInternalError(w, "Failed to update attachment")
		return
	}

	utils.RespondSuccess(w, "Attachment uploaded", map[string]string{"path": path})
}
./internal/handlers/analytics.go
package handlers

import (
	"database/sql"
	"net/http"
	"strconv"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type AnalyticsHandler struct {
	db *sql.DB
}

func NewAnalyticsHandler(db *sql.DB) *AnalyticsHandler {
	return &AnalyticsHandler{db: db}
}

// GetWeeklyTrends returns weekly attendance trends for an intern
func (h *AnalyticsHandler) GetWeeklyTrends(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, err := strconv.ParseInt(vars["id"], 10, 64)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid intern ID")
		return
	}

	// Get week parameter (default: current week)
	weekOffset := 0
	if offset := r.URL.Query().Get("week_offset"); offset != "" {
		weekOffset, _ = strconv.Atoi(offset)
	}

	// Calculate week start (Monday) and end (Sunday)
	now := time.Now()
	weekStart := startOfWeek(now.AddDate(0, 0, weekOffset*7))
	weekEnd := weekStart.AddDate(0, 0, 6)

	// Get intern name
	var internName string
	err = h.db.QueryRow("SELECT full_name FROM interns WHERE id = ?", internID).Scan(&internName)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	// Get daily attendance records for the week
	query := `
		SELECT date, check_in_time, status, late_reason
		FROM attendances
		WHERE intern_id = ? AND date BETWEEN ? AND ?
		ORDER BY date ASC
	`

	rows, err := h.db.Query(query, internID, weekStart.Format("2006-01-02"), weekEnd.Format("2006-01-02"))
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	defer rows.Close()

	// Map date to attendance record
	attendanceMap := make(map[string]models.DailyAttendanceStats)
	for rows.Next() {
		var date time.Time
		var checkInTime sql.NullTime
		var status string
		var lateReason sql.NullString

		if err := rows.Scan(&date, &checkInTime, &status, &lateReason); err != nil {
			continue
		}

		stats := models.DailyAttendanceStats{
			Date:      date,
			DayOfWeek: date.Weekday().String(),
			Status:    status,
		}

		if checkInTime.Valid {
			stats.CheckInTime = &checkInTime.Time
			hour := checkInTime.Time.Hour()
			minute := checkInTime.Time.Minute()
			stats.CheckInHour = &hour
			stats.CheckInMinute = &minute

			// Calculate minutes late
			if status == "late" {
				minutesLate := h.calculateMinutesLate(checkInTime.Time)
				stats.MinutesLate = &minutesLate

				if lateReason.Valid {
					stats.LateReason = &lateReason.String
				}
			}
		}

		attendanceMap[date.Format("2006-01-02")] = stats
	}

	// Build daily records for entire week (including days without records)
	var dailyRecords []models.DailyAttendanceStats
	for i := 0; i < 7; i++ {
		date := weekStart.AddDate(0, 0, i)
		dateStr := date.Format("2006-01-02")

		if record, exists := attendanceMap[dateStr]; exists {
			dailyRecords = append(dailyRecords, record)
		} else {
			// No record for this day
			dailyRecords = append(dailyRecords, models.DailyAttendanceStats{
				Date:      date,
				DayOfWeek: date.Weekday().String(),
				Status:    "absent",
			})
		}
	}

	// Calculate weekly summary
	summary := h.calculateWeeklySummary(dailyRecords)

	trends := models.AttendanceTrends{
		InternID:     internID,
		InternName:   internName,
		WeekStart:    weekStart,
		WeekEnd:      weekEnd,
		DailyRecords: dailyRecords,
		Summary:      summary,
	}

	utils.RespondSuccess(w, "Weekly trends retrieved successfully", trends)
}

// GetCheckInPatterns returns hourly distribution of check-ins
func (h *AnalyticsHandler) GetCheckInPatterns(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, err := strconv.ParseInt(vars["id"], 10, 64)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid intern ID")
		return
	}

	// Get date range (default: last 30 days)
	days := 30
	if d := r.URL.Query().Get("days"); d != "" {
		days, _ = strconv.Atoi(d)
	}

	startDate := time.Now().AddDate(0, 0, -days).Format("2006-01-02")

	// Query to get hourly distribution
	query := `
		SELECT HOUR(check_in_time) as hour, COUNT(*) as count
		FROM attendances
		WHERE intern_id = ? AND date >= ? AND check_in_time IS NOT NULL
		GROUP BY HOUR(check_in_time)
		ORDER BY hour ASC
	`

	rows, err := h.db.Query(query, internID, startDate)
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	defer rows.Close()

	var patterns []models.CheckInPattern
	var total int

	// Get counts per hour
	hourCounts := make(map[int]int)
	for rows.Next() {
		var hour, count int
		if err := rows.Scan(&hour, &count); err != nil {
			continue
		}
		hourCounts[hour] = count
		total += count
	}

	// Build pattern array with percentages
	for hour := 0; hour < 24; hour++ {
		count := hourCounts[hour]
		percentage := 0.0
		if total > 0 {
			percentage = float64(count) / float64(total) * 100
		}

		patterns = append(patterns, models.CheckInPattern{
			Hour:       hour,
			Count:      count,
			Percentage: percentage,
		})
	}

	utils.RespondSuccess(w, "Check-in patterns retrieved successfully", map[string]interface{}{
		"intern_id":       internID,
		"period":          strconv.Itoa(days) + " days",
		"total_check_ins": total,
		"patterns":        patterns,
	})
}

// GetPerformanceInsights generates AI-like insights for an intern
func (h *AnalyticsHandler) GetPerformanceInsights(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, err := strconv.ParseInt(vars["id"], 10, 64)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid intern ID")
		return
	}

	// Get intern name
	var internName string
	err = h.db.QueryRow("SELECT full_name FROM interns WHERE id = ?", internID).Scan(&internName)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	// Analyze last 4 weeks
	weeks := 4
	startDate := time.Now().AddDate(0, 0, -weeks*7).Format("2006-01-02")

	// Get attendance statistics
	var totalDays, presentDays, lateDays, absentDays int
	var avgCheckInMinutes sql.NullFloat64

	statsQuery := `
		SELECT 
			COUNT(*) as total_days,
			SUM(CASE WHEN status IN ('present', 'late') THEN 1 ELSE 0 END) as present_days,
			SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) as late_days,
			SUM(CASE WHEN status = 'absent' THEN 1 ELSE 0 END) as absent_days,
			AVG(CASE WHEN check_in_time IS NOT NULL 
				THEN HOUR(check_in_time) * 60 + MINUTE(check_in_time) 
				ELSE NULL END) as avg_check_in_minutes
		FROM attendances
		WHERE intern_id = ? AND date >= ?
	`

	err = h.db.QueryRow(statsQuery, internID, startDate).Scan(
		&totalDays, &presentDays, &lateDays, &absentDays, &avgCheckInMinutes,
	)
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	// Calculate rates
	attendanceRate := 0.0
	punctualityRate := 0.0
	if totalDays > 0 {
		attendanceRate = float64(presentDays) / float64(totalDays) * 100
		if presentDays > 0 {
			punctualityRate = float64(presentDays-lateDays) / float64(presentDays) * 100
		}
	}

	// Generate insights
	var strengths []string
	var concerns []string
	var suggestions []string

	// Analyze attendance
	if attendanceRate >= 95 {
		strengths = append(strengths, "Excellent attendance record ("+strconv.FormatFloat(attendanceRate, 'f', 1, 64)+"%)")
	} else if attendanceRate >= 85 {
		strengths = append(strengths, "Good attendance record")
	} else if attendanceRate < 75 {
		concerns = append(concerns, "Low attendance rate ("+strconv.FormatFloat(attendanceRate, 'f', 1, 64)+"%)")
		suggestions = append(suggestions, "Focus on improving daily attendance")
	}

	// Analyze punctuality
	if punctualityRate >= 90 {
		strengths = append(strengths, "Consistently punctual")
	} else if punctualityRate >= 70 {
		suggestions = append(suggestions, "Try to arrive on time more consistently")
	} else if punctualityRate < 70 {
		concerns = append(concerns, "Frequently arrives late")
		suggestions = append(suggestions, "Consider adjusting morning routine to arrive earlier")
	}

	// Analyze check-in time
	cfg := config.Loaded
	checkInTime, _ := time.Parse("15:04:05", cfg.Office.CheckInTime)
	expectedMinutes := float64(checkInTime.Hour()*60 + checkInTime.Minute())

	if avgCheckInMinutes.Valid {
		diff := avgCheckInMinutes.Float64 - expectedMinutes
		if diff < -10 {
			strengths = append(strengths, "Usually arrives early")
		} else if diff > 15 {
			concerns = append(concerns, "Average arrival time is after scheduled start")
		}
	}

	// Calculate overall score
	overallScore := int((attendanceRate*0.5 + punctualityRate*0.5))

	insights := models.PerformanceInsights{
		InternID:     internID,
		InternName:   internName,
		Period:       "Last " + strconv.Itoa(weeks) + " weeks",
		Strengths:    strengths,
		Concerns:     concerns,
		Suggestions:  suggestions,
		OverallScore: overallScore,
	}

	utils.RespondSuccess(w, "Performance insights generated successfully", insights)
}

// Helper: Calculate weekly summary
func (h *AnalyticsHandler) calculateWeeklySummary(dailyRecords []models.DailyAttendanceStats) models.WeeklySummary {
	var summary models.WeeklySummary
	summary.TotalDays = len(dailyRecords)

	var checkInMinutes []int
	var earliestCheckIn, latestCheckIn *time.Time

	for _, record := range dailyRecords {
		switch record.Status {
		case "present":
			summary.PresentDays++
		case "late":
			summary.LateDays++
			summary.PresentDays++ // Late still counts as present
		case "absent":
			summary.AbsentDays++
		case "on_leave", "sick", "permission":
			summary.OnLeaveDays++
		}

		// Collect check-in times for average calculation
		if record.CheckInTime != nil {
			minutes := record.CheckInTime.Hour()*60 + record.CheckInTime.Minute()
			checkInMinutes = append(checkInMinutes, minutes)

			if earliestCheckIn == nil || record.CheckInTime.Before(*earliestCheckIn) {
				earliestCheckIn = record.CheckInTime
			}
			if latestCheckIn == nil || record.CheckInTime.After(*latestCheckIn) {
				latestCheckIn = record.CheckInTime
			}
		}
	}

	// Calculate rates
	if summary.TotalDays > 0 {
		summary.AttendanceRate = float64(summary.PresentDays) / float64(summary.TotalDays) * 100
		if summary.PresentDays > 0 {
			onTimeDays := summary.PresentDays - summary.LateDays
			summary.PunctualityRate = float64(onTimeDays) / float64(summary.PresentDays) * 100
		}
	}

	// Calculate average check-in time
	if len(checkInMinutes) > 0 {
		sum := 0
		for _, m := range checkInMinutes {
			sum += m
		}
		avgMinutes := sum / len(checkInMinutes)
		hours := avgMinutes / 60
		minutes := avgMinutes % 60
		summary.AverageCheckInTime = time.Date(0, 1, 1, hours, minutes, 0, 0, time.UTC).Format("15:04")
	}

	summary.EarliestCheckIn = earliestCheckIn
	summary.LatestCheckIn = latestCheckIn

	// Determine tendency
	summary.Tendency = h.determineTendency(summary.LateDays, summary.PresentDays, checkInMinutes)

	return summary
}

// Helper: Determine attendance tendency
func (h *AnalyticsHandler) determineTendency(lateDays, presentDays int, checkInMinutes []int) string {
	if presentDays == 0 {
		return "no_data"
	}

	lateRate := float64(lateDays) / float64(presentDays)

	if lateRate > 0.5 {
		return "frequently_late"
	}

	if len(checkInMinutes) == 0 {
		return "inconsistent"
	}

	// Calculate variance
	sum := 0
	for _, m := range checkInMinutes {
		sum += m
	}
	avg := sum / len(checkInMinutes)

	// Get standard office start time
	cfg := config.Loaded
	checkInTime, _ := time.Parse("15:04:05", cfg.Office.CheckInTime)
	expectedMinutes := checkInTime.Hour()*60 + checkInTime.Minute()

	if avg < expectedMinutes-10 {
		return "early_bird"
	} else if avg <= expectedMinutes+5 {
		return "on_time"
	} else {
		return "inconsistent"
	}
}

// Helper: Calculate minutes late
func (h *AnalyticsHandler) calculateMinutesLate(checkInTime time.Time) int {
	cfg := config.Loaded
	expectedTime, _ := time.Parse("15:04:05", cfg.Office.CheckInTime)

	expected := time.Date(
		checkInTime.Year(), checkInTime.Month(), checkInTime.Day(),
		expectedTime.Hour(), expectedTime.Minute(), 0, 0, checkInTime.Location(),
	)
	expected = expected.Add(time.Duration(cfg.Office.LateToleranceMinutes) * time.Minute)

	if checkInTime.After(expected) {
		return int(checkInTime.Sub(expected).Minutes())
	}
	return 0
}

// Helper: Get start of week (Monday)
func startOfWeek(t time.Time) time.Time {
	weekday := int(t.Weekday())
	if weekday == 0 {
		weekday = 7 // Sunday
	}
	return time.Date(t.Year(), t.Month(), t.Day()-weekday+1, 0, 0, 0, 0, t.Location())
}
./internal/handlers/attendance.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type AttendanceHandler struct {
	db *sql.DB
}

func NewAttendanceHandler(db *sql.DB) *AttendanceHandler {
	return &AttendanceHandler{db: db}
}

// Helpers to convert SQL Nulls to JSON Pointers
func sqlNullTimeToPointer(t sql.NullTime) *time.Time {
	if t.Valid {
		return &t.Time
	}
	return nil
}

func sqlNullFloatToPointer(f sql.NullFloat64) *float64 {
	if f.Valid {
		return &f.Float64
	}
	return nil
}

func sqlNullStringToPointer(s sql.NullString) *string {
	if s.Valid {
		return &s.String
	}
	return nil
}

func sqlNullIntToPointer(i sql.NullInt64) *int {
	if i.Valid {
		val := int(i.Int64)
		return &val
	}
	return nil
}

// CheckIn (Strict: Location Required)
func (h *AttendanceHandler) CheckIn(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	if claims.Role != "intern" {
		utils.RespondForbidden(w, "Only interns can check in")
		return
	}

	var req models.CheckInRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// 1. Strict Location Check
	if !utils.ValidateCoordinates(req.Latitude, req.Longitude) {
		utils.RespondBadRequest(w, "Invalid coordinates")
		return
	}

	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	cfg := config.Loaded
	distance := utils.HaversineDistance(cfg.Office.Latitude, cfg.Office.Longitude, req.Latitude, req.Longitude)
	if distance > cfg.Office.Radius {
		utils.RespondBadRequest(w, "You are not within the office radius.")
		return
	}
	distanceMeters := int(distance + 0.5)

	today := time.Now().Format("2006-01-02")
	var existingID int64
	err = h.db.QueryRow("SELECT id FROM attendances WHERE intern_id = ? AND date = ?", internID, today).Scan(&existingID)
	if err == nil {
		utils.RespondBadRequest(w, "Already checked in today")
		return
	}

	// Time Logic
	now := time.Now()
	openTime, _ := time.Parse("15:04:05", cfg.Office.AttendanceOpenTime)
	targetTime, _ := time.Parse("15:04:05", cfg.Office.CheckInTime)

	openLimit := time.Date(now.Year(), now.Month(), now.Day(), openTime.Hour(), openTime.Minute(), 0, 0, now.Location())
	lateStart := time.Date(now.Year(), now.Month(), now.Day(), targetTime.Hour(), targetTime.Minute(), 0, 0, now.Location())
	hardLimit := lateStart.Add(time.Duration(cfg.Office.LateToleranceMinutes) * time.Minute)

	if now.Before(openLimit) {
		utils.RespondBadRequest(w, "Attendance is not open yet.")
		return
	}

	if now.After(hardLimit) {
		utils.RespondBadRequest(w, "Attendance check-in is closed.")
		return
	}

	status := "present"
	var lateReason sql.NullString

	if now.After(lateStart) {
		status = "late"
		if strings.TrimSpace(req.Reason) == "" {
			utils.RespondBadRequest(w, "You are late. A reason is required.")
			return
		}
		lateReason = sql.NullString{String: req.Reason, Valid: true}
	}

	result, err := h.db.Exec(
		`INSERT INTO attendances (intern_id, date, check_in_time, check_in_latitude, check_in_longitude, status, late_reason, distance_meters)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
		internID, today, now, req.Latitude, req.Longitude, status, lateReason, distanceMeters,
	)

	if err != nil {
		utils.RespondInternalError(w, "Failed to create attendance record")
		return
	}

	attendanceID, _ := result.LastInsertId()

	utils.RespondSuccess(w, "Check-in successful", map[string]interface{}{
		"attendance_id": attendanceID,
		"status":        status,
		"check_in_time": now,
	})
}

// CheckOut (Loose: Location Optional)
func (h *AttendanceHandler) CheckOut(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	var req models.CheckOutRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		// Even if body is invalid/empty, we proceed (we don't strictly need coords)
	}

	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	today := time.Now().Format("2006-01-02")
	var attendanceID int64
	var checkOutTime sql.NullTime

	err = h.db.QueryRow(
		"SELECT id, check_out_time FROM attendances WHERE intern_id = ? AND date = ?",
		internID, today,
	).Scan(&attendanceID, &checkOutTime)

	if err != nil {
		utils.RespondBadRequest(w, "No check-in record found for today")
		return
	}

	if checkOutTime.Valid {
		utils.RespondBadRequest(w, "Already checked out today")
		return
	}

	// REMOVED: Geo-Validation logic here. We accept check-outs from anywhere.

	now := time.Now()
	// Use 0.0 if coords missing
	_, err = h.db.Exec(
		`UPDATE attendances SET check_out_time = ?, check_out_latitude = ?, check_out_longitude = ?
		 WHERE id = ?`,
		now, req.Latitude, req.Longitude, attendanceID,
	)

	if err != nil {
		utils.RespondInternalError(w, "Failed to update attendance")
		return
	}

	utils.RespondSuccess(w, "Check-out successful", nil)
}

// GetToday (Fixes "Invalid Date" bug)
func (h *AttendanceHandler) GetToday(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
	w.Header().Set("Pragma", "no-cache")
	w.Header().Set("Expires", "0")

	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	today := time.Now().Format("2006-01-02")

	// Temporary SQL Null variables for scanning
	var (
		cit, cot               sql.NullTime
		cila, cilo, cola, colo sql.NullFloat64
		lr                     sql.NullString
		notes                  sql.NullString
		dist                   sql.NullInt64
		proof                  sql.NullString
	)

	var a models.Attendance
	err = h.db.QueryRow(
		`SELECT id, intern_id, date, check_in_time, check_in_latitude, check_in_longitude, 
		        check_out_time, check_out_latitude, check_out_longitude, status, late_reason, notes, distance_meters, proof_file
		 FROM attendances
		 WHERE intern_id = ? AND date = ?`,
		internID, today,
	).Scan(
		&a.ID, &a.InternID, &a.Date,
		&cit, &cila, &cilo,
		&cot, &cola, &colo,
		&a.Status, &lr, &notes, &dist, &proof,
	)

	if err == sql.ErrNoRows {
		utils.RespondSuccess(w, "No attendance record", map[string]interface{}{"checked_in": false})
		return
	}

	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	// CONVERT SQL NULLS TO POINTERS (Critical Fix for "Invalid Date")
	a.CheckInTime = sqlNullTimeToPointer(cit)
	a.CheckInLatitude = sqlNullFloatToPointer(cila)
	a.CheckInLongitude = sqlNullFloatToPointer(cilo)
	a.CheckOutTime = sqlNullTimeToPointer(cot)
	a.CheckOutLatitude = sqlNullFloatToPointer(cola)
	a.CheckOutLongitude = sqlNullFloatToPointer(colo)
	a.LateReason = sqlNullStringToPointer(lr)
	a.Notes = sqlNullStringToPointer(notes)
	a.DistanceMeters = sqlNullIntToPointer(dist)
	a.ProofFile = sqlNullStringToPointer(proof)

	utils.RespondSuccess(w, "Today's attendance", map[string]interface{}{
		"checked_in": true,
		"attendance": a,
	})
}

func (h *AttendanceHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	date := strings.TrimSpace(r.URL.Query().Get("date"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))
	internFilter := strings.TrimSpace(r.URL.Query().Get("intern_id"))
	month := strings.TrimSpace(r.URL.Query().Get("month"))

	where := []string{}
	args := []interface{}{}

	role := normalizeRole(claims.Role)
	if role == "intern" {
		var internID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID); err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		where = append(where, "a.intern_id = ?")
		args = append(args, internID)
	} else if internFilter != "" {
		if id, err := strconv.ParseInt(internFilter, 10, 64); err == nil {
			where = append(where, "a.intern_id = ?")
			args = append(args, id)
		}
	}

	if date != "" {
		where = append(where, "DATE(a.date) = ?")
		args = append(args, date)
	}
	if status != "" {
		where = append(where, "a.status = ?")
		args = append(args, status)
	}
	if month != "" {
		if parsed, err := time.Parse("2006-01", month); err == nil {
			where = append(where, "MONTH(a.date) = ? AND YEAR(a.date) = ?")
			args = append(args, parsed.Month(), parsed.Year())
		}
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
		FROM attendances a
		LEFT JOIN interns i ON a.intern_id = i.id
		LEFT JOIN users u ON i.user_id = u.id
	`

	var total int64
	countQuery := "SELECT COUNT(*) " + baseFrom + " " + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count attendance")
		return
	}

	query := `
		SELECT a.id, a.intern_id, a.date, a.check_in_time, a.check_in_latitude, a.check_in_longitude,
		       a.check_out_time, a.check_out_latitude, a.check_out_longitude, a.status, a.late_reason,
		       a.notes, a.distance_meters, a.proof_file, a.created_at, a.updated_at,
		       u.name
	` + baseFrom + " " + whereClause + " ORDER BY a.date DESC, a.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch attendance")
		return
	}
	defer rows.Close()

	var records []models.Attendance
	for rows.Next() {
		var a models.Attendance
		var cit, cot sql.NullTime
		var cila, cilo, cola, colo sql.NullFloat64
		var lr, notes, proof sql.NullString
		var dist sql.NullInt64
		var internName sql.NullString

		if err := rows.Scan(
			&a.ID, &a.InternID, &a.Date,
			&cit, &cila, &cilo,
			&cot, &cola, &colo,
			&a.Status, &lr,
			&notes, &dist, &proof, &a.CreatedAt, &a.UpdatedAt,
			&internName,
		); err != nil {
			continue
		}

		a.CheckInTime = sqlNullTimeToPointer(cit)
		a.CheckInLatitude = sqlNullFloatToPointer(cila)
		a.CheckInLongitude = sqlNullFloatToPointer(cilo)
		a.CheckOutTime = sqlNullTimeToPointer(cot)
		a.CheckOutLatitude = sqlNullFloatToPointer(cola)
		a.CheckOutLongitude = sqlNullFloatToPointer(colo)
		a.LateReason = sqlNullStringToPointer(lr)
		a.Notes = sqlNullStringToPointer(notes)
		a.DistanceMeters = sqlNullIntToPointer(dist)
		a.ProofFile = sqlNullStringToPointer(proof)
		if internName.Valid {
			a.InternName = internName.String
		}

		records = append(records, a)
	}

	utils.RespondPaginated(w, records, utils.CalculatePagination(page, limit, total))
}

func (h *AttendanceHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		SELECT a.id, a.intern_id, a.date, a.check_in_time, a.check_in_latitude, a.check_in_longitude,
		       a.check_out_time, a.check_out_latitude, a.check_out_longitude, a.status, a.late_reason,
		       a.notes, a.distance_meters, a.proof_file, a.created_at, a.updated_at,
		       u.name
		FROM attendances a
		LEFT JOIN interns i ON a.intern_id = i.id
		LEFT JOIN users u ON i.user_id = u.id
		WHERE a.id = ?
	`

	var a models.Attendance
	var cit, cot sql.NullTime
	var cila, cilo, cola, colo sql.NullFloat64
	var lr, notes, proof sql.NullString
	var dist sql.NullInt64
	var internName sql.NullString

	err := h.db.QueryRow(query, id).Scan(
		&a.ID, &a.InternID, &a.Date,
		&cit, &cila, &cilo,
		&cot, &cola, &colo,
		&a.Status, &lr,
		&notes, &dist, &proof, &a.CreatedAt, &a.UpdatedAt,
		&internName,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Attendance not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != a.InternID {
			utils.RespondForbidden(w, "You do not have access to this record")
			return
		}
	}

	a.CheckInTime = sqlNullTimeToPointer(cit)
	a.CheckInLatitude = sqlNullFloatToPointer(cila)
	a.CheckInLongitude = sqlNullFloatToPointer(cilo)
	a.CheckOutTime = sqlNullTimeToPointer(cot)
	a.CheckOutLatitude = sqlNullFloatToPointer(cola)
	a.CheckOutLongitude = sqlNullFloatToPointer(colo)
	a.LateReason = sqlNullStringToPointer(lr)
	a.Notes = sqlNullStringToPointer(notes)
	a.DistanceMeters = sqlNullIntToPointer(dist)
	a.ProofFile = sqlNullStringToPointer(proof)
	if internName.Valid {
		a.InternName = internName.String
	}

	utils.RespondSuccess(w, "Attendance retrieved", a)
}

func (h *AttendanceHandler) GetByInternID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	q := r.URL.Query()
	q.Set("intern_id", strconv.FormatInt(internID, 10))
	r.URL.RawQuery = q.Encode()
	h.GetAll(w, r)
}

// SubmitPermission handles sick/permission attendance submission
func (h *AttendanceHandler) SubmitPermission(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) != "intern" {
		utils.RespondForbidden(w, "Only interns can submit permission")
		return
	}

	if err := r.ParseMultipartForm(10 << 20); err != nil {
		utils.RespondBadRequest(w, "Failed to parse form data")
		return
	}

	status := r.FormValue("status")
	notes := r.FormValue("notes")
	latStr := r.FormValue("latitude")
	lonStr := r.FormValue("longitude")

	if status != "sick" && status != "permission" {
		utils.RespondBadRequest(w, "Invalid status")
		return
	}
	if strings.TrimSpace(notes) == "" {
		utils.RespondBadRequest(w, "Notes are required")
		return
	}

	var lat, lon sql.NullFloat64
	if latStr != "" {
		if v, err := strconv.ParseFloat(latStr, 64); err == nil {
			lat = sql.NullFloat64{Float64: v, Valid: true}
		}
	}
	if lonStr != "" {
		if v, err := strconv.ParseFloat(lonStr, 64); err == nil {
			lon = sql.NullFloat64{Float64: v, Valid: true}
		}
	}

	var internID int64
	if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID); err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	today := time.Now().Format("2006-01-02")
	var existingID int64
	if err := h.db.QueryRow("SELECT id FROM attendances WHERE intern_id = ? AND date = ?", internID, today).Scan(&existingID); err == nil {
		utils.RespondBadRequest(w, "Attendance already exists for today")
		return
	}

	// Optional proof file
	var proofPath sql.NullString
	file, header, err := r.FormFile("proof_file")
	if err == nil {
		defer file.Close()
		path, err := utils.UploadFile(file, header, "attendance_proofs")
		if err != nil {
			utils.RespondInternalError(w, "Failed to upload proof file")
			return
		}
		proofPath = sql.NullString{String: path, Valid: true}
	}

	_, err = h.db.Exec(
		`INSERT INTO attendances (intern_id, date, status, notes, proof_file, check_in_latitude, check_in_longitude)
		 VALUES (?, ?, ?, ?, ?, ?, ?)`,
		internID, today, status, notes, proofPath, lat, lon,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create permission record")
		return
	}

	utils.RespondCreated(w, "Permission submitted", nil)
}
./internal/handlers/holiday.go
package handlers

import (
	"net/http"
	"strconv"
	"dsi_interna_sys/internal/holiday"
	"dsi_interna_sys/internal/utils"
)

func GetHolidays(w http.ResponseWriter, r *http.Request) {
	yearStr := r.URL.Query().Get("year")
	var year int
	var err error
	if yearStr != "" {
		year, err = strconv.Atoi(yearStr)
		if err != nil {
			utils.RespondBadRequest(w, "Invalid year format")
			return
		}
	}

	holidays, err := holiday.GetHolidays(year)
	if err != nil {
		// If there is an error, we still return the fallback holidays
		utils.RespondSuccess(w, "Successfully retrieved fallback holidays", holidays)
		return
	}

	utils.RespondSuccess(w, "Successfully retrieved holidays", holidays)
}
./internal/handlers/task.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type TaskHandler struct {
	db *sql.DB
}

func NewTaskHandler(db *sql.DB) *TaskHandler {
	return &TaskHandler{db: db}
}

type createTaskRequest struct {
	Title        string  `json:"title"`
	Description  string  `json:"description"`
	Priority     string  `json:"priority"`      // low, medium, high
	StartDate    string  `json:"start_date"`    // YYYY-MM-DD
	Deadline     string  `json:"deadline"`      // YYYY-MM-DD
	DeadlineTime string  `json:"deadline_time"` // HH:MM
	AssignTo     string  `json:"assign_to"`     // all, selected
	InternIDs    []int64 `json:"intern_ids"`
}

type updateTaskRequest struct {
	Title        *string `json:"title"`
	Description *string `json:"description"`
	InternID     *int64  `json:"intern_id"`
	Priority     *string `json:"priority"`
	Status       *string `json:"status"`
	StartDate    *string `json:"start_date"`
	Deadline     *string `json:"deadline"`
	DeadlineTime *string `json:"deadline_time"`
	AdminFeedback *string `json:"admin_feedback"`
}

type submitTaskRequest struct {
	SubmissionNotes string                `json:"submission_notes"`
	Links           []models.SubmissionLink `json:"links"`
}

type reviewTaskRequest struct {
	Action   string `json:"action"` // approve, revision
	Score    *int   `json:"score"`
	Feedback string `json:"feedback"`
}

type updateStatusRequest struct {
	Status string `json:"status"` // pending, in_progress
}

func (h *TaskHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	search := strings.TrimSpace(r.URL.Query().Get("search"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))
	priority := strings.TrimSpace(r.URL.Query().Get("priority"))
	internFilter := strings.TrimSpace(r.URL.Query().Get("intern_id"))

	var where []string
	var args []interface{}

	// Interns can only see their tasks and not scheduled tasks
	if normalizeRole(claims.Role) == "intern" {
		internID, err := h.getInternIDForUser(claims.UserID)
		if err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		where = append(where, "t.intern_id = ?")
		args = append(args, internID)
		where = append(where, "t.status != 'scheduled'")
	} else if internFilter != "" {
		if id, err := strconv.ParseInt(internFilter, 10, 64); err == nil {
			where = append(where, "t.intern_id = ?")
			args = append(args, id)
		}
	}

	if search != "" {
		where = append(where, "t.title LIKE ?")
		args = append(args, "%"+search+"%")
	}
	if status != "" {
		where = append(where, "t.status = ?")
		args = append(args, status)
	}
	if priority != "" {
		where = append(where, "t.priority = ?")
		args = append(args, priority)
	}

	baseFrom := `
		FROM tasks t
		LEFT JOIN interns i ON t.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON t.assigned_by = au.id
	`

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	var total int64
	countQuery := "SELECT COUNT(*) " + baseFrom + " " + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count tasks")
		return
	}

	query := `
		SELECT t.id, t.task_assignment_id, t.intern_id, t.assigned_by, t.title, t.description, t.priority, t.status,
		       t.start_date, t.deadline, t.deadline_time, t.started_at, t.submitted_at, t.completed_at, t.approved_at,
		       t.is_late, t.submission_notes, t.submission_links, t.score, t.admin_feedback, t.created_at, t.updated_at,
		       iu.name, au.name
	` + baseFrom + " " + whereClause + " ORDER BY t.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch tasks")
		return
	}
	defer rows.Close()

	var tasks []models.Task
	for rows.Next() {
		t, err := scanTask(rows)
		if err != nil {
			continue
		}
		tasks = append(tasks, t)
	}

	utils.RespondPaginated(w, tasks, utils.CalculatePagination(page, limit, total))
}

func (h *TaskHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		SELECT t.id, t.task_assignment_id, t.intern_id, t.assigned_by, t.title, t.description, t.priority, t.status,
		       t.start_date, t.deadline, t.deadline_time, t.started_at, t.submitted_at, t.completed_at, t.approved_at,
		       t.is_late, t.submission_notes, t.submission_links, t.score, t.admin_feedback, t.created_at, t.updated_at,
		       iu.name, au.name
		FROM tasks t
		LEFT JOIN interns i ON t.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON t.assigned_by = au.id
		WHERE t.id = ?
	`

	t, err := scanTask(h.db.QueryRow(query, id))
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Task not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	// Interns can only access their own tasks
	if normalizeRole(claims.Role) == "intern" {
		internID, err := h.getInternIDForUser(claims.UserID)
		if err != nil || t.InternID == nil || *t.InternID != internID {
			utils.RespondForbidden(w, "You do not have access to this task")
			return
		}
	}

	utils.RespondSuccess(w, "Task retrieved", t)
}

func (h *TaskHandler) GetByInternID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	q := r.URL.Query()
	q.Set("intern_id", strconv.FormatInt(internID, 10))
	r.URL.RawQuery = q.Encode()
	h.GetAll(w, r)
}

func (h *TaskHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	// Only admin/pembimbing can create tasks
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can assign tasks")
		return
	}

	var req createTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if strings.TrimSpace(req.Title) == "" {
		utils.RespondBadRequest(w, "Title is required")
		return
	}
	if req.Priority == "" {
		req.Priority = "medium"
	}
	if req.Priority != "low" && req.Priority != "medium" && req.Priority != "high" {
		utils.RespondBadRequest(w, "Invalid priority")
		return
	}
	if req.AssignTo == "" {
		req.AssignTo = "selected"
	}
	if req.AssignTo != "all" && req.AssignTo != "selected" {
		utils.RespondBadRequest(w, "Invalid assign_to value")
		return
	}

	startDate := time.Now()
	if req.StartDate != "" {
		if parsed, err := time.Parse("2006-01-02", req.StartDate); err == nil {
			startDate = parsed
		}
	}
	var deadline sql.NullTime
	if req.Deadline != "" {
		if parsed, err := time.Parse("2006-01-02", req.Deadline); err == nil {
			deadline = sql.NullTime{Time: parsed, Valid: true}
		}
	}
	var deadlineTime sql.NullString
	if req.DeadlineTime != "" {
		deadlineTime = sql.NullString{String: req.DeadlineTime + ":00", Valid: true}
	}

	isScheduled := startDate.After(time.Now())
	initialStatus := "pending"
	if isScheduled {
		initialStatus = "scheduled"
	}

	// Determine interns to assign
	type internRow struct {
		ID     int64
		UserID int64
	}
	var interns []internRow

	if req.AssignTo == "all" {
		rows, err := h.db.Query("SELECT id, user_id FROM interns WHERE status = 'active'")
		if err != nil {
			utils.RespondInternalError(w, "Failed to fetch interns")
			return
		}
		defer rows.Close()
		for rows.Next() {
			var it internRow
			if err := rows.Scan(&it.ID, &it.UserID); err == nil {
				interns = append(interns, it)
			}
		}
	} else {
		if len(req.InternIDs) == 0 {
			utils.RespondBadRequest(w, "intern_ids is required when assign_to is selected")
			return
		}
		query := "SELECT id, user_id FROM interns WHERE id IN (" + placeholders(len(req.InternIDs)) + ")"
		args := make([]interface{}, 0, len(req.InternIDs))
		for _, id := range req.InternIDs {
			args = append(args, id)
		}
		rows, err := h.db.Query(query, args...)
		if err != nil {
			utils.RespondInternalError(w, "Failed to fetch interns")
			return
		}
		defer rows.Close()
		for rows.Next() {
			var it internRow
			if err := rows.Scan(&it.ID, &it.UserID); err == nil {
				interns = append(interns, it)
			}
		}
	}

	if len(interns) == 0 {
		utils.RespondBadRequest(w, "No interns found for assignment")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	assignmentRes, err := tx.Exec(
		`INSERT INTO task_assignments (title, description, assigned_by, priority, start_date, deadline, deadline_time, assign_to_all)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
		req.Title, nullIfEmpty(req.Description), claims.UserID, req.Priority, startDate, deadline, deadlineTime, req.AssignTo == "all",
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create task assignment")
		return
	}
	assignmentID, _ := assignmentRes.LastInsertId()

	for _, it := range interns {
		if _, err := tx.Exec(
			"INSERT INTO task_assignment_interns (task_assignment_id, intern_id) VALUES (?, ?)",
			assignmentID, it.ID,
		); err != nil {
			utils.RespondInternalError(w, "Failed to attach interns")
			return
		}

		taskRes, err := tx.Exec(
			`INSERT INTO tasks (task_assignment_id, title, description, intern_id, assigned_by, priority, status, start_date, deadline, deadline_time)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			assignmentID, req.Title, nullIfEmpty(req.Description), it.ID, claims.UserID, req.Priority, initialStatus, startDate, deadline, deadlineTime,
		)
		if err != nil {
			utils.RespondInternalError(w, "Failed to create tasks")
			return
		}

		taskID, _ := taskRes.LastInsertId()

		if !isScheduled {
			_ = h.createNotification(it.UserID, models.NotificationTaskAssigned, "Tugas Baru: "+req.Title,
				"Anda mendapat tugas baru. Silakan cek detail tugas Anda.", "/tasks/"+strconv.FormatInt(taskID, 10), map[string]interface{}{"task_id": taskID})
		}
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondCreated(w, "Tasks created successfully", map[string]interface{}{
		"assignment_id": assignmentID,
		"count":         len(interns),
		"scheduled":     isScheduled,
	})
}

func (h *TaskHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update tasks")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Load current task for status transitions
	var current struct {
		Status     string
		StartedAt  sql.NullTime
		Deadline   sql.NullTime
		DeadlineTime sql.NullString
	}
	err := h.db.QueryRow("SELECT status, started_at, deadline, deadline_time FROM tasks WHERE id = ?", taskID).
		Scan(&current.Status, &current.StartedAt, &current.Deadline, &current.DeadlineTime)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Task not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	updates := []string{}
	args := []interface{}{}

	if req.Title != nil {
		updates = append(updates, "title = ?")
		args = append(args, *req.Title)
	}
	if req.Description != nil {
		updates = append(updates, "description = ?")
		args = append(args, nullIfEmpty(*req.Description))
	}
	if req.InternID != nil {
		updates = append(updates, "intern_id = ?")
		args = append(args, sql.NullInt64{Int64: *req.InternID, Valid: *req.InternID != 0})
	}
	if req.Priority != nil {
		updates = append(updates, "priority = ?")
		args = append(args, *req.Priority)
	}
	if req.StartDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.StartDate); err == nil {
			updates = append(updates, "start_date = ?")
			args = append(args, parsed)
		}
	}
	if req.Deadline != nil {
		if parsed, err := time.Parse("2006-01-02", *req.Deadline); err == nil {
			updates = append(updates, "deadline = ?")
			args = append(args, parsed)
		}
	}
	if req.DeadlineTime != nil {
		if *req.DeadlineTime == "" {
			updates = append(updates, "deadline_time = NULL")
		} else {
			updates = append(updates, "deadline_time = ?")
			args = append(args, *req.DeadlineTime+":00")
		}
	}
	if req.AdminFeedback != nil {
		updates = append(updates, "admin_feedback = ?")
		args = append(args, nullIfEmpty(*req.AdminFeedback))
	}

	if req.Status != nil && *req.Status != current.Status {
		updates = append(updates, "status = ?")
		args = append(args, *req.Status)
		if *req.Status == "in_progress" && !current.StartedAt.Valid {
			updates = append(updates, "started_at = ?")
			args = append(args, time.Now())
		}
		if *req.Status == "completed" {
			updates = append(updates, "completed_at = ?")
			args = append(args, time.Now())
			updates = append(updates, "submitted_at = ?")
			args = append(args, time.Now())
			if h.isLate(current.Deadline, current.DeadlineTime, time.Now()) {
				updates = append(updates, "is_late = 1")
			}
		}
	}

	if len(updates) == 0 {
		utils.RespondBadRequest(w, "No updates provided")
		return
	}

	args = append(args, taskID)
	query := "UPDATE tasks SET " + strings.Join(updates, ", ") + " WHERE id = ?"
	if _, err := h.db.Exec(query, args...); err != nil {
		utils.RespondInternalError(w, "Failed to update task")
		return
	}

	utils.RespondSuccess(w, "Task updated", nil)
}

func (h *TaskHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can delete tasks")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if _, err := h.db.Exec("DELETE FROM tasks WHERE id = ?", taskID); err != nil {
		utils.RespondInternalError(w, "Failed to delete task")
		return
	}

	utils.RespondSuccess(w, "Task deleted", nil)
}

func (h *TaskHandler) UploadAttachment(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can upload attachments")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if err := r.ParseMultipartForm(10 << 20); err != nil {
		utils.RespondBadRequest(w, "Failed to parse form data")
		return
	}

	file, header, err := r.FormFile("file")
	if err != nil {
		utils.RespondBadRequest(w, "Missing file")
		return
	}
	defer file.Close()

	path, err := utils.UploadFile(file, header, "tasks")
	if err != nil {
		utils.RespondInternalError(w, "Upload failed: "+err.Error())
		return
	}

	_, err = h.db.Exec(
		`INSERT INTO task_attachments (task_id, file_name, file_path, file_type, file_size)
		 VALUES (?, ?, ?, ?, ?)`,
		taskID, header.Filename, path, utils.GetFileExtension(header.Filename), header.Size,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to save attachment")
		return
	}

	utils.RespondCreated(w, "Attachment uploaded", map[string]string{"path": path})
}

func (h *TaskHandler) MarkComplete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can mark complete")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	_, err := h.db.Exec("UPDATE tasks SET status = 'completed', completed_at = ? WHERE id = ?", time.Now(), taskID)
	if err != nil {
		utils.RespondInternalError(w, "Failed to update task")
		return
	}

	utils.RespondSuccess(w, "Task marked complete", nil)
}

// Submit task by intern
func (h *TaskHandler) Submit(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) != "intern" {
		utils.RespondForbidden(w, "Only interns can submit tasks")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	internID, err := h.getInternIDForUser(claims.UserID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	var req submitTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}
	if len(req.Links) == 0 {
		utils.RespondBadRequest(w, "At least one submission link is required")
		return
	}
	for _, l := range req.Links {
		if strings.TrimSpace(l.Label) == "" || strings.TrimSpace(l.URL) == "" {
			utils.RespondBadRequest(w, "Each link must have label and url")
			return
		}
	}

	var deadline sql.NullTime
	var deadlineTime sql.NullString
	err = h.db.QueryRow("SELECT deadline, deadline_time FROM tasks WHERE id = ? AND intern_id = ?", taskID, internID).
		Scan(&deadline, &deadlineTime)
	if err == sql.ErrNoRows {
		utils.RespondForbidden(w, "You do not have access to this task")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	linksJSON, _ := json.Marshal(req.Links)
	now := time.Now()
	isLate := h.isLate(deadline, deadlineTime, now)

	_, err = h.db.Exec(
		`UPDATE tasks SET status = 'submitted', submitted_at = ?, submission_notes = ?, submission_links = ?, is_late = ?,
		        started_at = COALESCE(started_at, ?)
		 WHERE id = ?`,
		now, nullIfEmpty(req.SubmissionNotes), string(linksJSON), isLate, now, taskID,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to submit task")
		return
	}

	utils.RespondSuccess(w, "Task submitted", map[string]interface{}{"is_late": isLate})
}

// Review task by admin/pembimbing
func (h *TaskHandler) Review(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can review tasks")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req reviewTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}
	if req.Action != "approve" && req.Action != "revision" {
		utils.RespondBadRequest(w, "Invalid action")
		return
	}
	if req.Action == "approve" && req.Score == nil {
		utils.RespondBadRequest(w, "Score is required for approval")
		return
	}

	var internUserID int64
	err := h.db.QueryRow(
		`SELECT i.user_id FROM tasks t
		 LEFT JOIN interns i ON t.intern_id = i.id
		 WHERE t.id = ?`, taskID,
	).Scan(&internUserID)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Task not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if req.Action == "approve" {
		_, err = h.db.Exec(
			`UPDATE tasks SET status = 'completed', completed_at = ?, approved_at = ?, score = ?, admin_feedback = ?
			 WHERE id = ?`,
			time.Now(), time.Now(), *req.Score, nullIfEmpty(req.Feedback), taskID,
		)
		if err != nil {
			utils.RespondInternalError(w, "Failed to approve task")
			return
		}
		_ = h.createNotification(internUserID, models.NotificationTaskApproved, "Tugas Disetujui",
			"Tugas Anda telah disetujui. Nilai: "+strconv.Itoa(*req.Score), "/tasks/"+strconv.FormatInt(taskID, 10),
			map[string]interface{}{"task_id": taskID, "score": *req.Score})
	} else {
		_, err = h.db.Exec(
			`UPDATE tasks SET status = 'revision', admin_feedback = ?
			 WHERE id = ?`,
			nullIfEmpty(req.Feedback), taskID,
		)
		if err != nil {
			utils.RespondInternalError(w, "Failed to request revision")
			return
		}
		_ = h.createNotification(internUserID, models.NotificationTaskRevision, "Perlu Revisi",
			"Tugas Anda memerlukan revisi. Silakan cek feedback pembimbing.", "/tasks/"+strconv.FormatInt(taskID, 10),
			map[string]interface{}{"task_id": taskID})
	}

	utils.RespondSuccess(w, "Review processed", nil)
}

// Update status by intern (pending/in_progress)
func (h *TaskHandler) UpdateStatus(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) != "intern" {
		utils.RespondForbidden(w, "Only interns can update task status")
		return
	}

	vars := mux.Vars(r)
	taskID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}
	if req.Status != "pending" && req.Status != "in_progress" {
		utils.RespondBadRequest(w, "Invalid status")
		return
	}

	internID, err := h.getInternIDForUser(claims.UserID)
	if err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	query := "UPDATE tasks SET status = ?"
	args := []interface{}{req.Status}
	if req.Status == "in_progress" {
		query += ", started_at = COALESCE(started_at, ?)"
		args = append(args, time.Now())
	}
	query += " WHERE id = ? AND intern_id = ?"
	args = append(args, taskID, internID)

	if _, err := h.db.Exec(query, args...); err != nil {
		utils.RespondInternalError(w, "Failed to update status")
		return
	}

	utils.RespondSuccess(w, "Status updated", nil)
}

// Search interns (for task assignment)
func (h *TaskHandler) SearchInterns(w http.ResponseWriter, r *http.Request) {
	query := strings.TrimSpace(r.URL.Query().Get("q"))
	args := []interface{}{}
	where := "WHERE i.status = 'active'"

	if query != "" {
		where += " AND (u.name LIKE ? OR i.school LIKE ? OR i.department LIKE ?)"
		like := "%" + query + "%"
		args = append(args, like, like, like)
	}

	rows, err := h.db.Query(
		`SELECT i.id, u.name, i.school, i.department
		 FROM interns i
		 LEFT JOIN users u ON i.user_id = u.id
		`+where+` LIMIT 20`, args...,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to search interns")
		return
	}
	defer rows.Close()

	type result struct {
		ID         int64  `json:"id"`
		Name       string `json:"name"`
		School     string `json:"school"`
		Department string `json:"department"`
		Label      string `json:"label"`
	}

	results := []result{}
	for rows.Next() {
		var r result
		if err := rows.Scan(&r.ID, &r.Name, &r.School, &r.Department); err == nil {
			r.Label = r.Name + " - " + r.School + " (" + r.Department + ")"
			results = append(results, r)
		}
	}

	utils.RespondSuccess(w, "Interns found", results)
}

// Task Assignments (grouped)
func (h *TaskHandler) GetAssignments(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can view assignments")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}
	offset := (page - 1) * limit

	search := strings.TrimSpace(r.URL.Query().Get("search"))
	priority := strings.TrimSpace(r.URL.Query().Get("priority"))

	where := []string{}
	args := []interface{}{}
	if search != "" {
		where = append(where, "ta.title LIKE ?")
		args = append(args, "%"+search+"%")
	}
	if priority != "" {
		where = append(where, "ta.priority = ?")
		args = append(args, priority)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	var total int64
	countQuery := `
		SELECT COUNT(*) FROM task_assignments ta
	` + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count assignments")
		return
	}

	query := `
		SELECT ta.id, ta.title, ta.description, ta.assigned_by, ta.priority, ta.start_date, ta.deadline, ta.deadline_time,
		       ta.assign_to_all, ta.created_at, ta.updated_at, u.name, COUNT(t.id) as tasks_count
		FROM task_assignments ta
		LEFT JOIN tasks t ON t.task_assignment_id = ta.id
		LEFT JOIN users u ON ta.assigned_by = u.id
	` + whereClause + `
		GROUP BY ta.id
		HAVING tasks_count > 0
		ORDER BY ta.created_at DESC
		LIMIT ? OFFSET ?
	`

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch assignments")
		return
	}
	defer rows.Close()

	type assignmentWithStats struct {
		models.TaskAssignment
		Stats map[string]interface{} `json:"stats"`
	}

	var assignments []assignmentWithStats
	for rows.Next() {
		var a models.TaskAssignment
		var description sql.NullString
		var startDate sql.NullTime
		var deadline sql.NullTime
		var deadlineTime sql.NullString
		var assignedByName sql.NullString
		if err := rows.Scan(
			&a.ID, &a.Title, &description, &a.AssignedBy, &a.Priority, &startDate, &deadline, &deadlineTime,
			&a.AssignToAll, &a.CreatedAt, &a.UpdatedAt, &assignedByName, &a.TasksCount,
		); err == nil {
			a.Description = ptrStringFromNull(description)
			a.StartDate = ptrTimeFromNull(startDate)
			a.Deadline = ptrTimeFromNull(deadline)
			a.DeadlineTime = ptrStringFromNull(deadlineTime)
			if assignedByName.Valid {
				a.AssignedByName = assignedByName.String
			}
			stats := h.assignmentStats(a.ID)
			assignments = append(assignments, assignmentWithStats{TaskAssignment: a, Stats: stats})
		}
	}

	utils.RespondPaginated(w, assignments, utils.CalculatePagination(page, limit, total))
}

func (h *TaskHandler) GetAssignmentByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can view assignments")
		return
	}

	vars := mux.Vars(r)
	assignmentID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var assignment models.TaskAssignment
	var description sql.NullString
	var startDate sql.NullTime
	var deadline sql.NullTime
	var deadlineTime sql.NullString
	var assignedByName sql.NullString
	err := h.db.QueryRow(
		`SELECT ta.id, ta.title, ta.description, ta.assigned_by, ta.priority, ta.start_date, ta.deadline, ta.deadline_time,
		        ta.assign_to_all, ta.created_at, ta.updated_at, u.name
		 FROM task_assignments ta
		 LEFT JOIN users u ON ta.assigned_by = u.id
		 WHERE ta.id = ?`, assignmentID,
	).Scan(&assignment.ID, &assignment.Title, &description, &assignment.AssignedBy, &assignment.Priority,
		&startDate, &deadline, &deadlineTime, &assignment.AssignToAll,
		&assignment.CreatedAt, &assignment.UpdatedAt, &assignedByName)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Assignment not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	assignment.Description = ptrStringFromNull(description)
	assignment.StartDate = ptrTimeFromNull(startDate)
	assignment.Deadline = ptrTimeFromNull(deadline)
	assignment.DeadlineTime = ptrStringFromNull(deadlineTime)
	if assignedByName.Valid {
		assignment.AssignedByName = assignedByName.String
	}

	// Fetch tasks under this assignment
	rows, err := h.db.Query(
		`SELECT t.id, t.task_assignment_id, t.intern_id, t.assigned_by, t.title, t.description, t.priority, t.status,
		        t.start_date, t.deadline, t.deadline_time, t.started_at, t.submitted_at, t.completed_at, t.approved_at,
		        t.is_late, t.submission_notes, t.submission_links, t.score, t.admin_feedback, t.created_at, t.updated_at,
		        iu.name, au.name
		 FROM tasks t
		 LEFT JOIN interns i ON t.intern_id = i.id
		 LEFT JOIN users iu ON i.user_id = iu.id
		 LEFT JOIN users au ON t.assigned_by = au.id
		 WHERE t.task_assignment_id = ?`, assignmentID,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch tasks")
		return
	}
	defer rows.Close()

	var tasks []models.Task
	for rows.Next() {
		t, err := scanTask(rows)
		if err != nil {
			continue
		}
		tasks = append(tasks, t)
	}

	stats := h.assignmentStats(assignmentID)
	utils.RespondSuccess(w, "Assignment retrieved", map[string]interface{}{
		"assignment": assignment,
		"tasks":      tasks,
		"stats":      stats,
	})
}

// Helpers
type sqlScanner interface {
	Scan(dest ...interface{}) error
}

func scanTask(scanner sqlScanner) (models.Task, error) {
	var t models.Task
	var taskAssignmentID sql.NullInt64
	var internID sql.NullInt64
	var description sql.NullString
	var startDate sql.NullTime
	var deadline sql.NullTime
	var deadlineTime sql.NullString
	var startedAt sql.NullTime
	var submittedAt sql.NullTime
	var completedAt sql.NullTime
	var approvedAt sql.NullTime
	var submissionNotes sql.NullString
	var submissionLinks sql.NullString
	var score sql.NullInt64
	var adminFeedback sql.NullString
	var internName sql.NullString
	var assignedByName sql.NullString

	if err := scanner.Scan(
		&t.ID, &taskAssignmentID, &internID, &t.AssignedBy, &t.Title, &description, &t.Priority, &t.Status,
		&startDate, &deadline, &deadlineTime, &startedAt, &submittedAt, &completedAt, &approvedAt,
		&t.IsLate, &submissionNotes, &submissionLinks, &score, &adminFeedback, &t.CreatedAt, &t.UpdatedAt,
		&internName, &assignedByName,
	); err != nil {
		return t, err
	}

	t.TaskAssignmentID = ptrInt64FromNull(taskAssignmentID)
	t.InternID = ptrInt64FromNull(internID)
	t.Description = ptrStringFromNull(description)
	t.StartDate = ptrTimeFromNull(startDate)
	t.Deadline = ptrTimeFromNull(deadline)
	t.DeadlineTime = ptrStringFromNull(deadlineTime)
	t.StartedAt = ptrTimeFromNull(startedAt)
	t.SubmittedAt = ptrTimeFromNull(submittedAt)
	t.CompletedAt = ptrTimeFromNull(completedAt)
	t.ApprovedAt = ptrTimeFromNull(approvedAt)
	t.SubmissionNotes = ptrStringFromNull(submissionNotes)
	t.Score = ptrIntFromNull(score)
	t.AdminFeedback = ptrStringFromNull(adminFeedback)

	if submissionLinks.Valid {
		var links []models.SubmissionLink
		_ = json.Unmarshal([]byte(submissionLinks.String), &links)
		t.SubmissionLinks = links
	}
	if internName.Valid {
		t.InternName = internName.String
	}
	if assignedByName.Valid {
		t.AssignedByName = assignedByName.String
	}

	return t, nil
}

func (h *TaskHandler) getInternIDForUser(userID int64) (int64, error) {
	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", userID).Scan(&internID)
	return internID, err
}

func (h *TaskHandler) createNotification(userID int64, ntype, title, message, link string, data map[string]interface{}) error {
	var dataStr sql.NullString
	if data != nil {
		if b, err := json.Marshal(data); err == nil {
			dataStr = sql.NullString{String: string(b), Valid: true}
		}
	}
	_, err := h.db.Exec(
		`INSERT INTO notifications (user_id, type, title, message, link, data)
		 VALUES (?, ?, ?, ?, ?, ?)`,
		userID, ntype, title, message, nullIfEmpty(link), dataStr,
	)
	return err
}

func (h *TaskHandler) assignmentStats(assignmentID int64) map[string]interface{} {
	row := h.db.QueryRow(`
		SELECT
			COUNT(*) as total,
			SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
			SUM(CASE WHEN status = 'completed' AND is_late = 0 THEN 1 ELSE 0 END) as completed_on_time,
			SUM(CASE WHEN status = 'completed' AND is_late = 1 THEN 1 ELSE 0 END) as completed_late,
			SUM(CASE WHEN status = 'submitted' THEN 1 ELSE 0 END) as submitted,
			SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
			SUM(CASE WHEN status = 'revision' THEN 1 ELSE 0 END) as revision,
			SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
			SUM(CASE WHEN status = 'scheduled' THEN 1 ELSE 0 END) as scheduled,
			AVG(CASE WHEN status = 'completed' THEN score ELSE NULL END) as average_score
		FROM tasks
		WHERE task_assignment_id = ?
	`, assignmentID)

	var total, completed, completedOnTime, completedLate, submitted, inProgress, revision, pending, scheduled sql.NullInt64
	var avgScore sql.NullFloat64
	_ = row.Scan(&total, &completed, &completedOnTime, &completedLate, &submitted, &inProgress, &revision, &pending, &scheduled, &avgScore)

	progress := 0.0
	if total.Valid && total.Int64 > 0 && completed.Valid {
		progress = (float64(completed.Int64) / float64(total.Int64)) * 100
	}

	stats := map[string]interface{}{
		"total":               int64OrZero(total),
		"completed":           int64OrZero(completed),
		"completed_on_time":   int64OrZero(completedOnTime),
		"completed_late":      int64OrZero(completedLate),
		"submitted":           int64OrZero(submitted),
		"in_progress":         int64OrZero(inProgress),
		"revision":            int64OrZero(revision),
		"pending":             int64OrZero(pending),
		"scheduled":           int64OrZero(scheduled),
		"progress_percentage": int(progress + 0.5),
		"average_score":       floatOrZero(avgScore),
	}
	return stats
}

func (h *TaskHandler) isLate(deadline sql.NullTime, deadlineTime sql.NullString, now time.Time) bool {
	if !deadline.Valid {
		return false
	}
	dt := time.Date(deadline.Time.Year(), deadline.Time.Month(), deadline.Time.Day(), 23, 59, 59, 0, now.Location())
	if deadlineTime.Valid {
		if t, err := time.Parse("15:04:05", deadlineTime.String); err == nil {
			dt = time.Date(deadline.Time.Year(), deadline.Time.Month(), deadline.Time.Day(), t.Hour(), t.Minute(), t.Second(), 0, now.Location())
		}
	}
	return now.After(dt)
}

func placeholders(n int) string {
	if n <= 0 {
		return ""
	}
	sb := strings.Builder{}
	for i := 0; i < n; i++ {
		if i > 0 {
			sb.WriteString(",")
		}
		sb.WriteString("?")
	}
	return sb.String()
}

func ptrStringFromNull(value sql.NullString) *string {
	if !value.Valid {
		return nil
	}
	v := value.String
	return &v
}

func ptrTimeFromNull(value sql.NullTime) *time.Time {
	if !value.Valid {
		return nil
	}
	v := value.Time
	return &v
}

func ptrInt64FromNull(value sql.NullInt64) *int64 {
	if !value.Valid {
		return nil
	}
	v := value.Int64
	return &v
}

func ptrIntFromNull(value sql.NullInt64) *int {
	if !value.Valid {
		return nil
	}
	v := int(value.Int64)
	return &v
}

func nullIfEmpty(value string) sql.NullString {
	if strings.TrimSpace(value) == "" {
		return sql.NullString{Valid: false}
	}
	return sql.NullString{String: value, Valid: true}
}

func int64OrZero(v sql.NullInt64) int64 {
	if v.Valid {
		return v.Int64
	}
	return 0
}

func floatOrZero(v sql.NullFloat64) float64 {
	if v.Valid {
		return v.Float64
	}
	return 0
}
./internal/handlers/password_reset.go
package handlers

import (
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/utils"

	"golang.org/x/crypto/bcrypt"
)

type PasswordResetHandler struct {
	db *sql.DB
}

func NewPasswordResetHandler(db *sql.DB) *PasswordResetHandler {
	return &PasswordResetHandler{db: db}
}

func (h *PasswordResetHandler) RequestReset(w http.ResponseWriter, r *http.Request) {
	var payload struct {
		Email string `json:"email"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	email := strings.TrimSpace(strings.ToLower(payload.Email))
	if email == "" {
		utils.RespondBadRequest(w, "Email is required")
		return
	}

	// Always respond success to avoid leaking user existence
	var userCount int
	_ = h.db.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", email).Scan(&userCount)
	if userCount == 0 {
		utils.RespondSuccess(w, "If the email exists, a reset link will be sent", nil)
		return
	}

	token, err := utils.GenerateToken(32)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate token")
		return
	}

	hash := sha256.Sum256([]byte(token))
	hashStr := hex.EncodeToString(hash[:])

	// Clear old tokens
	_, _ = h.db.Exec("DELETE FROM password_resets WHERE email = ?", email)
	_, err = h.db.Exec(
		"INSERT INTO password_resets (email, token_hash, created_at) VALUES (?, ?, ?)",
		email, hashStr, time.Now(),
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to save reset token")
		return
	}

	resetURL := config.Loaded.OAuth.FrontendURL + "/reset-password?email=" + email + "&token=" + token
	subject := "Reset Password"
	body := "Gunakan tautan berikut untuk mengatur ulang password Anda:\n\n" + resetURL + "\n\nTautan ini berlaku selama 1 jam."

	sent := false
	if config.Loaded.SMTP.Host != "" && config.Loaded.SMTP.From != "" {
		if err := utils.SendMail(email, subject, body); err == nil {
			sent = true
		}
	}

	responsePayload := map[string]interface{}{
		"sent": sent,
	}
	if !sent && config.Loaded.App.Env != "production" {
		responsePayload["token"] = token
		responsePayload["reset_url"] = resetURL
	}

	utils.RespondSuccess(w, "If the email exists, a reset link will be sent", responsePayload)
}

func (h *PasswordResetHandler) Reset(w http.ResponseWriter, r *http.Request) {
	var payload struct {
		Email                string `json:"email"`
		Token                string `json:"token"`
		Password             string `json:"password"`
		PasswordConfirmation string `json:"password_confirmation"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	email := strings.TrimSpace(strings.ToLower(payload.Email))
	if email == "" || payload.Token == "" || payload.Password == "" {
		utils.RespondBadRequest(w, "Email, token, and password are required")
		return
	}
	if payload.Password != payload.PasswordConfirmation {
		utils.RespondBadRequest(w, "Password confirmation does not match")
		return
	}
	if len(payload.Password) < 6 {
		utils.RespondBadRequest(w, "Password must be at least 6 characters")
		return
	}

	// Check token
	hash := sha256.Sum256([]byte(payload.Token))
	hashStr := hex.EncodeToString(hash[:])

	var createdAt time.Time
	err := h.db.QueryRow(
		"SELECT created_at FROM password_resets WHERE email = ? AND token_hash = ?",
		email, hashStr,
	).Scan(&createdAt)
	if err == sql.ErrNoRows {
		utils.RespondBadRequest(w, "Invalid token")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if time.Since(createdAt) > time.Hour {
		utils.RespondBadRequest(w, "Token expired")
		return
	}

	newHash, err := bcrypt.GenerateFromPassword([]byte(payload.Password), bcrypt.DefaultCost)
	if err != nil {
		utils.RespondInternalError(w, "Failed to hash password")
		return
	}

	if _, err := h.db.Exec("UPDATE users SET password_hash = ? WHERE email = ?", string(newHash), email); err != nil {
		utils.RespondInternalError(w, "Failed to update password")
		return
	}

	_, _ = h.db.Exec("DELETE FROM password_resets WHERE email = ?", email)

	utils.RespondSuccess(w, "Password updated", nil)
}
./internal/handlers/oauth.go
package handlers

import (
	"context"
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
)

func googleOAuthConfig() *oauth2.Config {
	cfg := config.Loaded
	return &oauth2.Config{
		ClientID:     cfg.OAuth.GoogleClientID,
		ClientSecret: cfg.OAuth.GoogleClientSecret,
		RedirectURL:  cfg.OAuth.GoogleRedirectURL,
		Scopes:       []string{"openid", "email", "profile"},
		Endpoint:     google.Endpoint,
	}
}

// StartGoogleOAuth returns a Google OAuth URL or redirects to it
func (h *AuthHandler) StartGoogleOAuth(w http.ResponseWriter, r *http.Request) {
	if config.Loaded.OAuth.GoogleClientID == "" || config.Loaded.OAuth.GoogleClientSecret == "" || config.Loaded.OAuth.GoogleRedirectURL == "" {
		utils.RespondInternalError(w, "Google OAuth is not configured")
		return
	}

	state, err := utils.GenerateToken(24)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate state")
		return
	}

	redirectPath := strings.TrimSpace(r.URL.Query().Get("redirect_path"))
	if redirectPath != "" {
		http.SetCookie(w, &http.Cookie{
			Name:     "oauth_redirect",
			Value:    redirectPath,
			MaxAge:   600,
			Path:     "/",
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Secure:   config.Loaded.App.Env == "production",
		})
	}

	// store state in cookie (10 min)
	http.SetCookie(w, &http.Cookie{
		Name:     "oauth_state",
		Value:    state,
		MaxAge:   600,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		Secure:   config.Loaded.App.Env == "production",
	})

	url := googleOAuthConfig().AuthCodeURL(state, oauth2.AccessTypeOffline)

	if r.URL.Query().Get("redirect") == "1" {
		http.Redirect(w, r, url, http.StatusFound)
		return
	}

	utils.RespondSuccess(w, "OAuth URL generated", map[string]string{"url": url})
}

// HandleGoogleCallback handles OAuth callback and returns JWT
func (h *AuthHandler) HandleGoogleCallback(w http.ResponseWriter, r *http.Request) {
	state := r.URL.Query().Get("state")
	code := r.URL.Query().Get("code")

	cookie, err := r.Cookie("oauth_state")
	if err != nil || cookie.Value == "" || cookie.Value != state {
		utils.RespondBadRequest(w, "Invalid OAuth state")
		return
	}

	if code == "" {
		utils.RespondBadRequest(w, "Missing code")
		return
	}

	token, err := googleOAuthConfig().Exchange(context.Background(), code)
	if err != nil {
		utils.RespondInternalError(w, "Failed to exchange code")
		return
	}

	client := googleOAuthConfig().Client(context.Background(), token)
	resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch user info")
		return
	}
	defer resp.Body.Close()

	var info struct {
		ID      string `json:"id"`
		Email   string `json:"email"`
		Name    string `json:"name"`
		Picture string `json:"picture"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&info); err != nil {
		utils.RespondInternalError(w, "Failed to parse user info")
		return
	}

	if info.Email == "" {
		utils.RespondBadRequest(w, "Email not available from Google")
		return
	}

	var user models.User
	var errUser error
	query := `SELECT id, name, email, role, avatar, google_id, provider, is_2fa_enabled, created_at
	          FROM users WHERE google_id = ? OR email = ? LIMIT 1`
	errUser = h.db.QueryRow(query, info.ID, info.Email).Scan(
		&user.ID, &user.Name, &user.Email, &user.Role, &user.Avatar, &user.GoogleID, &user.Provider, &user.Is2FAEnabled, &user.CreatedAt,
	)

	setupRequired := false
	if errUser == sql.ErrNoRows {
		// Create user
		res, err := h.db.Exec(
			"INSERT INTO users (name, email, role, google_id, provider, avatar) VALUES (?, ?, ?, ?, ?, ?)",
			info.Name, info.Email, "intern", info.ID, "google", info.Picture,
		)
		if err != nil {
			utils.RespondInternalError(w, "Failed to create user")
			return
		}
		userID, _ := res.LastInsertId()
		user.ID = userID
		user.Email = info.Email
		user.Role = "intern"
		user.Name = sql.NullString{String: info.Name, Valid: info.Name != ""}
		user.Avatar = sql.NullString{String: info.Picture, Valid: info.Picture != ""}
		user.Is2FAEnabled = false
		user.CreatedAt = time.Now()
		setupRequired = true

		// Create minimal intern profile
		start := time.Now()
		end := time.Now().AddDate(0, 3, 0)
		_, _ = h.db.Exec(
			`INSERT INTO interns (user_id, full_name, start_date, end_date, status)
			 VALUES (?, ?, ?, ?, 'pending')`,
			userID, info.Name, start, end,
		)
	} else if errUser != nil {
		utils.RespondInternalError(w, "Database error")
		return
	} else {
		// Update google_id/provider/avatar if missing
		if !user.GoogleID.Valid || user.GoogleID.String == "" {
			_, _ = h.db.Exec("UPDATE users SET google_id = ?, provider = 'google' WHERE id = ?", info.ID, user.ID)
		}
		if info.Picture != "" {
			_, _ = h.db.Exec("UPDATE users SET avatar = ? WHERE id = ?", info.Picture, user.ID)
		}
	}

	// Block pending intern/supervisor
	role := normalizeRole(user.Role)
	if role == "intern" {
		var status string
		if err := h.db.QueryRow("SELECT status FROM interns WHERE user_id = ?", user.ID).Scan(&status); err == nil {
			if status == "pending" {
				utils.RespondForbidden(w, "Account pending approval")
				return
			}
		}
	}
	if role == "pembimbing" {
		var status string
		if err := h.db.QueryRow("SELECT status FROM supervisors WHERE user_id = ?", user.ID).Scan(&status); err == nil {
			if status == "pending" {
				utils.RespondForbidden(w, "Account pending approval")
				return
			}
		}
	}

	jwtToken, err := h.generateToken(&user)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate token")
		return
	}

	// optional redirect to frontend
	redirect := r.URL.Query().Get("redirect")
	if strings.TrimSpace(redirect) != "" {
		redirectURL := config.Loaded.OAuth.FrontendURL + redirect
		q := "?token=" + jwtToken
		if setupRequired {
			q += "&setup_required=1"
		}
		http.Redirect(w, r, redirectURL+q, http.StatusFound)
		return
	}

	if rc, err := r.Cookie("oauth_redirect"); err == nil && rc.Value != "" {
		http.SetCookie(w, &http.Cookie{
			Name:     "oauth_redirect",
			Value:    "",
			MaxAge:   -1,
			Path:     "/",
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Secure:   config.Loaded.App.Env == "production",
		})
		redirectURL := config.Loaded.OAuth.FrontendURL + rc.Value
		q := "?token=" + jwtToken
		if setupRequired {
			q += "&setup_required=1"
		}
		http.Redirect(w, r, redirectURL+q, http.StatusFound)
		return
	}

	utils.RespondSuccess(w, "OAuth login successful", LoginResponse{
		Token:         jwtToken,
		User:          toUserResponse(user),
		Require2FA:    user.Is2FAEnabled,
		SetupRequired: setupRequired,
	})
}
./internal/handlers/supervisor.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"

	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
	"golang.org/x/crypto/bcrypt"
)

type SupervisorHandler struct {
	db *sql.DB
}

func NewSupervisorHandler(db *sql.DB) *SupervisorHandler {
	return &SupervisorHandler{db: db}
}

type createSupervisorRequest struct {
	Name        string `json:"name"`
	Email       string `json:"email"`
	Password    string `json:"password"`
	NIP         string `json:"nip"`
	Phone       string `json:"phone"`
	Position    string `json:"position"`
	Address     string `json:"address"`
	Institution string `json:"institution"`
	Status      string `json:"status"`
}

type updateSupervisorRequest struct {
	Name        *string `json:"name"`
	Email       *string `json:"email"`
	Password    *string `json:"password"`
	NIP         *string `json:"nip"`
	Phone       *string `json:"phone"`
	Position    *string `json:"position"`
	Address     *string `json:"address"`
	Institution *string `json:"institution"`
	Status      *string `json:"status"`
}

func (h *SupervisorHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	search := strings.TrimSpace(r.URL.Query().Get("search"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))

	where := []string{}
	args := []interface{}{}

	if status != "" {
		where = append(where, "s.status = ?")
		args = append(args, status)
	}
	if search != "" {
		where = append(where, "(u.name LIKE ? OR u.email LIKE ? OR s.institution LIKE ? OR s.nip LIKE ?)")
		like := "%" + search + "%"
		args = append(args, like, like, like, like)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	var total int64
	countQuery := "SELECT COUNT(*) FROM supervisors s JOIN users u ON s.user_id = u.id " + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count supervisors")
		return
	}

	query := `
		SELECT s.id, s.user_id, s.full_name, s.nip, s.phone, s.position, s.address, s.institution,
		       s.status, s.created_at, s.updated_at, u.email, u.name,
		       (SELECT COUNT(*) FROM interns i WHERE i.supervisor_id = s.user_id) as interns_count
		FROM supervisors s
		JOIN users u ON s.user_id = u.id
	` + whereClause + ` ORDER BY s.created_at DESC LIMIT ? OFFSET ?`

	args = append(args, limit, offset)
	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch supervisors")
		return
	}
	defer rows.Close()

	supervisors := []models.Supervisor{}
	for rows.Next() {
		var s models.Supervisor
		var nip, phone, position, address, institution sql.NullString
		var email, userName string
		if err := rows.Scan(
			&s.ID, &s.UserID, &s.FullName, &nip, &phone, &position, &address, &institution,
			&s.Status, &s.CreatedAt, &s.UpdatedAt, &email, &userName, &s.InternsCount,
		); err != nil {
			continue
		}
		if strings.TrimSpace(s.FullName) == "" {
			s.FullName = userName
		}
		s.Email = email
		s.NIP = ptrStringFromNull(nip)
		s.Phone = ptrStringFromNull(phone)
		s.Position = ptrStringFromNull(position)
		s.Address = ptrStringFromNull(address)
		s.Institution = ptrStringFromNull(institution)
		supervisors = append(supervisors, s)
	}

	utils.RespondPaginated(w, supervisors, utils.CalculatePagination(page, limit, total))
}

func (h *SupervisorHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var s models.Supervisor
	var nip, phone, position, address, institution sql.NullString
	var email, userName string
	query := `
		SELECT s.id, s.user_id, s.full_name, s.nip, s.phone, s.position, s.address, s.institution,
		       s.status, s.created_at, s.updated_at, u.email, u.name,
		       (SELECT COUNT(*) FROM interns i WHERE i.supervisor_id = s.user_id) as interns_count
		FROM supervisors s
		JOIN users u ON s.user_id = u.id
		WHERE s.id = ?
	`
	if err := h.db.QueryRow(query, id).Scan(
		&s.ID, &s.UserID, &s.FullName, &nip, &phone, &position, &address, &institution,
		&s.Status, &s.CreatedAt, &s.UpdatedAt, &email, &userName, &s.InternsCount,
	); err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Supervisor not found")
		return
	} else if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	if strings.TrimSpace(s.FullName) == "" {
		s.FullName = userName
	}
	s.Email = email
	s.NIP = ptrStringFromNull(nip)
	s.Phone = ptrStringFromNull(phone)
	s.Position = ptrStringFromNull(position)
	s.Address = ptrStringFromNull(address)
	s.Institution = ptrStringFromNull(institution)

	utils.RespondSuccess(w, "Supervisor retrieved", s)
}

func (h *SupervisorHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req createSupervisorRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if strings.TrimSpace(req.Name) == "" || strings.TrimSpace(req.Email) == "" || strings.TrimSpace(req.Password) == "" {
		utils.RespondBadRequest(w, "Name, email, and password are required")
		return
	}

	if len(req.Password) < 6 {
		utils.RespondBadRequest(w, "Password must be at least 6 characters")
		return
	}

	var exists int
	_ = h.db.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", req.Email).Scan(&exists)
	if exists > 0 {
		utils.RespondBadRequest(w, "Email already exists")
		return
	}

	status := strings.TrimSpace(req.Status)
	if status == "" {
		status = "active"
	}
	if status != "active" && status != "pending" {
		utils.RespondBadRequest(w, "Invalid status")
		return
	}

	hashed, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		utils.RespondInternalError(w, "Failed to hash password")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	res, err := tx.Exec("INSERT INTO users (name, email, password_hash, role) VALUES (?, ?, ?, ?)", req.Name, req.Email, string(hashed), "pembimbing")
	if err != nil {
		utils.RespondInternalError(w, "Failed to create user")
		return
	}
	userID, _ := res.LastInsertId()

	supRes, err := tx.Exec(
		`INSERT INTO supervisors (user_id, full_name, nip, phone, position, address, institution, status)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
		userID, req.Name, nullIfEmpty(req.NIP), nullIfEmpty(req.Phone), nullIfEmpty(req.Position), nullIfEmpty(req.Address), nullIfEmpty(req.Institution), status,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create supervisor")
		return
	}
	supervisorID, _ := supRes.LastInsertId()

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondCreated(w, "Supervisor created", map[string]interface{}{
		"user_id":       userID,
		"supervisor_id": supervisorID,
	})
}

func (h *SupervisorHandler) Update(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateSupervisorRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	var userID int64
	var currentEmail string
	if err := h.db.QueryRow("SELECT user_id FROM supervisors WHERE id = ?", id).Scan(&userID); err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Supervisor not found")
		return
	} else if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}
	_ = h.db.QueryRow("SELECT email FROM users WHERE id = ?", userID).Scan(&currentEmail)

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	userUpdates := []string{}
	userArgs := []interface{}{}
	if req.Name != nil {
		userUpdates = append(userUpdates, "name = ?")
		userArgs = append(userArgs, *req.Name)
	}
	if req.Email != nil {
		newEmail := strings.TrimSpace(*req.Email)
		if newEmail != "" && newEmail != currentEmail {
			var exists int
			_ = h.db.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", newEmail).Scan(&exists)
			if exists > 0 {
				utils.RespondBadRequest(w, "Email already exists")
				return
			}
		}
		userUpdates = append(userUpdates, "email = ?")
		userArgs = append(userArgs, newEmail)
	}
	if req.Password != nil && strings.TrimSpace(*req.Password) != "" {
		if len(*req.Password) < 6 {
			utils.RespondBadRequest(w, "Password must be at least 6 characters")
			return
		}
		hash, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
		if err != nil {
			utils.RespondInternalError(w, "Failed to hash password")
			return
		}
		userUpdates = append(userUpdates, "password_hash = ?")
		userArgs = append(userArgs, string(hash))
	}

	if len(userUpdates) > 0 {
		userArgs = append(userArgs, userID)
		if _, err := tx.Exec("UPDATE users SET "+strings.Join(userUpdates, ", ")+" WHERE id = ?", userArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update user")
			return
		}
	}

	supUpdates := []string{}
	supArgs := []interface{}{}
	if req.Name != nil {
		supUpdates = append(supUpdates, "full_name = ?")
		supArgs = append(supArgs, *req.Name)
	}
	if req.NIP != nil {
		supUpdates = append(supUpdates, "nip = ?")
		supArgs = append(supArgs, nullIfEmpty(*req.NIP))
	}
	if req.Phone != nil {
		supUpdates = append(supUpdates, "phone = ?")
		supArgs = append(supArgs, nullIfEmpty(*req.Phone))
	}
	if req.Position != nil {
		supUpdates = append(supUpdates, "position = ?")
		supArgs = append(supArgs, nullIfEmpty(*req.Position))
	}
	if req.Address != nil {
		supUpdates = append(supUpdates, "address = ?")
		supArgs = append(supArgs, nullIfEmpty(*req.Address))
	}
	if req.Institution != nil {
		supUpdates = append(supUpdates, "institution = ?")
		supArgs = append(supArgs, nullIfEmpty(*req.Institution))
	}
	if req.Status != nil {
		status := strings.TrimSpace(*req.Status)
		if status != "" {
			if status != "active" && status != "pending" {
				utils.RespondBadRequest(w, "Invalid status")
				return
			}
			supUpdates = append(supUpdates, "status = ?")
			supArgs = append(supArgs, status)
		}
	}

	if len(supUpdates) > 0 {
		supArgs = append(supArgs, id)
		if _, err := tx.Exec("UPDATE supervisors SET "+strings.Join(supUpdates, ", ")+" WHERE id = ?", supArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update supervisor")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondSuccess(w, "Supervisor updated", nil)
}

func (h *SupervisorHandler) Approve(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	res, err := h.db.Exec("UPDATE supervisors SET status = 'active' WHERE id = ?", id)
	if err != nil {
		utils.RespondInternalError(w, "Failed to approve supervisor")
		return
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		utils.RespondNotFound(w, "Supervisor not found")
		return
	}

	utils.RespondSuccess(w, "Supervisor approved", nil)
}

func (h *SupervisorHandler) Reject(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var userID int64
	if err := h.db.QueryRow("SELECT user_id FROM supervisors WHERE id = ?", id).Scan(&userID); err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Supervisor not found")
		return
	} else if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	if _, err := tx.Exec("DELETE FROM supervisors WHERE id = ?", id); err != nil {
		utils.RespondInternalError(w, "Failed to delete supervisor")
		return
	}
	if _, err := tx.Exec("DELETE FROM users WHERE id = ?", userID); err != nil {
		utils.RespondInternalError(w, "Failed to delete user")
		return
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondSuccess(w, "Supervisor rejected", nil)
}

func (h *SupervisorHandler) Delete(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var userID int64
	if err := h.db.QueryRow("SELECT user_id FROM supervisors WHERE id = ?", id).Scan(&userID); err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Supervisor not found")
		return
	} else if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	var assigned int64
	_ = h.db.QueryRow("SELECT COUNT(*) FROM interns WHERE supervisor_id = ?", userID).Scan(&assigned)
	if assigned > 0 {
		utils.RespondBadRequest(w, "Supervisor still has assigned interns")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	if _, err := tx.Exec("DELETE FROM supervisors WHERE id = ?", id); err != nil {
		utils.RespondInternalError(w, "Failed to delete supervisor")
		return
	}
	if _, err := tx.Exec("DELETE FROM users WHERE id = ?", userID); err != nil {
		utils.RespondInternalError(w, "Failed to delete user")
		return
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondSuccess(w, "Supervisor deleted", nil)
}
./internal/handlers/profile.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"golang.org/x/crypto/bcrypt"
)

type ProfileHandler struct {
	db *sql.DB
}

func NewProfileHandler(db *sql.DB) *ProfileHandler {
	return &ProfileHandler{db: db}
}

func (h *ProfileHandler) Get(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	var user models.User
	if err := h.db.QueryRow(
		"SELECT id, email, role, name, avatar, is_2fa_enabled, created_at FROM users WHERE id = ?",
		claims.UserID,
	).Scan(&user.ID, &user.Email, &user.Role, &user.Name, &user.Avatar, &user.Is2FAEnabled, &user.CreatedAt); err != nil {
		utils.RespondInternalError(w, "User not found")
		return
	}

	var intern models.Intern
	err := h.db.QueryRow(
		`SELECT id, user_id, institution_id, supervisor_id, full_name, nis, student_id, school, department, date_of_birth,
		        gender, phone, address, start_date, end_date, status, certificate_number, certificate_issued_at, created_at, updated_at
		 FROM interns WHERE user_id = ?`,
		claims.UserID,
	).Scan(
		&intern.ID, &intern.UserID, &intern.InstitutionID, &intern.SupervisorID, &intern.FullName, &intern.NIS, &intern.StudentID,
		&intern.School, &intern.Department, &intern.DateOfBirth, &intern.Gender, &intern.Phone, &intern.Address,
		&intern.StartDate, &intern.EndDate, &intern.Status, &intern.CertificateNumber, &intern.CertificateIssuedAt,
		&intern.CreatedAt, &intern.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		utils.RespondSuccess(w, "Profile retrieved", map[string]interface{}{
			"user":   toUserResponse(user),
			"intern": intern,
		})
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	utils.RespondSuccess(w, "Profile retrieved", map[string]interface{}{
		"user":   toUserResponse(user),
		"intern": intern,
	})
}

func (h *ProfileHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	contentType := r.Header.Get("Content-Type")
	name := ""
	email := ""
	avatarPath := ""

	if strings.Contains(contentType, "multipart/form-data") {
		if err := r.ParseMultipartForm(10 << 20); err != nil {
			utils.RespondBadRequest(w, "Failed to parse form data")
			return
		}
		name = strings.TrimSpace(r.FormValue("name"))
		email = strings.TrimSpace(r.FormValue("email"))

		file, header, err := r.FormFile("avatar")
		if err == nil {
			defer file.Close()
			path, err := utils.UploadFile(file, header, "avatars")
			if err != nil {
				utils.RespondBadRequest(w, "Upload failed: "+err.Error())
				return
			}
			avatarPath = path
		}
	} else {
		var payload struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			utils.RespondBadRequest(w, "Invalid request body")
			return
		}
		name = strings.TrimSpace(payload.Name)
		email = strings.TrimSpace(payload.Email)
	}

	if name == "" || email == "" {
		utils.RespondBadRequest(w, "Name and email are required")
		return
	}

	var currentEmail string
	_ = h.db.QueryRow("SELECT email FROM users WHERE id = ?", claims.UserID).Scan(&currentEmail)
	if email != currentEmail {
		var exists int
		_ = h.db.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", email).Scan(&exists)
		if exists > 0 {
			utils.RespondBadRequest(w, "Email already exists")
			return
		}
	}

	updates := []string{"name = ?", "email = ?"}
	args := []interface{}{name, email}
	if avatarPath != "" {
		updates = append(updates, "avatar = ?")
		args = append(args, avatarPath)
	}
	args = append(args, claims.UserID)

	query := "UPDATE users SET " + strings.Join(updates, ", ") + " WHERE id = ?"
	if _, err := h.db.Exec(query, args...); err != nil {
		utils.RespondInternalError(w, "Failed to update profile")
		return
	}

	utils.RespondSuccess(w, "Profile updated", nil)
}

func (h *ProfileHandler) UpdatePassword(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	var payload struct {
		CurrentPassword string `json:"current_password"`
		Password        string `json:"password"`
		PasswordConfirm string `json:"password_confirmation"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}
	if payload.CurrentPassword == "" || payload.Password == "" {
		utils.RespondBadRequest(w, "Current password and new password are required")
		return
	}
	if payload.Password != payload.PasswordConfirm {
		utils.RespondBadRequest(w, "Password confirmation does not match")
		return
	}
	if len(payload.Password) < 6 {
		utils.RespondBadRequest(w, "Password must be at least 6 characters")
		return
	}

	var hashed string
	if err := h.db.QueryRow("SELECT password_hash FROM users WHERE id = ?", claims.UserID).Scan(&hashed); err != nil {
		utils.RespondInternalError(w, "User not found")
		return
	}
	if err := bcrypt.CompareHashAndPassword([]byte(hashed), []byte(payload.CurrentPassword)); err != nil {
		utils.RespondBadRequest(w, "Current password is incorrect")
		return
	}

	newHash, err := bcrypt.GenerateFromPassword([]byte(payload.Password), bcrypt.DefaultCost)
	if err != nil {
		utils.RespondInternalError(w, "Failed to hash password")
		return
	}

	if _, err := h.db.Exec("UPDATE users SET password_hash = ? WHERE id = ?", string(newHash), claims.UserID); err != nil {
		utils.RespondInternalError(w, "Failed to update password")
		return
	}

	utils.RespondSuccess(w, "Password updated", nil)
}
./internal/handlers/intern.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
	"golang.org/x/crypto/bcrypt"
)

type InternHandler struct {
	db *sql.DB
}

func NewInternHandler(db *sql.DB) *InternHandler {
	return &InternHandler{db: db}
}

type createInternRequest struct {
	Email         string `json:"email"`
	Password      string `json:"password,omitempty"`
	FullName      string `json:"full_name"`
	NIS           string `json:"nis,omitempty"`
	StudentID     string `json:"student_id,omitempty"`
	School        string `json:"school"`
	Department    string `json:"department"`
	Phone         string `json:"phone,omitempty"`
	Address       string `json:"address,omitempty"`
	StartDate     string `json:"start_date"` // YYYY-MM-DD
	EndDate       string `json:"end_date"`   // YYYY-MM-DD
	Status        string `json:"status,omitempty"`
	InstitutionID *int64 `json:"institution_id,omitempty"`
	SupervisorID  *int64 `json:"supervisor_id,omitempty"`
}

type updateInternRequest struct {
	Email         *string `json:"email,omitempty"`
	Password      *string `json:"password,omitempty"`
	FullName      *string `json:"full_name,omitempty"`
	NIS           *string `json:"nis,omitempty"`
	StudentID     *string `json:"student_id,omitempty"`
	School        *string `json:"school,omitempty"`
	Department    *string `json:"department,omitempty"`
	Phone         *string `json:"phone,omitempty"`
	Address       *string `json:"address,omitempty"`
	StartDate     *string `json:"start_date,omitempty"`
	EndDate       *string `json:"end_date,omitempty"`
	Status        *string `json:"status,omitempty"`
	InstitutionID *int64  `json:"institution_id,omitempty"`
	SupervisorID  *int64  `json:"supervisor_id,omitempty"`
}

func (h *InternHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	role := normalizeRole(claims.Role)
	if role == "intern" {
		internID, err := h.getInternIDForUser(claims.UserID)
		if err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		r = r.Clone(r.Context())
		q := r.URL.Query()
		q.Set("intern_id", strconv.FormatInt(internID, 10))
		r.URL.RawQuery = q.Encode()
		h.GetByID(w, r)
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	search := strings.TrimSpace(r.URL.Query().Get("search"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))
	supervisorFilter := strings.TrimSpace(r.URL.Query().Get("supervisor_id"))

	where := []string{}
	args := []interface{}{}

	if status != "" {
		where = append(where, "i.status = ?")
		args = append(args, status)
	}
	if supervisorFilter != "" {
		if id, err := strconv.ParseInt(supervisorFilter, 10, 64); err == nil {
			where = append(where, "i.supervisor_id = ?")
			args = append(args, id)
		}
	}
	if search != "" {
		where = append(where, "(i.full_name LIKE ? OR i.school LIKE ? OR i.department LIKE ? OR u.email LIKE ?)")
		like := "%" + search + "%"
		args = append(args, like, like, like, like)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
		FROM interns i
		JOIN users u ON i.user_id = u.id
		LEFT JOIN users su ON i.supervisor_id = su.id
		LEFT JOIN institutions inst ON i.institution_id = inst.id
	`

	var total int64
	countQuery := "SELECT COUNT(*) " + baseFrom + " " + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count interns")
		return
	}

	query := `
		SELECT i.id, i.user_id, i.institution_id, i.supervisor_id, i.full_name,
		       COALESCE(i.nis,''), COALESCE(i.student_id,''), COALESCE(i.school,''), COALESCE(i.department,''),
		       i.date_of_birth, COALESCE(i.gender,''), COALESCE(i.phone,''), COALESCE(i.address,''),
		       i.start_date, i.end_date, i.status, i.certificate_number, i.certificate_issued_at, i.created_at, i.updated_at,
		       u.email, COALESCE(su.name,''), COALESCE(inst.name,'')
	` + baseFrom + " " + whereClause + " ORDER BY i.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch interns")
		return
	}
	defer rows.Close()

	var interns []models.InternWithDetails
	for rows.Next() {
		var i models.Intern
		var email, supervisorName, institutionName string

		if err := rows.Scan(
			&i.ID, &i.UserID, &i.InstitutionID, &i.SupervisorID, &i.FullName,
			&i.NIS, &i.StudentID, &i.School, &i.Department,
			&i.DateOfBirth, &i.Gender, &i.Phone, &i.Address,
			&i.StartDate, &i.EndDate, &i.Status, &i.CertificateNumber, &i.CertificateIssuedAt, &i.CreatedAt, &i.UpdatedAt,
			&email, &supervisorName, &institutionName,
		); err == nil {
			interns = append(interns, models.InternWithDetails{
				Intern:          i,
				SupervisorName:  supervisorName,
				InstitutionName: institutionName,
				Email:           email,
			})
		}
	}

	utils.RespondPaginated(w, interns, utils.CalculatePagination(page, limit, total))
}

func (h *InternHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	idStr := vars["id"]
	if idStr == "" {
		idStr = r.URL.Query().Get("intern_id")
	}
	internID, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid intern id")
		return
	}

	// Interns can only access their own profile
	if normalizeRole(claims.Role) == "intern" {
		myID, err := h.getInternIDForUser(claims.UserID)
		if err != nil || myID != internID {
			utils.RespondForbidden(w, "You do not have access to this intern")
			return
		}
	}

	query := `
		SELECT i.id, i.user_id, i.institution_id, i.supervisor_id, i.full_name,
		       COALESCE(i.nis,''), COALESCE(i.student_id,''), COALESCE(i.school,''), COALESCE(i.department,''),
		       i.date_of_birth, COALESCE(i.gender,''), COALESCE(i.phone,''), COALESCE(i.address,''),
		       i.start_date, i.end_date, i.status, i.certificate_number, i.certificate_issued_at, i.created_at, i.updated_at,
		       u.email, COALESCE(su.name,''), COALESCE(inst.name,'')
		FROM interns i
		JOIN users u ON i.user_id = u.id
		LEFT JOIN users su ON i.supervisor_id = su.id
		LEFT JOIN institutions inst ON i.institution_id = inst.id
		WHERE i.id = ?
	`

	var i models.Intern
	var email, supervisorName, institutionName string
	err = h.db.QueryRow(query, internID).Scan(
		&i.ID, &i.UserID, &i.InstitutionID, &i.SupervisorID, &i.FullName,
		&i.NIS, &i.StudentID, &i.School, &i.Department,
		&i.DateOfBirth, &i.Gender, &i.Phone, &i.Address,
		&i.StartDate, &i.EndDate, &i.Status, &i.CertificateNumber, &i.CertificateIssuedAt, &i.CreatedAt, &i.UpdatedAt,
		&email, &supervisorName, &institutionName,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Intern not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	result := models.InternWithDetails{
		Intern:          i,
		SupervisorName:  supervisorName,
		InstitutionName: institutionName,
		Email:           email,
	}

	utils.RespondSuccess(w, "Intern retrieved", result)
}

func (h *InternHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can create interns")
		return
	}

	var req createInternRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if strings.TrimSpace(req.Email) == "" || strings.TrimSpace(req.FullName) == "" || strings.TrimSpace(req.StartDate) == "" || strings.TrimSpace(req.EndDate) == "" {
		utils.RespondBadRequest(w, "Email, full_name, start_date, and end_date are required")
		return
	}

	startDate, err := time.Parse("2006-01-02", req.StartDate)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid start_date")
		return
	}
	endDate, err := time.Parse("2006-01-02", req.EndDate)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid end_date")
		return
	}

	status := req.Status
	if status == "" {
		status = "active"
	}

	var passwordHash sql.NullString
	if strings.TrimSpace(req.Password) != "" {
		hashed, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
		if err != nil {
			utils.RespondInternalError(w, "Failed to hash password")
			return
		}
		passwordHash = sql.NullString{String: string(hashed), Valid: true}
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	// Insert user
	res, err := tx.Exec(
		"INSERT INTO users (name, email, password_hash, role) VALUES (?, ?, ?, 'intern')",
		req.FullName, req.Email, nullIfEmptySQL(passwordHash),
	)
	if err != nil {
		utils.RespondBadRequest(w, "Email already exists")
		return
	}
	userID, _ := res.LastInsertId()

	_, err = tx.Exec(
		`INSERT INTO interns (user_id, institution_id, supervisor_id, full_name, nis, student_id, school, department,
		                      phone, address, start_date, end_date, status)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		userID, nullableInt(req.InstitutionID), nullableInt(req.SupervisorID), req.FullName, req.NIS, req.StudentID,
		req.School, req.Department, req.Phone, req.Address, startDate, endDate, status,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create intern")
		return
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondCreated(w, "Intern created", map[string]interface{}{"user_id": userID})
}

func (h *InternHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update interns")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateInternRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Get user_id for this intern
	var userID int64
	err := h.db.QueryRow("SELECT user_id FROM interns WHERE id = ?", internID).Scan(&userID)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Intern not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	userUpdates := []string{}
	userArgs := []interface{}{}
	if req.Email != nil {
		userUpdates = append(userUpdates, "email = ?")
		userArgs = append(userArgs, *req.Email)
	}
	if req.FullName != nil {
		userUpdates = append(userUpdates, "name = ?")
		userArgs = append(userArgs, *req.FullName)
	}
	if req.Password != nil && strings.TrimSpace(*req.Password) != "" {
		hashed, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
		if err != nil {
			utils.RespondInternalError(w, "Failed to hash password")
			return
		}
		userUpdates = append(userUpdates, "password_hash = ?")
		userArgs = append(userArgs, string(hashed))
	}
	if len(userUpdates) > 0 {
		userArgs = append(userArgs, userID)
		if _, err := tx.Exec("UPDATE users SET "+strings.Join(userUpdates, ", ")+" WHERE id = ?", userArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update user")
			return
		}
	}

	internUpdates := []string{}
	internArgs := []interface{}{}
	if req.FullName != nil {
		internUpdates = append(internUpdates, "full_name = ?")
		internArgs = append(internArgs, *req.FullName)
	}
	if req.NIS != nil {
		internUpdates = append(internUpdates, "nis = ?")
		internArgs = append(internArgs, *req.NIS)
	}
	if req.StudentID != nil {
		internUpdates = append(internUpdates, "student_id = ?")
		internArgs = append(internArgs, *req.StudentID)
	}
	if req.School != nil {
		internUpdates = append(internUpdates, "school = ?")
		internArgs = append(internArgs, *req.School)
	}
	if req.Department != nil {
		internUpdates = append(internUpdates, "department = ?")
		internArgs = append(internArgs, *req.Department)
	}
	if req.Phone != nil {
		internUpdates = append(internUpdates, "phone = ?")
		internArgs = append(internArgs, *req.Phone)
	}
	if req.Address != nil {
		internUpdates = append(internUpdates, "address = ?")
		internArgs = append(internArgs, *req.Address)
	}
	if req.StartDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.StartDate); err == nil {
			internUpdates = append(internUpdates, "start_date = ?")
			internArgs = append(internArgs, parsed)
		}
	}
	if req.EndDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.EndDate); err == nil {
			internUpdates = append(internUpdates, "end_date = ?")
			internArgs = append(internArgs, parsed)
		}
	}
	if req.Status != nil {
		internUpdates = append(internUpdates, "status = ?")
		internArgs = append(internArgs, *req.Status)
	}
	if req.InstitutionID != nil {
		internUpdates = append(internUpdates, "institution_id = ?")
		internArgs = append(internArgs, nullableInt(req.InstitutionID))
	}
	if req.SupervisorID != nil {
		internUpdates = append(internUpdates, "supervisor_id = ?")
		internArgs = append(internArgs, nullableInt(req.SupervisorID))
	}

	if len(internUpdates) > 0 {
		internArgs = append(internArgs, internID)
		if _, err := tx.Exec("UPDATE interns SET "+strings.Join(internUpdates, ", ")+" WHERE id = ?", internArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update intern")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondSuccess(w, "Intern updated", nil)
}

func (h *InternHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can delete interns")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if _, err := h.db.Exec("DELETE FROM interns WHERE id = ?", internID); err != nil {
		utils.RespondInternalError(w, "Failed to delete intern")
		return
	}

	utils.RespondSuccess(w, "Intern deleted", nil)
}

// Helpers
func (h *InternHandler) getInternIDForUser(userID int64) (int64, error) {
	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", userID).Scan(&internID)
	return internID, err
}

func nullableInt(val *int64) sql.NullInt64 {
	if val == nil {
		return sql.NullInt64{Valid: false}
	}
	return sql.NullInt64{Int64: *val, Valid: *val != 0}
}

func nullIfEmptySQL(val sql.NullString) interface{} {
	if val.Valid {
		return val.String
	}
	return nil
}
./internal/handlers/auth.go
package handlers

import (
	"bytes"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"image/png"
	"net/http"
	"strings"
	"time"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/golang-jwt/jwt/v5"
	"github.com/pquerna/otp/totp"
	"golang.org/x/crypto/bcrypt"
)

type AuthHandler struct {
	db *sql.DB
}

func NewAuthHandler(db *sql.DB) *AuthHandler {
	return &AuthHandler{db: db}
}

// RegisterRequest represents registration request
type RegisterRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
	Role     string `json:"role,omitempty"` // admin, pembimbing/supervisor, intern
	FullName string `json:"full_name"`

	// Optional fields for intern
	StudentID     string `json:"student_id,omitempty"`
	InstitutionID int64  `json:"institution_id,omitempty"`
	SupervisorID  int64  `json:"supervisor_id,omitempty"`
	StartDate     string `json:"start_date,omitempty"`
	EndDate       string `json:"end_date,omitempty"`

	// Optional fields for supervisor
	NIP      string `json:"nip,omitempty"`
	Position string `json:"position,omitempty"`
}

// LoginRequest represents login request
type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
	TOTPCode string `json:"totp_code,omitempty"` // Required if 2FA enabled
}

// LoginResponse represents login response
type LoginResponse struct {
	Token         string      `json:"token"`
	User          UserResponse `json:"user"`
	Require2FA    bool        `json:"require_2fa"`
	SetupRequired bool        `json:"setup_required"` // <--- ADD THIS
}

// UserResponse is a safe JSON shape for frontend consumption
type UserResponse struct {
	ID           int64  `json:"id"`
	Name         string `json:"name"`
	Email        string `json:"email"`
	Role         string `json:"role"`
	Avatar       string `json:"avatar,omitempty"`
	Is2FAEnabled bool   `json:"is_2fa_enabled"`
	CreatedAt    time.Time `json:"created_at"`
}

// Setup2FAResponse represents 2FA setup response
type Setup2FAResponse struct {
	Secret string `json:"secret"`
	QRCode string `json:"qr_code"`
}

// Verify2FARequest represents 2FA verification request
type Verify2FARequest struct {
	Code string `json:"code"`
}

// Register creates a new user
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) {
	var req RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Validate input
	if req.Email == "" || req.Password == "" || req.Role == "" || req.FullName == "" {
		utils.RespondBadRequest(w, "Missing required fields")
		return
	}

	role := strings.ToLower(strings.TrimSpace(req.Role))
	if role == "supervisor" {
		role = "pembimbing"
	}

	// Validate role
	if role != "admin" && role != "pembimbing" && role != "intern" {
		utils.RespondBadRequest(w, "Invalid role. Must be admin, pembimbing, or intern")
		return
	}

	// Validate password length
	if len(req.Password) < 6 {
		utils.RespondBadRequest(w, "Password must be at least 6 characters")
		return
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		utils.RespondInternalError(w, "Failed to hash password")
		return
	}

	// Start transaction
	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	// Insert user
	result, err := tx.Exec(
		"INSERT INTO users (name, email, password_hash, role) VALUES (?, ?, ?, ?)",
		req.FullName, req.Email, string(hashedPassword), role,
	)
	if err != nil {
		utils.RespondBadRequest(w, "Email already exists")
		return
	}

	userID, _ := result.LastInsertId()

	// Create role-specific record
	switch role {
	case "pembimbing":
		_, err = tx.Exec(
			"INSERT INTO supervisors (user_id, full_name, nip, position) VALUES (?, ?, ?, ?)",
			userID, req.FullName, req.NIP, req.Position,
		)
	case "intern":
		if req.InstitutionID == 0 || req.SupervisorID == 0 {
			utils.RespondBadRequest(w, "Institution and supervisor are required for interns")
			return
		}

		startDate := time.Now()
		endDate := time.Now().AddDate(0, 3, 0) // Default 3 months

		if req.StartDate != "" {
			startDate, _ = time.Parse("2006-01-02", req.StartDate)
		}
		if req.EndDate != "" {
			endDate, _ = time.Parse("2006-01-02", req.EndDate)
		}

		_, err = tx.Exec(
			`INSERT INTO interns (user_id, institution_id, supervisor_id, full_name, student_id, start_date, end_date, status) 
			 VALUES (?, ?, ?, ?, ?, ?, ?, 'active')`,
			userID, req.InstitutionID, req.SupervisorID, req.FullName, req.StudentID, startDate, endDate,
		)
	}

	if err != nil {
		utils.RespondInternalError(w, "Failed to create user profile")
		return
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondCreated(w, "User registered successfully", map[string]interface{}{
		"user_id": userID,
		"email":   req.Email,
		"role":    role,
	})
}

// Login authenticates user and returns JWT token
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Find user
	var user models.User
	err := h.db.QueryRow(
		"SELECT id, name, email, password_hash, role, totp_secret, is_2fa_enabled FROM users WHERE email = ?",
		req.Email,
	).Scan(&user.ID, &user.Name, &user.Email, &user.PasswordHash, &user.Role, &user.TOTPSecret, &user.Is2FAEnabled)

	if err != nil {
		utils.RespondUnauthorized(w, "Invalid email or password")
		return
	}

	// Verify password
	if !user.PasswordHash.Valid {
		utils.RespondUnauthorized(w, "Password login not available for this account")
		return
	}
	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash.String), []byte(req.Password)); err != nil {
		utils.RespondUnauthorized(w, "Invalid email or password")
		return
	}

	// 1. Check if 2FA is Enabled (Existing Logic)
	if user.Is2FAEnabled {
		if req.TOTPCode == "" {
			utils.RespondSuccess(w, "2FA Code Required", LoginResponse{
				Require2FA: true,
			})
			return
		}

		if !user.TOTPSecret.Valid {
			utils.RespondUnauthorized(w, "2FA is enabled but no secret is configured")
			return
		}
		valid := totp.Validate(req.TOTPCode, user.TOTPSecret.String)
		if !valid {
			utils.RespondUnauthorized(w, "Invalid 2FA code")
			return
		}
	}

	// Generate JWT token
	token, err := h.generateToken(&user)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate token")
		return
	}

	// 2. Determine if Setup is Required (New Logic)
	// If 2FA is NOT enabled, we mark SetupRequired as true
	setupRequired := !user.Is2FAEnabled

	utils.RespondSuccess(w, "Login successful", LoginResponse{
		Token:         token,
		User:          toUserResponse(user),
		Require2FA:    false,
		SetupRequired: setupRequired, // <--- SEND THE FLAG
	})
}

// Setup2FA generates TOTP secret and QR code image
func (h *AuthHandler) Setup2FA(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	// Generate TOTP secret
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      "INTERNA",
		AccountName: claims.Email,
	})
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate 2FA secret")
		return
	}

	// Generate the QR Code Image
	var buf bytes.Buffer
	img, err := key.Image(200, 200)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate QR image")
		return
	}

	err = png.Encode(&buf, img)
	if err != nil {
		utils.RespondInternalError(w, "Failed to encode QR image")
		return
	}

	qrCodeBase64 := "data:image/png;base64," + base64.StdEncoding.EncodeToString(buf.Bytes())

	// Save secret to database
	res, err := h.db.Exec(
		"UPDATE users SET totp_secret = ? WHERE id = ?",
		key.Secret(), claims.UserID,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to save 2FA secret")
		return
	}

	// CHECK ROWS AFFECTED
	rows, _ := res.RowsAffected()
	if rows == 0 {
		utils.RespondInternalError(w, "Failed to initialize 2FA: User not found")
		return
	}

	utils.RespondSuccess(w, "2FA setup initiated. Scan the QR code with Google Authenticator", Setup2FAResponse{
		Secret: key.Secret(),
		QRCode: qrCodeBase64,
	})
}

// Verify2FA verifies and enables 2FA
func (h *AuthHandler) Verify2FA(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	var req Verify2FARequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// 1. Get the secret from the DB (Verify persistence)
	var secret sql.NullString
	err := h.db.QueryRow("SELECT totp_secret FROM users WHERE id = ?", claims.UserID).Scan(&secret)
	if err != nil {
		utils.RespondInternalError(w, "User not found")
		return
	}

	if !secret.Valid || secret.String == "" {
		// CRITICAL: This means Setup2FA didn't save the secret!
		utils.RespondBadRequest(w, "2FA Setup not initialized. Please try generating the QR code again.")
		return
	}

	// 2. Verify code
	valid := totp.Validate(req.Code, secret.String)
	if !valid {
		utils.RespondBadRequest(w, "Invalid 2FA code")
		return
	}

	// 3. Enable 2FA (Strict Update)
	res, err := h.db.Exec("UPDATE users SET is_2fa_enabled = 1 WHERE id = ?", claims.UserID)
	if err != nil {
		utils.RespondInternalError(w, "Database error enabling 2FA")
		return
	}

	// 4. CHECK ROWS AFFECTED (The Fix)
	rows, err := res.RowsAffected()
	if err != nil {
		utils.RespondInternalError(w, "Failed to verify database update")
		return
	}

	if rows == 0 {
		// If we are here, it means the Update found NO matching user to update.
		// This usually means claims.UserID is wrong or the user was deleted.
		utils.RespondInternalError(w, "Failed to enable 2FA: User record could not be updated")
		return
	}

	utils.RespondSuccess(w, "2FA enabled successfully", nil)
}

// Disable2FA disables 2FA for user
func (h *AuthHandler) Disable2FA(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	_, err := h.db.Exec(
		"UPDATE users SET is_2fa_enabled = FALSE, totp_secret = NULL WHERE id = ?",
		claims.UserID,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to disable 2FA")
		return
	}

	utils.RespondSuccess(w, "2FA disabled successfully", nil)
}

// GetCurrentUser returns current user information
// GetCurrentUser returns current user information
func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	// DISABLE CACHING: Force browser to ask server every time
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
	w.Header().Set("Pragma", "no-cache")
	w.Header().Set("Expires", "0")

	var user models.User
	err := h.db.QueryRow(
		"SELECT id, name, email, role, avatar, is_2fa_enabled, created_at FROM users WHERE id = ?",
		claims.UserID,
	).Scan(&user.ID, &user.Name, &user.Email, &user.Role, &user.Avatar, &user.Is2FAEnabled, &user.CreatedAt)

	if err != nil {
		utils.RespondNotFound(w, "User not found")
		return
	}

	utils.RespondSuccess(w, "User retrieved successfully", toUserResponse(user))
}

// Logout handles logout (mainly client-side token removal)
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	// In a stateless JWT system, logout is mainly handled client-side
	// You could implement token blacklisting here if needed
	utils.RespondSuccess(w, "Logged out successfully", nil)
}

// generateToken creates a new JWT token
func (h *AuthHandler) generateToken(user *models.User) (string, error) {
	cfg := config.Loaded

	claims := middleware.Claims{
		UserID: user.ID,
		Email:  user.Email,
		Role:   user.Role,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(cfg.JWT.Expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(cfg.JWT.Secret))
}

func toUserResponse(user models.User) UserResponse {
	resp := UserResponse{
		ID:           user.ID,
		Email:        user.Email,
		Role:         user.Role,
		Is2FAEnabled: user.Is2FAEnabled,
		CreatedAt:    user.CreatedAt,
	}
	if user.Name.Valid {
		resp.Name = user.Name.String
	}
	if user.Avatar.Valid {
		resp.Avatar = user.Avatar.String
	}
	return resp
}
./internal/handlers/role.go
package handlers

// normalizeRole maps legacy "supervisor" to "pembimbing"
func normalizeRole(role string) string {
	if role == "supervisor" {
		return "pembimbing"
	}
	return role
}
./internal/handlers/report.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
	"github.com/phpdave11/gofpdf"
)

type ReportHandler struct {
	db *sql.DB
}

func NewReportHandler(db *sql.DB) *ReportHandler {
	return &ReportHandler{db: db}
}

type createReportRequest struct {
	InternID    int64  `json:"intern_id"`
	Title       string `json:"title"`
	Content     string `json:"content"`
	Type        string `json:"type"` // weekly, monthly, final
	PeriodStart string `json:"period_start"`
	PeriodEnd   string `json:"period_end"`
}

type updateReportRequest struct {
	Title       *string `json:"title,omitempty"`
	Content     *string `json:"content,omitempty"`
	Type        *string `json:"type,omitempty"`
	PeriodStart *string `json:"period_start,omitempty"`
	PeriodEnd   *string `json:"period_end,omitempty"`
	Status      *string `json:"status,omitempty"`
	Feedback    *string `json:"feedback,omitempty"`
}

func (h *ReportHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}
	offset := (page - 1) * limit

	filterType := strings.TrimSpace(r.URL.Query().Get("type"))
	filterStatus := strings.TrimSpace(r.URL.Query().Get("status"))
	filterIntern := strings.TrimSpace(r.URL.Query().Get("intern_id"))

	where := []string{}
	args := []interface{}{}

	role := normalizeRole(claims.Role)
	if role == "intern" {
		var internID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID); err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		where = append(where, "r.intern_id = ?")
		args = append(args, internID)
	} else if filterIntern != "" {
		if id, err := strconv.ParseInt(filterIntern, 10, 64); err == nil {
			where = append(where, "r.intern_id = ?")
			args = append(args, id)
		}
	}

	if filterType != "" {
		where = append(where, "r.type = ?")
		args = append(args, filterType)
	}
	if filterStatus != "" {
		where = append(where, "r.status = ?")
		args = append(args, filterStatus)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
		FROM reports r
		LEFT JOIN interns i ON r.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users cu ON r.created_by = cu.id
	`

	var total int64
	if err := h.db.QueryRow("SELECT COUNT(*) "+baseFrom+" "+whereClause, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count reports")
		return
	}

	query := `
		SELECT r.id, r.intern_id, r.created_by, r.title, r.content, r.type,
		       r.period_start, r.period_end, r.status, r.feedback, r.created_at, r.updated_at,
		       iu.name, cu.name
	` + baseFrom + " " + whereClause + " ORDER BY r.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)
	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch reports")
		return
	}
	defer rows.Close()

	var reports []models.Report
	for rows.Next() {
		var rep models.Report
		var feedback sql.NullString
		var internName, createdByName sql.NullString
		if err := rows.Scan(
			&rep.ID, &rep.InternID, &rep.CreatedBy, &rep.Title, &rep.Content, &rep.Type,
			&rep.PeriodStart, &rep.PeriodEnd, &rep.Status, &feedback, &rep.CreatedAt, &rep.UpdatedAt,
			&internName, &createdByName,
		); err == nil {
			if feedback.Valid {
				rep.Feedback = feedback.String
			}
			if internName.Valid {
				rep.InternName = internName.String
			}
			if createdByName.Valid {
				rep.CreatedByName = createdByName.String
			}
			reports = append(reports, rep)
		}
	}

	utils.RespondPaginated(w, reports, utils.CalculatePagination(page, limit, total))
}

func (h *ReportHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		SELECT r.id, r.intern_id, r.created_by, r.title, r.content, r.type,
		       r.period_start, r.period_end, r.status, r.feedback, r.created_at, r.updated_at,
		       iu.name, cu.name
		FROM reports r
		LEFT JOIN interns i ON r.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users cu ON r.created_by = cu.id
		WHERE r.id = ?
	`

	var rep models.Report
	var feedback sql.NullString
	var internName, createdByName sql.NullString
	err := h.db.QueryRow(query, id).Scan(
		&rep.ID, &rep.InternID, &rep.CreatedBy, &rep.Title, &rep.Content, &rep.Type,
		&rep.PeriodStart, &rep.PeriodEnd, &rep.Status, &feedback, &rep.CreatedAt, &rep.UpdatedAt,
		&internName, &createdByName,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Report not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != rep.InternID {
			utils.RespondForbidden(w, "You do not have access to this report")
			return
		}
	}

	if feedback.Valid {
		rep.Feedback = feedback.String
	}
	if internName.Valid {
		rep.InternName = internName.String
	}
	if createdByName.Valid {
		rep.CreatedByName = createdByName.String
	}

	utils.RespondSuccess(w, "Report retrieved", rep)
}

func (h *ReportHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can create reports")
		return
	}

	var req createReportRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if req.InternID == 0 || strings.TrimSpace(req.Title) == "" || strings.TrimSpace(req.Content) == "" || strings.TrimSpace(req.Type) == "" {
		utils.RespondBadRequest(w, "intern_id, title, content, and type are required")
		return
	}
	if req.Type != "weekly" && req.Type != "monthly" && req.Type != "final" {
		utils.RespondBadRequest(w, "Invalid report type")
		return
	}

	start, err := time.Parse("2006-01-02", req.PeriodStart)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid period_start")
		return
	}
	end, err := time.Parse("2006-01-02", req.PeriodEnd)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid period_end")
		return
	}

	_, err = h.db.Exec(
		`INSERT INTO reports (intern_id, created_by, title, content, type, period_start, period_end, status)
		 VALUES (?, ?, ?, ?, ?, ?, ?, 'submitted')`,
		req.InternID, claims.UserID, req.Title, req.Content, req.Type, start, end,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create report")
		return
	}

	utils.RespondCreated(w, "Report created", nil)
}

func (h *ReportHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update reports")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateReportRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	updates := []string{}
	args := []interface{}{}

	if req.Title != nil {
		updates = append(updates, "title = ?")
		args = append(args, *req.Title)
	}
	if req.Content != nil {
		updates = append(updates, "content = ?")
		args = append(args, *req.Content)
	}
	if req.Type != nil {
		updates = append(updates, "type = ?")
		args = append(args, *req.Type)
	}
	if req.PeriodStart != nil {
		if parsed, err := time.Parse("2006-01-02", *req.PeriodStart); err == nil {
			updates = append(updates, "period_start = ?")
			args = append(args, parsed)
		}
	}
	if req.PeriodEnd != nil {
		if parsed, err := time.Parse("2006-01-02", *req.PeriodEnd); err == nil {
			updates = append(updates, "period_end = ?")
			args = append(args, parsed)
		}
	}
	if req.Status != nil {
		updates = append(updates, "status = ?")
		args = append(args, *req.Status)
	}
	if req.Feedback != nil {
		updates = append(updates, "feedback = ?")
		args = append(args, nullIfEmpty(*req.Feedback))
	}

	if len(updates) == 0 {
		utils.RespondBadRequest(w, "No updates provided")
		return
	}

	args = append(args, id)
	if _, err := h.db.Exec("UPDATE reports SET "+strings.Join(updates, ", ")+" WHERE id = ?", args...); err != nil {
		utils.RespondInternalError(w, "Failed to update report")
		return
	}

	utils.RespondSuccess(w, "Report updated", nil)
}

func (h *ReportHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can delete reports")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	if _, err := h.db.Exec("DELETE FROM reports WHERE id = ?", id); err != nil {
		utils.RespondInternalError(w, "Failed to delete report")
		return
	}

	utils.RespondSuccess(w, "Report deleted", nil)
}

func (h *ReportHandler) AddFeedback(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can add feedback")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var payload struct {
		Feedback string `json:"feedback"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}
	if strings.TrimSpace(payload.Feedback) == "" {
		utils.RespondBadRequest(w, "Feedback is required")
		return
	}

	if _, err := h.db.Exec("UPDATE reports SET feedback = ?, status = 'reviewed' WHERE id = ?", payload.Feedback, id); err != nil {
		utils.RespondInternalError(w, "Failed to add feedback")
		return
	}

	utils.RespondSuccess(w, "Feedback added", nil)
}

// --- Aggregated Reports ---

func (h *ReportHandler) GetInternReport(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if normalizeRole(claims.Role) == "intern" {
		var myID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myID); err != nil || myID != internID {
			utils.RespondForbidden(w, "You do not have access to this report")
			return
		}
	}

	// Intern info
	var intern struct {
		ID        int64     `json:"id"`
		FullName  string    `json:"full_name"`
		Email     string    `json:"email"`
		StartDate time.Time `json:"start_date"`
		EndDate   time.Time `json:"end_date"`
	}
	if err := h.db.QueryRow(
		`SELECT i.id, i.full_name, u.email, i.start_date, i.end_date
		 FROM interns i JOIN users u ON i.user_id = u.id
		 WHERE i.id = ?`, internID,
	).Scan(&intern.ID, &intern.FullName, &intern.Email, &intern.StartDate, &intern.EndDate); err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	// Task stats
	var taskStats struct {
		Total           int64   `json:"total"`
		Completed       int64   `json:"completed"`
		InProgress      int64   `json:"in_progress"`
		Pending         int64   `json:"pending"`
		Revision        int64   `json:"revision"`
		CompletedOnTime int64   `json:"completed_on_time"`
		CompletedLate   int64   `json:"completed_late"`
		AverageScore    float64 `json:"average_score"`
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as total,
		        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
		        SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
		        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
		        SUM(CASE WHEN status = 'revision' THEN 1 ELSE 0 END) as revision,
		        SUM(CASE WHEN status = 'completed' AND is_late = 0 THEN 1 ELSE 0 END) as completed_on_time,
		        SUM(CASE WHEN status = 'completed' AND is_late = 1 THEN 1 ELSE 0 END) as completed_late,
		        AVG(CASE WHEN status = 'completed' THEN score ELSE NULL END) as average_score
		 FROM tasks WHERE intern_id = ?`, internID,
	).Scan(&taskStats.Total, &taskStats.Completed, &taskStats.InProgress, &taskStats.Pending, &taskStats.Revision,
		&taskStats.CompletedOnTime, &taskStats.CompletedLate, &taskStats.AverageScore)

	// Attendance stats
	var attendanceStats struct {
		Total      int64   `json:"total"`
		Present    int64   `json:"present"`
		Late       int64   `json:"late"`
		Absent     int64   `json:"absent"`
		Sick       int64   `json:"sick"`
		Permission int64   `json:"permission"`
		Percentage float64 `json:"percentage"`
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as total,
		        SUM(CASE WHEN status = 'present' THEN 1 ELSE 0 END) as present,
		        SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) as late,
		        SUM(CASE WHEN status = 'absent' THEN 1 ELSE 0 END) as absent,
		        SUM(CASE WHEN status = 'sick' THEN 1 ELSE 0 END) as sick,
		        SUM(CASE WHEN status = 'permission' THEN 1 ELSE 0 END) as permission
		 FROM attendances WHERE intern_id = ?`, internID,
	).Scan(&attendanceStats.Total, &attendanceStats.Present, &attendanceStats.Late, &attendanceStats.Absent, &attendanceStats.Sick, &attendanceStats.Permission)

	if attendanceStats.Total > 0 {
		attendanceStats.Percentage = float64(attendanceStats.Present+attendanceStats.Late) / float64(attendanceStats.Total) * 100
	}

	// Assessment stats
	var assessmentStats struct {
		Count         int64   `json:"count"`
		Quality       float64 `json:"quality"`
		Speed         float64 `json:"speed"`
		Initiative    float64 `json:"initiative"`
		Teamwork      float64 `json:"teamwork"`
		Communication float64 `json:"communication"`
		Overall       float64 `json:"overall"`
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as cnt,
		        AVG(quality_score), AVG(speed_score), AVG(initiative_score), AVG(teamwork_score), AVG(communication_score)
		 FROM assessments WHERE intern_id = ?`, internID,
	).Scan(&assessmentStats.Count, &assessmentStats.Quality, &assessmentStats.Speed, &assessmentStats.Initiative, &assessmentStats.Teamwork, &assessmentStats.Communication)

	if assessmentStats.Count > 0 {
		assessmentStats.Overall = (assessmentStats.Quality + assessmentStats.Speed + assessmentStats.Initiative + assessmentStats.Teamwork + assessmentStats.Communication) / 5
	}

	// Recent tasks
	type miniTask struct {
		ID     int64  `json:"id"`
		Title  string `json:"title"`
		Status string `json:"status"`
	}
	var recentTasks []miniTask
	rows, _ := h.db.Query(
		`SELECT id, title, status FROM tasks WHERE intern_id = ? ORDER BY created_at DESC LIMIT 10`,
		internID,
	)
	for rows != nil && rows.Next() {
		var t miniTask
		if err := rows.Scan(&t.ID, &t.Title, &t.Status); err == nil {
			recentTasks = append(recentTasks, t)
		}
	}
	if rows != nil {
		rows.Close()
	}

	// Recent attendances
	type miniAttendance struct {
		ID     int64     `json:"id"`
		Date   time.Time `json:"date"`
		Status string    `json:"status"`
	}
	var recentAttendances []miniAttendance
	rows, _ = h.db.Query(
		`SELECT id, date, status FROM attendances WHERE intern_id = ? ORDER BY date DESC LIMIT 10`,
		internID,
	)
	for rows != nil && rows.Next() {
		var a miniAttendance
		if err := rows.Scan(&a.ID, &a.Date, &a.Status); err == nil {
			recentAttendances = append(recentAttendances, a)
		}
	}
	if rows != nil {
		rows.Close()
	}

	// Progress
	durationDays := int(intern.EndDate.Sub(intern.StartDate).Hours() / 24)
	if durationDays < 1 {
		durationDays = 1
	}
	daysCompleted := int(time.Since(intern.StartDate).Hours() / 24)
	if daysCompleted < 0 {
		daysCompleted = 0
	}
	progress := float64(daysCompleted) / float64(durationDays) * 100
	if progress > 100 {
		progress = 100
	}

	utils.RespondSuccess(w, "Intern report retrieved", map[string]interface{}{
		"intern":             intern,
		"task_stats":         taskStats,
		"attendance_stats":   attendanceStats,
		"assessment_stats":   assessmentStats,
		"recent_tasks":       recentTasks,
		"recent_attendances": recentAttendances,
		"duration_days":      durationDays,
		"days_completed":     daysCompleted,
		"progress":           progress,
	})
}

func (h *ReportHandler) GetAttendanceReport(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var stats struct {
		Total      int64 `json:"total"`
		Present    int64 `json:"present"`
		Late       int64 `json:"late"`
		Absent     int64 `json:"absent"`
		Sick       int64 `json:"sick"`
		Permission int64 `json:"permission"`
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as total,
		        SUM(CASE WHEN status = 'present' THEN 1 ELSE 0 END) as present,
		        SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) as late,
		        SUM(CASE WHEN status = 'absent' THEN 1 ELSE 0 END) as absent,
		        SUM(CASE WHEN status = 'sick' THEN 1 ELSE 0 END) as sick,
		        SUM(CASE WHEN status = 'permission' THEN 1 ELSE 0 END) as permission
		 FROM attendances WHERE intern_id = ?`, internID,
	).Scan(&stats.Total, &stats.Present, &stats.Late, &stats.Absent, &stats.Sick, &stats.Permission)

	utils.RespondSuccess(w, "Attendance report retrieved", stats)
}

func (h *ReportHandler) GetAssessmentReport(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var avgScore sql.NullFloat64
	_ = h.db.QueryRow("SELECT AVG(score) FROM assessments WHERE intern_id = ?", internID).Scan(&avgScore)

	// Category distribution
	rows, err := h.db.Query("SELECT category, COUNT(*) FROM assessments WHERE intern_id = ? GROUP BY category", internID)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch assessment report")
		return
	}
	defer rows.Close()

	dist := map[string]int64{}
	for rows.Next() {
		var category string
		var count int64
		if err := rows.Scan(&category, &count); err == nil {
			dist[category] = count
		}
	}

	utils.RespondSuccess(w, "Assessment report retrieved", map[string]interface{}{
		"average_score": avgScore.Float64,
		"distribution":  dist,
	})
}

func (h *ReportHandler) GetCertificate(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var cert struct {
		ID                int64           `json:"id"`
		InternID          int64           `json:"intern_id"`
		CertificateNumber string          `json:"certificate_number"`
		IssueDate         time.Time       `json:"issue_date"`
		FinalScore        sql.NullFloat64 `json:"final_score"`
		Remarks           sql.NullString  `json:"remarks"`
		FilePath          sql.NullString  `json:"file_path"`
	}
	err := h.db.QueryRow(
		`SELECT id, intern_id, certificate_number, issue_date, final_score, remarks, file_path
		 FROM certificates WHERE intern_id = ?`, internID,
	).Scan(&cert.ID, &cert.InternID, &cert.CertificateNumber, &cert.IssueDate, &cert.FinalScore, &cert.Remarks, &cert.FilePath)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Certificate not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	utils.RespondSuccess(w, "Certificate retrieved", cert)
}

func (h *ReportHandler) GenerateCertificate(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	// Calculate final score
	var avgScore sql.NullFloat64
	_ = h.db.QueryRow("SELECT AVG(score) FROM assessments WHERE intern_id = ?", internID).Scan(&avgScore)

	certNumber := "CERT-" + strconv.FormatInt(internID, 10) + "-" + time.Now().Format("20060102")

	_, err := h.db.Exec(
		`INSERT INTO certificates (intern_id, certificate_number, issue_date, final_score)
		 VALUES (?, ?, ?, ?)`,
		internID, certNumber, time.Now(), avgScore,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to generate certificate")
		return
	}

	utils.RespondCreated(w, "Certificate generated", map[string]interface{}{
		"certificate_number": certNumber,
		"final_score":        avgScore.Float64,
	})
}

// DownloadInternReport generates a simple PDF report for an intern
func (h *ReportHandler) DownloadInternReport(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if normalizeRole(claims.Role) == "intern" {
		var myID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myID); err != nil || myID != internID {
			utils.RespondForbidden(w, "You do not have access to this report")
			return
		}
	}

	// Intern info
	var intern struct {
		ID        int64
		FullName  string
		Email     string
		StartDate time.Time
		EndDate   time.Time
	}
	if err := h.db.QueryRow(
		`SELECT i.id, i.full_name, u.email, i.start_date, i.end_date
		 FROM interns i JOIN users u ON i.user_id = u.id
		 WHERE i.id = ?`, internID,
	).Scan(&intern.ID, &intern.FullName, &intern.Email, &intern.StartDate, &intern.EndDate); err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	// Task stats
	var taskStats struct {
		Total           int64
		Completed       int64
		InProgress      int64
		Pending         int64
		Revision        int64
		CompletedOnTime int64
		CompletedLate   int64
		AverageScore    float64
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as total,
		        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
		        SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
		        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
		        SUM(CASE WHEN status = 'revision' THEN 1 ELSE 0 END) as revision,
		        SUM(CASE WHEN status = 'completed' AND is_late = 0 THEN 1 ELSE 0 END) as completed_on_time,
		        SUM(CASE WHEN status = 'completed' AND is_late = 1 THEN 1 ELSE 0 END) as completed_late,
		        AVG(CASE WHEN status = 'completed' THEN score ELSE NULL END) as average_score
		 FROM tasks WHERE intern_id = ?`, internID,
	).Scan(&taskStats.Total, &taskStats.Completed, &taskStats.InProgress, &taskStats.Pending, &taskStats.Revision,
		&taskStats.CompletedOnTime, &taskStats.CompletedLate, &taskStats.AverageScore)

	// Attendance stats
	var attendanceStats struct {
		Total      int64
		Present    int64
		Late       int64
		Absent     int64
		Sick       int64
		Permission int64
		Percentage float64
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as total,
		        SUM(CASE WHEN status = 'present' THEN 1 ELSE 0 END) as present,
		        SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) as late,
		        SUM(CASE WHEN status = 'absent' THEN 1 ELSE 0 END) as absent,
		        SUM(CASE WHEN status = 'sick' THEN 1 ELSE 0 END) as sick,
		        SUM(CASE WHEN status = 'permission' THEN 1 ELSE 0 END) as permission
		 FROM attendances WHERE intern_id = ?`, internID,
	).Scan(&attendanceStats.Total, &attendanceStats.Present, &attendanceStats.Late, &attendanceStats.Absent, &attendanceStats.Sick, &attendanceStats.Permission)

	if attendanceStats.Total > 0 {
		attendanceStats.Percentage = float64(attendanceStats.Present+attendanceStats.Late) / float64(attendanceStats.Total) * 100
	}

	// Assessment stats
	var assessmentStats struct {
		Count         int64
		Quality       float64
		Speed         float64
		Initiative    float64
		Teamwork      float64
		Communication float64
		Overall       float64
	}
	_ = h.db.QueryRow(
		`SELECT COUNT(*) as cnt,
		        AVG(quality_score), AVG(speed_score), AVG(initiative_score), AVG(teamwork_score), AVG(communication_score)
		 FROM assessments WHERE intern_id = ?`, internID,
	).Scan(&assessmentStats.Count, &assessmentStats.Quality, &assessmentStats.Speed, &assessmentStats.Initiative, &assessmentStats.Teamwork, &assessmentStats.Communication)

	if assessmentStats.Count > 0 {
		assessmentStats.Overall = (assessmentStats.Quality + assessmentStats.Speed + assessmentStats.Initiative + assessmentStats.Teamwork + assessmentStats.Communication) / 5
	}

	durationDays := int(intern.EndDate.Sub(intern.StartDate).Hours() / 24)
	if durationDays < 1 {
		durationDays = 1
	}
	daysCompleted := int(time.Since(intern.StartDate).Hours() / 24)
	if daysCompleted < 0 {
		daysCompleted = 0
	}
	progress := float64(daysCompleted) / float64(durationDays) * 100
	if progress > 100 {
		progress = 100
	}

	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Helvetica", "B", 16)
	pdf.Cell(0, 10, "Laporan Intern")
	pdf.Ln(8)

	pdf.SetFont("Helvetica", "", 11)
	pdf.Cell(0, 6, fmt.Sprintf("Nama: %s", intern.FullName))
	pdf.Ln(5)
	pdf.Cell(0, 6, fmt.Sprintf("Email: %s", intern.Email))
	pdf.Ln(5)
	pdf.Cell(0, 6, fmt.Sprintf("Periode: %s - %s", intern.StartDate.Format("02/01/2006"), intern.EndDate.Format("02/01/2006")))
	pdf.Ln(6)

	pdf.SetFont("Helvetica", "B", 12)
	pdf.Cell(0, 7, "Ringkasan Tugas")
	pdf.Ln(6)
	pdf.SetFont("Helvetica", "", 10)
	pdf.Cell(0, 5, fmt.Sprintf("Total: %d | Selesai: %d | Dalam Proses: %d | Pending: %d | Revisi: %d", taskStats.Total, taskStats.Completed, taskStats.InProgress, taskStats.Pending, taskStats.Revision))
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Tepat Waktu: %d | Terlambat: %d | Rata-rata Nilai: %.1f", taskStats.CompletedOnTime, taskStats.CompletedLate, taskStats.AverageScore))
	pdf.Ln(7)

	pdf.SetFont("Helvetica", "B", 12)
	pdf.Cell(0, 7, "Ringkasan Presensi")
	pdf.Ln(6)
	pdf.SetFont("Helvetica", "", 10)
	pdf.Cell(0, 5, fmt.Sprintf("Total: %d | Hadir: %d | Terlambat: %d | Tidak Hadir: %d | Sakit: %d | Izin: %d", attendanceStats.Total, attendanceStats.Present, attendanceStats.Late, attendanceStats.Absent, attendanceStats.Sick, attendanceStats.Permission))
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Kehadiran: %.1f%%", attendanceStats.Percentage))
	pdf.Ln(7)

	pdf.SetFont("Helvetica", "B", 12)
	pdf.Cell(0, 7, "Ringkasan Penilaian")
	pdf.Ln(6)
	pdf.SetFont("Helvetica", "", 10)
	pdf.Cell(0, 5, fmt.Sprintf("Kualitas: %.1f | Kecepatan: %.1f | Inisiatif: %.1f | Kerjasama: %.1f | Komunikasi: %.1f", assessmentStats.Quality, assessmentStats.Speed, assessmentStats.Initiative, assessmentStats.Teamwork, assessmentStats.Communication))
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Skor Keseluruhan: %.1f", assessmentStats.Overall))
	pdf.Ln(7)

	pdf.SetFont("Helvetica", "B", 12)
	pdf.Cell(0, 7, "Progress Magang")
	pdf.Ln(6)
	pdf.SetFont("Helvetica", "", 10)
	pdf.Cell(0, 5, fmt.Sprintf("Durasi: %d hari | Hari berjalan: %d | Progress: %.1f%%", durationDays, daysCompleted, progress))

	filename := fmt.Sprintf("Laporan_%s_%s.pdf", sanitizeFilename(intern.FullName), time.Now().Format("2006-01-02"))
	w.Header().Set("Content-Type", "application/pdf")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
	if err := pdf.Output(w); err != nil {
		utils.RespondInternalError(w, "Failed to generate PDF")
		return
	}
}

// DownloadCertificate generates a simple internship certificate PDF
func (h *ReportHandler) DownloadCertificate(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var intern struct {
		ID                  int64
		FullName            string
		Status              string
		CertificateNumber   sql.NullString
		CertificateIssuedAt sql.NullTime
	}
	if err := h.db.QueryRow(
		`SELECT id, full_name, status, certificate_number, certificate_issued_at
		 FROM interns WHERE id = ?`, internID,
	).Scan(&intern.ID, &intern.FullName, &intern.Status, &intern.CertificateNumber, &intern.CertificateIssuedAt); err != nil {
		utils.RespondNotFound(w, "Intern not found")
		return
	}

	if intern.Status != "completed" {
		utils.RespondBadRequest(w, "Certificate is only available for completed interns")
		return
	}

	// Fetch or generate certificate record
	var certNumber string
	var issueDate time.Time
	var finalScore sql.NullFloat64
	err := h.db.QueryRow(
		`SELECT certificate_number, issue_date, final_score FROM certificates WHERE intern_id = ?`,
		internID,
	).Scan(&certNumber, &issueDate, &finalScore)
	if err == sql.ErrNoRows {
		year := time.Now().Format("2006")
		certNumber = fmt.Sprintf("MG-DSI/%s/%04d", year, internID)
		issueDate = time.Now()
		_ = h.db.QueryRow("SELECT AVG(score) FROM assessments WHERE intern_id = ?", internID).Scan(&finalScore)

		if _, err := h.db.Exec(
			`INSERT INTO certificates (intern_id, certificate_number, issue_date, final_score)
			 VALUES (?, ?, ?, ?)`, internID, certNumber, issueDate, finalScore,
		); err != nil {
			utils.RespondInternalError(w, "Failed to generate certificate")
			return
		}

		_, _ = h.db.Exec(
			`UPDATE interns SET certificate_number = ?, certificate_issued_at = ? WHERE id = ?`,
			certNumber, issueDate, internID,
		)
	} else if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if !intern.CertificateNumber.Valid {
		intern.CertificateNumber = sql.NullString{String: certNumber, Valid: true}
		intern.CertificateIssuedAt = sql.NullTime{Time: issueDate, Valid: true}
	}

	pdf := gofpdf.New("L", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Helvetica", "B", 26)
	pdf.Cell(0, 20, "Sertifikat Magang")
	pdf.Ln(14)

	pdf.SetFont("Helvetica", "", 14)
	pdf.Cell(0, 10, "Diberikan kepada:")
	pdf.Ln(10)
	pdf.SetFont("Helvetica", "B", 22)
	pdf.Cell(0, 14, intern.FullName)
	pdf.Ln(12)

	pdf.SetFont("Helvetica", "", 12)
	pdf.Cell(0, 8, fmt.Sprintf("Nomor Sertifikat: %s", certNumber))
	pdf.Ln(6)
	if intern.CertificateIssuedAt.Valid {
		pdf.Cell(0, 8, fmt.Sprintf("Tanggal: %s", intern.CertificateIssuedAt.Time.Format("02/01/2006")))
	}
	pdf.Ln(10)

	pdf.SetFont("Helvetica", "", 11)
	if finalScore.Valid {
		pdf.Cell(0, 6, fmt.Sprintf("Nilai Akhir: %.1f", finalScore.Float64))
	}

	filename := fmt.Sprintf("Sertifikat_%s_%s.pdf", sanitizeFilename(intern.FullName), time.Now().Format("2006-01-02"))
	w.Header().Set("Content-Type", "application/pdf")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
	if err := pdf.Output(w); err != nil {
		utils.RespondInternalError(w, "Failed to generate PDF")
		return
	}
}

func sanitizeFilename(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return "file"
	}
	return strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' {
			return r
		}
		if r == ' ' {
			return '_'
		}
		return '_'
	}, value)
}
./internal/handlers/export_import.go
package handlers

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"mime/multipart"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/utils"

	"github.com/xuri/excelize/v2"
	"golang.org/x/crypto/bcrypt"
)

type ExportImportHandler struct {
	db *sql.DB
}

func NewExportImportHandler(db *sql.DB) *ExportImportHandler {
	return &ExportImportHandler{db: db}
}

func (h *ExportImportHandler) ExportInterns(w http.ResponseWriter, r *http.Request) {
	status := strings.TrimSpace(r.URL.Query().Get("status"))

	where := ""
	args := []interface{}{}
	if status != "" {
		where = "WHERE i.status = ?"
		args = append(args, status)
	}

	query := `
		SELECT i.id, i.full_name, u.email, i.nis, i.school, i.department, i.phone, i.address,
		       su.name as supervisor_name, i.start_date, i.end_date, i.status,
		       (SELECT COUNT(*) FROM tasks t WHERE t.intern_id = i.id) as total_tasks,
		       (SELECT COUNT(*) FROM tasks t WHERE t.intern_id = i.id AND t.status = 'completed') as completed_tasks,
		       (SELECT COUNT(*) FROM attendances a WHERE a.intern_id = i.id) as total_attendance,
		       (SELECT COUNT(*) FROM attendances a WHERE a.intern_id = i.id AND a.status IN ('present','late')) as present_attendance,
		       (SELECT AVG(score) FROM tasks t WHERE t.intern_id = i.id AND t.status = 'completed' AND t.score IS NOT NULL) as avg_score
		FROM interns i
		JOIN users u ON i.user_id = u.id
		LEFT JOIN users su ON i.supervisor_id = su.id
	` + where + ` ORDER BY i.created_at DESC`

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to export interns")
		return
	}
	defer rows.Close()

	headers := []string{
		"ID", "Nama", "Email", "NIS", "Sekolah", "Jurusan", "No. Telepon", "Alamat", "Pembimbing",
		"Tanggal Mulai", "Tanggal Selesai", "Status", "Total Tugas", "Tugas Selesai", "Tingkat Kehadiran (%)", "Skor Rata-rata",
	}

	var data [][]string
	for rows.Next() {
		var (
			id                          int64
			fullName, email             string
			nis, school, department     sql.NullString
			phone, address              sql.NullString
			supervisorName              sql.NullString
			startDate, endDate          sql.NullTime
			rowStatus                   string
			totalTasks, completedTasks  int64
			totalAttendance, presentAtt int64
			avgScore                    sql.NullFloat64
		)
		if err := rows.Scan(
			&id, &fullName, &email, &nis, &school, &department, &phone, &address,
			&supervisorName, &startDate, &endDate, &rowStatus,
			&totalTasks, &completedTasks, &totalAttendance, &presentAtt, &avgScore,
		); err != nil {
			continue
		}

		attendanceRate := 0.0
		if totalAttendance > 0 {
			attendanceRate = (float64(presentAtt) / float64(totalAttendance)) * 100
		}

		data = append(data, []string{
			strconv.FormatInt(id, 10),
			fullName,
			email,
			valueOrDash(nis),
			valueOrDash(school),
			valueOrDash(department),
			valueOrDash(phone),
			valueOrDash(address),
			valueOrDash(supervisorName),
			formatDate(startDate),
			formatDate(endDate),
			internStatusLabel(rowStatus),
			strconv.FormatInt(totalTasks, 10),
			strconv.FormatInt(completedTasks, 10),
			fmt.Sprintf("%.1f", attendanceRate),
			formatFloat(avgScore),
		})
	}

	filename := fmt.Sprintf("Data_Peserta_Magang_%s.xlsx", time.Now().Format("2006-01-02_150405"))
	if err := writeExcel(w, filename, headers, data); err != nil {
		utils.RespondInternalError(w, "Failed to generate export")
		return
	}
}

func (h *ExportImportHandler) ExportAttendances(w http.ResponseWriter, r *http.Request) {
	internID := strings.TrimSpace(r.URL.Query().Get("intern_id"))
	startDate := strings.TrimSpace(r.URL.Query().Get("start_date"))
	endDate := strings.TrimSpace(r.URL.Query().Get("end_date"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))

	where := []string{}
	args := []interface{}{}
	if internID != "" {
		where = append(where, "a.intern_id = ?")
		args = append(args, internID)
	}
	if startDate != "" {
		where = append(where, "a.date >= ?")
		args = append(args, startDate)
	}
	if endDate != "" {
		where = append(where, "a.date <= ?")
		args = append(args, endDate)
	}
	if status != "" {
		where = append(where, "a.status = ?")
		args = append(args, status)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	query := `
		SELECT a.id, i.full_name, i.nis, a.date, a.check_in_time, a.check_out_time,
		       a.status, a.late_reason, a.notes, a.distance_meters
		FROM attendances a
		JOIN interns i ON a.intern_id = i.id
	` + whereClause + ` ORDER BY a.date DESC`

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to export attendances")
		return
	}
	defer rows.Close()

	headers := []string{
		"ID", "Nama Siswa", "NIS", "Tanggal", "Hari", "Jam Masuk", "Jam Pulang", "Status", "Alasan Terlambat", "Catatan", "Jarak (meter)",
	}

	var data [][]string
	for rows.Next() {
		var (
			id         int64
			name       string
			nis        sql.NullString
			date       time.Time
			checkIn    sql.NullTime
			checkOut   sql.NullTime
			rowStatus  string
			lateReason sql.NullString
			notes      sql.NullString
			distance   sql.NullInt64
		)
		if err := rows.Scan(&id, &name, &nis, &date, &checkIn, &checkOut, &rowStatus, &lateReason, &notes, &distance); err != nil {
			continue
		}

		data = append(data, []string{
			strconv.FormatInt(id, 10),
			name,
			valueOrDash(nis),
			date.Format("02/01/2006"),
			dayNameID(date.Weekday()),
			formatTime(checkIn),
			formatTime(checkOut),
			attendanceStatusLabel(rowStatus),
			valueOrDash(lateReason),
			valueOrDash(notes),
			formatInt64(distance),
		})
	}

	filename := fmt.Sprintf("Data_Presensi_%s.xlsx", time.Now().Format("2006-01-02_150405"))
	if err := writeExcel(w, filename, headers, data); err != nil {
		utils.RespondInternalError(w, "Failed to generate export")
		return
	}
}

func (h *ExportImportHandler) ExportTasks(w http.ResponseWriter, r *http.Request) {
	internID := strings.TrimSpace(r.URL.Query().Get("intern_id"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))

	where := []string{}
	args := []interface{}{}
	if internID != "" {
		where = append(where, "t.intern_id = ?")
		args = append(args, internID)
	}
	if status != "" {
		where = append(where, "t.status = ?")
		args = append(args, status)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	query := `
		SELECT t.id, t.title, t.description, i.full_name, t.priority, t.status, t.deadline,
		       t.submitted_at, t.completed_at, t.is_late, t.score, t.admin_feedback, u.name, t.created_at
		FROM tasks t
		LEFT JOIN interns i ON t.intern_id = i.id
		LEFT JOIN users u ON t.assigned_by = u.id
	` + whereClause + ` ORDER BY t.created_at DESC`

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to export tasks")
		return
	}
	defer rows.Close()

	headers := []string{
		"ID", "Judul", "Deskripsi", "Nama Siswa", "Prioritas", "Status", "Deadline", "Tanggal Submit",
		"Tanggal Selesai", "Tepat Waktu", "Nilai", "Feedback", "Dibuat Oleh", "Dibuat Pada",
	}

	var data [][]string
	for rows.Next() {
		var (
			id          int64
			title       string
			description sql.NullString
			internName  sql.NullString
			priority    string
			rowStatus   string
			deadline    sql.NullTime
			submittedAt sql.NullTime
			completedAt sql.NullTime
			isLate      bool
			score       sql.NullInt64
			feedback    sql.NullString
			assignedBy  sql.NullString
			createdAt   time.Time
		)
		if err := rows.Scan(&id, &title, &description, &internName, &priority, &rowStatus, &deadline, &submittedAt, &completedAt, &isLate, &score, &feedback, &assignedBy, &createdAt); err != nil {
			continue
		}

		ontime := "-"
		if rowStatus == "completed" {
			if isLate {
				ontime = "Terlambat"
			} else {
				ontime = "Tepat Waktu"
			}
		}

		data = append(data, []string{
			strconv.FormatInt(id, 10),
			title,
			valueOrDash(description),
			valueOrDash(internName),
			priorityLabel(priority),
			taskStatusLabel(rowStatus),
			formatDate(deadline),
			formatDateTime(submittedAt),
			formatDateTime(completedAt),
			ontime,
			formatInt64(score),
			valueOrDash(feedback),
			valueOrDash(assignedBy),
			createdAt.Format("02/01/2006 15:04"),
		})
	}

	filename := fmt.Sprintf("Data_Tugas_%s.xlsx", time.Now().Format("2006-01-02_150405"))
	if err := writeExcel(w, filename, headers, data); err != nil {
		utils.RespondInternalError(w, "Failed to generate export")
		return
	}
}

func (h *ExportImportHandler) DownloadTemplate(w http.ResponseWriter, r *http.Request) {
	headers := []string{"ID", "Nama", "Email", "NIS", "Sekolah", "Jurusan", "No. Telepon", "Alamat", "Pembimbing", "Tanggal Mulai", "Tanggal Selesai", "Status"}
	example := []string{"1", "Sabil Murti", "isabilmurti@gmail.com", "1234", "SMK N 9 Semarang", "PPLG", "0882003427575", "Jl. Bukit Cemara Permai IV, No. DN-28, Meteseh, Tembalang.", "Budi Santoso", "05/01/2026", "05/04/2026", "Aktif"}

	filename := "Template_Import_Peserta_Magang.xlsx"
	if err := writeExcel(w, filename, headers, [][]string{example}); err != nil {
		utils.RespondInternalError(w, "Failed to generate template")
		return
	}
}

func (h *ExportImportHandler) ImportInterns(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(10 << 20); err != nil {
		utils.RespondBadRequest(w, "Failed to parse form data")
		return
	}

	file, header, err := r.FormFile("file")
	if err != nil {
		utils.RespondBadRequest(w, "Missing file")
		return
	}
	defer file.Close()

	supervisorID := int64(0)
	if raw := r.FormValue("supervisor_id"); raw != "" {
		if parsed, err := strconv.ParseInt(raw, 10, 64); err == nil {
			supervisorID = parsed
		}
	}

	ext := strings.ToLower(filepath.Ext(header.Filename))
	rows, err := readRows(file, ext)
	if err != nil {
		utils.RespondBadRequest(w, "Failed to read file")
		return
	}
	if len(rows) == 0 {
		utils.RespondBadRequest(w, "File is empty")
		return
	}

	startIdx := 0
	if isHeaderRow(rows[0]) {
		startIdx = 1
	}

	imported := 0
	skipped := 0
	errors := []string{}

	for i := startIdx; i < len(rows); i++ {
		row := rows[i]
		name := cell(row, 1)
		email := cell(row, 2)
		if name == "" || email == "" {
			skipped++
			continue
		}

		var exists int
		_ = h.db.QueryRow("SELECT COUNT(*) FROM users WHERE email = ?", email).Scan(&exists)
		if exists > 0 {
			skipped++
			continue
		}

		resolvedSupervisorID := supervisorID
		if resolvedSupervisorID == 0 {
			supervisorName := cell(row, 8)
			if supervisorName != "" {
				_ = h.db.QueryRow(
					"SELECT id FROM users WHERE name LIKE ? AND role IN ('admin','pembimbing','supervisor') LIMIT 1",
					"%"+supervisorName+"%",
				).Scan(&resolvedSupervisorID)
			}
		}

		status := mapInternStatus(cell(row, 11))
		startDate, okStart := parseFlexibleDate(cell(row, 9))
		endDate, okEnd := parseFlexibleDate(cell(row, 10))
		if !okStart || !okEnd {
			errors = append(errors, fmt.Sprintf("Row %d: invalid start/end date", i+1))
			skipped++
			continue
		}

		password := "password123"
		if pwd := cell(row, 12); pwd != "" {
			password = pwd
		}

		hashed, err := hashPassword(password)
		if err != nil {
			errors = append(errors, fmt.Sprintf("Row %d: failed to hash password", i+1))
			skipped++
			continue
		}

		tx, err := h.db.Begin()
		if err != nil {
			errors = append(errors, fmt.Sprintf("Row %d: failed to start transaction", i+1))
			skipped++
			continue
		}

		res, err := tx.Exec(
			"INSERT INTO users (name, email, password_hash, role) VALUES (?, ?, ?, 'intern')",
			name, email, hashed,
		)
		if err != nil {
			tx.Rollback()
			errors = append(errors, fmt.Sprintf("Row %d: failed to create user", i+1))
			skipped++
			continue
		}
		userID, _ := res.LastInsertId()

		_, err = tx.Exec(
			`INSERT INTO interns (user_id, supervisor_id, full_name, nis, school, department, phone, address, start_date, end_date, status)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			userID,
			nullInt64(resolvedSupervisorID),
			name,
			cell(row, 3),
			cell(row, 4),
			cell(row, 5),
			cell(row, 6),
			cell(row, 7),
			startDate,
			endDate,
			status,
		)
		if err != nil {
			tx.Rollback()
			errors = append(errors, fmt.Sprintf("Row %d: failed to create intern", i+1))
			skipped++
			continue
		}

		if err := tx.Commit(); err != nil {
			errors = append(errors, fmt.Sprintf("Row %d: failed to commit", i+1))
			skipped++
			continue
		}

		imported++
	}

	payload := map[string]interface{}{
		"imported": imported,
		"skipped":  skipped,
	}
	if len(errors) > 0 {
		payload["errors"] = errors
	}

	utils.RespondSuccess(w, "Import completed", payload)
}

// Helpers

func writeExcel(w http.ResponseWriter, filename string, headers []string, rows [][]string) error {
	file := excelize.NewFile()
	sheet := file.GetSheetName(0)

	for i, header := range headers {
		cell, _ := excelize.CoordinatesToCellName(i+1, 1)
		file.SetCellValue(sheet, cell, header)
	}

	for rIdx, row := range rows {
		for cIdx, value := range row {
			cell, _ := excelize.CoordinatesToCellName(cIdx+1, rIdx+2)
			file.SetCellValue(sheet, cell, value)
		}
	}

	style, _ := file.NewStyle(&excelize.Style{
		Font: &excelize.Font{Bold: true, Color: "FFFFFF"},
		Fill: excelize.Fill{Type: "pattern", Pattern: 1, Color: []string{"4B5563"}},
	})
	endCell, _ := excelize.CoordinatesToCellName(len(headers), 1)
	file.SetCellStyle(sheet, "A1", endCell, style)

	buf, err := file.WriteToBuffer()
	if err != nil {
		return err
	}

	w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
	_, err = w.Write(buf.Bytes())
	return err
}

func readRows(file multipart.File, ext string) ([][]string, error) {
	switch ext {
	case ".csv":
		reader := csv.NewReader(file)
		reader.FieldsPerRecord = -1
		return reader.ReadAll()
	case ".xlsx", ".xls":
		f, err := excelize.OpenReader(file)
		if err != nil {
			return nil, err
		}
		defer f.Close()
		sheet := f.GetSheetName(0)
		return f.GetRows(sheet)
	default:
		return nil, fmt.Errorf("unsupported file type")
	}
}

func isHeaderRow(row []string) bool {
	if len(row) == 0 {
		return false
	}
	joined := strings.ToLower(strings.Join(row, " "))
	return strings.Contains(joined, "nama") && strings.Contains(joined, "email")
}

func cell(row []string, idx int) string {
	if idx >= len(row) {
		return ""
	}
	return strings.TrimSpace(row[idx])
}

func parseFlexibleDate(value string) (time.Time, bool) {
	value = strings.TrimSpace(value)
	if value == "" {
		return time.Time{}, false
	}

	if num, err := strconv.ParseFloat(value, 64); err == nil {
		if t, err := excelize.ExcelDateToTime(num, false); err == nil {
			return t, true
		}
	}

	value = strings.ReplaceAll(value, "-", "/")
	layouts := []string{"02/01/2006", "2/1/2006", "2006/01/02", "2006-01-02"}
	for _, layout := range layouts {
		if t, err := time.Parse(layout, value); err == nil {
			return t, true
		}
	}

	if t, err := time.Parse(time.RFC3339, value); err == nil {
		return t, true
	}
	return time.Time{}, false
}

func internStatusLabel(status string) string {
	switch status {
	case "active":
		return "Aktif"
	case "completed":
		return "Selesai"
	case "cancelled":
		return "Dibatalkan"
	case "pending":
		return "Pending"
	default:
		return status
	}
}

func taskStatusLabel(status string) string {
	switch status {
	case "pending":
		return "Menunggu"
	case "in_progress":
		return "Dalam Proses"
	case "submitted":
		return "Disubmit"
	case "revision":
		return "Revisi"
	case "completed":
		return "Selesai"
	default:
		return status
	}
}

func priorityLabel(priority string) string {
	switch priority {
	case "low":
		return "Rendah"
	case "medium":
		return "Sedang"
	case "high":
		return "Tinggi"
	case "urgent":
		return "Mendesak"
	default:
		if priority == "" {
			return "Sedang"
		}
		return priority
	}
}

func attendanceStatusLabel(status string) string {
	switch status {
	case "present":
		return "Hadir"
	case "late":
		return "Terlambat"
	case "absent":
		return "Tidak Hadir"
	case "sick":
		return "Sakit"
	case "permission":
		return "Izin"
	default:
		return status
	}
}

func mapInternStatus(value string) string {
	v := strings.ToLower(strings.TrimSpace(value))
	switch v {
	case "aktif", "active":
		return "active"
	case "selesai", "completed":
		return "completed"
	case "pending":
		return "pending"
	case "dibatalkan", "cancelled":
		return "cancelled"
	default:
		return "active"
	}
}

func valueOrDash(v sql.NullString) string {
	if v.Valid && strings.TrimSpace(v.String) != "" {
		return v.String
	}
	return "-"
}

func formatDate(v sql.NullTime) string {
	if v.Valid {
		return v.Time.Format("02/01/2006")
	}
	return "-"
}

func formatDateTime(v sql.NullTime) string {
	if v.Valid {
		return v.Time.Format("02/01/2006 15:04")
	}
	return "-"
}

func formatTime(v sql.NullTime) string {
	if v.Valid {
		return v.Time.Format("15:04")
	}
	return "-"
}

func formatInt64(v sql.NullInt64) string {
	if v.Valid {
		return strconv.FormatInt(v.Int64, 10)
	}
	return "-"
}

func formatFloat(v sql.NullFloat64) string {
	if v.Valid {
		return fmt.Sprintf("%.1f", v.Float64)
	}
	return "0"
}

func dayNameID(day time.Weekday) string {
	switch day {
	case time.Sunday:
		return "Minggu"
	case time.Monday:
		return "Senin"
	case time.Tuesday:
		return "Selasa"
	case time.Wednesday:
		return "Rabu"
	case time.Thursday:
		return "Kamis"
	case time.Friday:
		return "Jumat"
	case time.Saturday:
		return "Sabtu"
	default:
		return "-"
	}
}

// HashPassword wraps bcrypt in utils for import usage
// We keep a small helper to safely convert optional int64
func nullInt64(val int64) sql.NullInt64 {
	if val == 0 {
		return sql.NullInt64{Valid: false}
	}
	return sql.NullInt64{Int64: val, Valid: true}
}

func hashPassword(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hash), nil
}
./internal/handlers/notification.go
package handlers

import (
	"database/sql"
	"net/http"
	"strconv"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type NotificationHandler struct {
	db *sql.DB
}

func NewNotificationHandler(db *sql.DB) *NotificationHandler {
	return &NotificationHandler{db: db}
}

func (h *NotificationHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 20
	}
	offset := (page - 1) * limit

	var total int64
	if err := h.db.QueryRow("SELECT COUNT(*) FROM notifications WHERE user_id = ?", claims.UserID).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count notifications")
		return
	}

	rows, err := h.db.Query(
		`SELECT id, user_id, type, title, message, icon, link, data, read_at, created_at, updated_at
		 FROM notifications
		 WHERE user_id = ?
		 ORDER BY created_at DESC
		 LIMIT ? OFFSET ?`,
		claims.UserID, limit, offset,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch notifications")
		return
	}
	defer rows.Close()

	var notifications []models.Notification
	for rows.Next() {
		var n models.Notification
		if err := rows.Scan(&n.ID, &n.UserID, &n.Type, &n.Title, &n.Message, &n.Icon, &n.Link, &n.Data, &n.ReadAt, &n.CreatedAt, &n.UpdatedAt); err == nil {
			notifications = append(notifications, n)
		}
	}

	utils.RespondPaginated(w, notifications, utils.CalculatePagination(page, limit, total))
}

func (h *NotificationHandler) MarkAsRead(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	res, err := h.db.Exec(
		"UPDATE notifications SET read_at = ? WHERE id = ? AND user_id = ?",
		time.Now(), id, claims.UserID,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to update notification")
		return
	}
	affected, _ := res.RowsAffected()
	if affected == 0 {
		utils.RespondNotFound(w, "Notification not found")
		return
	}

	utils.RespondSuccess(w, "Notification marked as read", nil)
}

func (h *NotificationHandler) MarkAllRead(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	if _, err := h.db.Exec(
		"UPDATE notifications SET read_at = ? WHERE user_id = ? AND read_at IS NULL",
		time.Now(), claims.UserID,
	); err != nil {
		utils.RespondInternalError(w, "Failed to mark all notifications")
		return
	}

	utils.RespondSuccess(w, "All notifications marked as read", nil)
}

func (h *NotificationHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	res, err := h.db.Exec("DELETE FROM notifications WHERE id = ? AND user_id = ?", id, claims.UserID)
	if err != nil {
		utils.RespondInternalError(w, "Failed to delete notification")
		return
	}
	affected, _ := res.RowsAffected()
	if affected == 0 {
		utils.RespondNotFound(w, "Notification not found")
		return
	}

	utils.RespondSuccess(w, "Notification deleted", nil)
}
./internal/handlers/assessment.go
package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
)

type AssessmentHandler struct {
	db *sql.DB
}

type updateAssessmentPayload struct {
	QualityScore       *int   `json:"quality_score,omitempty"`
	SpeedScore         *int   `json:"speed_score,omitempty"`
	InitiativeScore    *int   `json:"initiative_score,omitempty"`
	TeamworkScore      *int   `json:"teamwork_score,omitempty"`
	CommunicationScore *int   `json:"communication_score,omitempty"`
	Strengths          *string `json:"strengths,omitempty"`
	Improvements       *string `json:"improvements,omitempty"`
	Comments           *string `json:"comments,omitempty"`
	Aspect             *string `json:"aspect,omitempty"`
	Notes              *string `json:"notes,omitempty"`
	AssessmentDate     *string `json:"assessment_date,omitempty"` // YYYY-MM-DD
}

func NewAssessmentHandler(db *sql.DB) *AssessmentHandler {
	return &AssessmentHandler{db: db}
}

func (h *AssessmentHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	internFilter := strings.TrimSpace(r.URL.Query().Get("intern_id"))
	where := []string{}
	args := []interface{}{}

	role := normalizeRole(claims.Role)
	if role == "intern" {
		var internID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&internID); err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		where = append(where, "a.intern_id = ?")
		args = append(args, internID)
	} else if internFilter != "" {
		if id, err := strconv.ParseInt(internFilter, 10, 64); err == nil {
			where = append(where, "a.intern_id = ?")
			args = append(args, id)
		}
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
		FROM assessments a
		LEFT JOIN interns i ON a.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON a.assessed_by = au.id
		LEFT JOIN tasks t ON a.task_id = t.id
	`

	var total int64
	if err := h.db.QueryRow("SELECT COUNT(*) "+baseFrom+" "+whereClause, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count assessments")
		return
	}

	query := `
		SELECT a.id, a.intern_id, a.task_id, a.assessed_by, a.score, a.category, a.aspect,
		       a.quality_score, a.speed_score, a.initiative_score, a.teamwork_score, a.communication_score,
		       a.strengths, a.improvements, a.comments, a.notes, a.assessment_date, a.created_at, a.updated_at,
		       iu.name, au.name, t.title
	` + baseFrom + " " + whereClause + " ORDER BY a.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch assessments")
		return
	}
	defer rows.Close()

	var assessments []models.Assessment
	for rows.Next() {
		var a models.Assessment
		var internName, assessorName, taskTitle sql.NullString
		if err := rows.Scan(
			&a.ID, &a.InternID, &a.TaskID, &a.AssessedBy, &a.Score, &a.Category, &a.Aspect,
			&a.QualityScore, &a.SpeedScore, &a.InitiativeScore, &a.TeamworkScore, &a.CommunicationScore,
			&a.Strengths, &a.Improvements, &a.Comments, &a.Notes, &a.AssessmentDate, &a.CreatedAt, &a.UpdatedAt,
			&internName, &assessorName, &taskTitle,
		); err == nil {
			if internName.Valid {
				a.InternName = internName.String
			}
			if assessorName.Valid {
				a.AssessorName = assessorName.String
			}
			if taskTitle.Valid {
				a.TaskTitle = taskTitle.String
			}
			assessments = append(assessments, a)
		}
	}

	utils.RespondPaginated(w, assessments, utils.CalculatePagination(page, limit, total))
}

func (h *AssessmentHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	query := `
		SELECT a.id, a.intern_id, a.task_id, a.assessed_by, a.score, a.category, a.aspect,
		       a.quality_score, a.speed_score, a.initiative_score, a.teamwork_score, a.communication_score,
		       a.strengths, a.improvements, a.comments, a.notes, a.assessment_date, a.created_at, a.updated_at,
		       iu.name, au.name, t.title
		FROM assessments a
		LEFT JOIN interns i ON a.intern_id = i.id
		LEFT JOIN users iu ON i.user_id = iu.id
		LEFT JOIN users au ON a.assessed_by = au.id
		LEFT JOIN tasks t ON a.task_id = t.id
		WHERE a.id = ?
	`

	var a models.Assessment
	var internName, assessorName, taskTitle sql.NullString
	err := h.db.QueryRow(query, id).Scan(
		&a.ID, &a.InternID, &a.TaskID, &a.AssessedBy, &a.Score, &a.Category, &a.Aspect,
		&a.QualityScore, &a.SpeedScore, &a.InitiativeScore, &a.TeamworkScore, &a.CommunicationScore,
		&a.Strengths, &a.Improvements, &a.Comments, &a.Notes, &a.AssessmentDate, &a.CreatedAt, &a.UpdatedAt,
		&internName, &assessorName, &taskTitle,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Assessment not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	if normalizeRole(claims.Role) == "intern" {
		var myInternID int64
		if err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", claims.UserID).Scan(&myInternID); err != nil || myInternID != a.InternID {
			utils.RespondForbidden(w, "You do not have access to this assessment")
			return
		}
	}

	if internName.Valid {
		a.InternName = internName.String
	}
	if assessorName.Valid {
		a.AssessorName = assessorName.String
	}
	if taskTitle.Valid {
		a.TaskTitle = taskTitle.String
	}

	utils.RespondSuccess(w, "Assessment retrieved", a)
}

func (h *AssessmentHandler) GetByInternID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)
	q := r.URL.Query()
	q.Set("intern_id", strconv.FormatInt(internID, 10))
	r.URL.RawQuery = q.Encode()
	h.GetAll(w, r)
}

func (h *AssessmentHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can create assessments")
		return
	}

	var req models.CreateAssessmentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if req.InternID == 0 {
		utils.RespondBadRequest(w, "intern_id is required")
		return
	}

	score := (req.QualityScore + req.SpeedScore + req.InitiativeScore + req.TeamworkScore + req.CommunicationScore) / 5
	aspect := req.Aspect
	if strings.TrimSpace(aspect) == "" {
		aspect = "overall"
	}
	assessmentDate := req.AssessmentDate
	if assessmentDate.IsZero() {
		assessmentDate = time.Now()
	}

	var taskID sql.NullInt64
	if req.TaskID != nil && *req.TaskID > 0 {
		taskID = sql.NullInt64{Int64: *req.TaskID, Valid: true}
	}

	_, err := h.db.Exec(
		`INSERT INTO assessments (intern_id, task_id, assessed_by, score, aspect, quality_score, speed_score, initiative_score,
		                          teamwork_score, communication_score, strengths, improvements, comments, notes, assessment_date)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		req.InternID, taskID, claims.UserID, score, aspect,
		req.QualityScore, req.SpeedScore, req.InitiativeScore, req.TeamworkScore, req.CommunicationScore,
		nullIfEmpty(req.Strengths), nullIfEmpty(req.Improvements), nullIfEmpty(req.Comments), nullIfEmpty(req.Notes), assessmentDate,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create assessment")
		return
	}

	utils.RespondCreated(w, "Assessment created", nil)
}

func (h *AssessmentHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update assessments")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateAssessmentPayload
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Load existing scores
	var existing struct {
		Quality       sql.NullInt64
		Speed         sql.NullInt64
		Initiative    sql.NullInt64
		Teamwork      sql.NullInt64
		Communication sql.NullInt64
	}
	err := h.db.QueryRow(
		`SELECT quality_score, speed_score, initiative_score, teamwork_score, communication_score
		 FROM assessments WHERE id = ?`, id,
	).Scan(&existing.Quality, &existing.Speed, &existing.Initiative, &existing.Teamwork, &existing.Communication)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Assessment not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	quality := int64OrZero(existing.Quality)
	speed := int64OrZero(existing.Speed)
	initiative := int64OrZero(existing.Initiative)
	teamwork := int64OrZero(existing.Teamwork)
	communication := int64OrZero(existing.Communication)

	updates := []string{}
	args := []interface{}{}

	if req.QualityScore != nil {
		quality = int64(*req.QualityScore)
		updates = append(updates, "quality_score = ?")
		args = append(args, *req.QualityScore)
	}
	if req.SpeedScore != nil {
		speed = int64(*req.SpeedScore)
		updates = append(updates, "speed_score = ?")
		args = append(args, *req.SpeedScore)
	}
	if req.InitiativeScore != nil {
		initiative = int64(*req.InitiativeScore)
		updates = append(updates, "initiative_score = ?")
		args = append(args, *req.InitiativeScore)
	}
	if req.TeamworkScore != nil {
		teamwork = int64(*req.TeamworkScore)
		updates = append(updates, "teamwork_score = ?")
		args = append(args, *req.TeamworkScore)
	}
	if req.CommunicationScore != nil {
		communication = int64(*req.CommunicationScore)
		updates = append(updates, "communication_score = ?")
		args = append(args, *req.CommunicationScore)
	}

	if req.Strengths != nil {
		updates = append(updates, "strengths = ?")
		args = append(args, nullIfEmpty(*req.Strengths))
	}
	if req.Improvements != nil {
		updates = append(updates, "improvements = ?")
		args = append(args, nullIfEmpty(*req.Improvements))
	}
	if req.Comments != nil {
		updates = append(updates, "comments = ?")
		args = append(args, nullIfEmpty(*req.Comments))
	}
	if req.Notes != nil {
		updates = append(updates, "notes = ?")
		args = append(args, nullIfEmpty(*req.Notes))
	}
	if req.Aspect != nil {
		updates = append(updates, "aspect = ?")
		args = append(args, *req.Aspect)
	}
	if req.AssessmentDate != nil && *req.AssessmentDate != "" {
		if parsed, err := time.Parse("2006-01-02", *req.AssessmentDate); err == nil {
			updates = append(updates, "assessment_date = ?")
			args = append(args, parsed)
		}
	}

	// recompute score if any criteria updated
	score := int((quality + speed + initiative + teamwork + communication) / 5)
	updates = append(updates, "score = ?")
	args = append(args, score)

	if len(updates) == 0 {
		utils.RespondBadRequest(w, "No updates provided")
		return
	}

	args = append(args, id)
	if _, err := h.db.Exec("UPDATE assessments SET "+strings.Join(updates, ", ")+" WHERE id = ?", args...); err != nil {
		utils.RespondInternalError(w, "Failed to update assessment")
		return
	}

	utils.RespondSuccess(w, "Assessment updated", nil)
}

func (h *AssessmentHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can delete assessments")
		return
	}

	vars := mux.Vars(r)
	id, _ := strconv.ParseInt(vars["id"], 10, 64)

	if _, err := h.db.Exec("DELETE FROM assessments WHERE id = ?", id); err != nil {
		utils.RespondInternalError(w, "Failed to delete assessment")
		return
	}

	utils.RespondSuccess(w, "Assessment deleted", nil)
}
./internal/routes/routes.go
package routes

import (
	"database/sql"
	"net/http"

	"dsi_interna_sys/internal/handlers"
	"dsi_interna_sys/internal/middleware"

	"github.com/gorilla/mux"
)

func SetupRoutes(router *mux.Router, db *sql.DB) {
	authHandler := handlers.NewAuthHandler(db)
	internHandler := handlers.NewInternHandler(db)
	taskHandler := handlers.NewTaskHandler(db)
	attendanceHandler := handlers.NewAttendanceHandler(db)
	leaveHandler := handlers.NewLeaveHandler(db)
	assessmentHandler := handlers.NewAssessmentHandler(db)
	reportHandler := handlers.NewReportHandler(db)
	analyticsHandler := handlers.NewAnalyticsHandler(db)
	notificationHandler := handlers.NewNotificationHandler(db)
	settingHandler := handlers.NewSettingHandler(db)
	supervisorHandler := handlers.NewSupervisorHandler(db)
	exportImportHandler := handlers.NewExportImportHandler(db)
	profileHandler := handlers.NewProfileHandler(db)
	passwordResetHandler := handlers.NewPasswordResetHandler(db)
	dashboardHandler := handlers.NewDashboardHandler(db)

	api := router.PathPrefix("/api").Subrouter()

	// Public
	api.HandleFunc("/health", healthCheck).Methods("GET")
	api.HandleFunc("/auth/login", authHandler.Login).Methods("POST")
	api.HandleFunc("/auth/google", authHandler.StartGoogleOAuth).Methods("GET")
	api.HandleFunc("/auth/google/callback", authHandler.HandleGoogleCallback).Methods("GET")
	api.HandleFunc("/auth/password/forgot", passwordResetHandler.RequestReset).Methods("POST")
	api.HandleFunc("/auth/password/reset", passwordResetHandler.Reset).Methods("POST")

	// Protected
	protected := api.PathPrefix("").Subrouter()
	protected.Use(middleware.AuthMiddleware)

	// Holidays
	protected.HandleFunc("/holidays", handlers.GetHolidays).Methods("GET")

	admin := protected.PathPrefix("").Subrouter()
	admin.Use(middleware.RequireRole("admin"))
	admin.HandleFunc("/auth/register", authHandler.Register).Methods("POST")

	// Auth
	protected.HandleFunc("/auth/me", authHandler.GetCurrentUser).Methods("GET")
	protected.HandleFunc("/auth/2fa/setup", authHandler.Setup2FA).Methods("POST")
	protected.HandleFunc("/auth/2fa/verify", authHandler.Verify2FA).Methods("POST")
	protected.HandleFunc("/auth/2fa/disable", authHandler.Disable2FA).Methods("POST")
	protected.HandleFunc("/auth/logout", authHandler.Logout).Methods("POST")

	// Profile
	protected.HandleFunc("/profile", profileHandler.Get).Methods("GET")
	protected.HandleFunc("/profile", profileHandler.Update).Methods("PUT")
	protected.HandleFunc("/profile/password", profileHandler.UpdatePassword).Methods("PUT")

	// Interns
	protected.HandleFunc("/interns", internHandler.GetAll).Methods("GET")
	protected.HandleFunc("/interns", internHandler.Create).Methods("POST")
	protected.HandleFunc("/interns/{id}", internHandler.GetByID).Methods("GET")
	protected.HandleFunc("/interns/{id}", internHandler.Update).Methods("PUT")
	protected.HandleFunc("/interns/{id}", internHandler.Delete).Methods("DELETE")

	// Tasks
	protected.HandleFunc("/tasks", taskHandler.GetAll).Methods("GET")
	protected.HandleFunc("/tasks", taskHandler.Create).Methods("POST")
	protected.HandleFunc("/tasks/intern/{id}", taskHandler.GetByInternID).Methods("GET")
	protected.HandleFunc("/tasks/search-interns", taskHandler.SearchInterns).Methods("GET")
	protected.HandleFunc("/tasks/{id}/attachments", taskHandler.UploadAttachment).Methods("POST")
	protected.HandleFunc("/tasks/{id}/complete", taskHandler.MarkComplete).Methods("POST")
	protected.HandleFunc("/tasks/{id}/status", taskHandler.UpdateStatus).Methods("POST")
	protected.HandleFunc("/tasks/{id}/submit", taskHandler.Submit).Methods("POST")
	protected.HandleFunc("/tasks/{id}/review", taskHandler.Review).Methods("POST")
	protected.HandleFunc("/tasks/{id}", taskHandler.GetByID).Methods("GET")
	protected.HandleFunc("/tasks/{id}", taskHandler.Update).Methods("PUT")
	protected.HandleFunc("/tasks/{id}", taskHandler.Delete).Methods("DELETE")

	// Task Assignments (grouped)
	protected.HandleFunc("/task-assignments", taskHandler.GetAssignments).Methods("GET")
	protected.HandleFunc("/task-assignments/{id}", taskHandler.GetAssignmentByID).Methods("GET")

	// Attendance - ORDER IS CRITICAL HERE
	protected.HandleFunc("/attendance", attendanceHandler.GetAll).Methods("GET")
	protected.HandleFunc("/attendance/today", attendanceHandler.GetToday).Methods("GET")     // SPECIFIC
	protected.HandleFunc("/attendance/checkin", attendanceHandler.CheckIn).Methods("POST")   // SPECIFIC
	protected.HandleFunc("/attendance/checkout", attendanceHandler.CheckOut).Methods("POST") // SPECIFIC
	protected.HandleFunc("/attendance/permission", attendanceHandler.SubmitPermission).Methods("POST")
	protected.HandleFunc("/attendance/intern/{id}", attendanceHandler.GetByInternID).Methods("GET")
	protected.HandleFunc("/attendance/{id}", attendanceHandler.GetByID).Methods("GET") // GENERIC LAST

	// Leaves
	protected.HandleFunc("/leaves", leaveHandler.GetAll).Methods("GET")
	protected.HandleFunc("/leaves", leaveHandler.Create).Methods("POST")
	protected.HandleFunc("/leaves/intern/{id}", leaveHandler.GetByInternID).Methods("GET")
	protected.HandleFunc("/leaves/{id}/approve", leaveHandler.Approve).Methods("POST")
	protected.HandleFunc("/leaves/{id}/reject", leaveHandler.Reject).Methods("POST")
	protected.HandleFunc("/leaves/{id}/attachment", leaveHandler.UploadAttachment).Methods("POST")
	protected.HandleFunc("/leaves/{id}", leaveHandler.GetByID).Methods("GET")
	protected.HandleFunc("/leaves/{id}", leaveHandler.Update).Methods("PUT")

	// Assessments
	protected.HandleFunc("/assessments", assessmentHandler.GetAll).Methods("GET")
	protected.HandleFunc("/assessments", assessmentHandler.Create).Methods("POST")
	protected.HandleFunc("/assessments/intern/{id}", assessmentHandler.GetByInternID).Methods("GET")
	protected.HandleFunc("/assessments/{id}", assessmentHandler.GetByID).Methods("GET")
	protected.HandleFunc("/assessments/{id}", assessmentHandler.Update).Methods("PUT")
	protected.HandleFunc("/assessments/{id}", assessmentHandler.Delete).Methods("DELETE")

	// Reports
	protected.HandleFunc("/reports", reportHandler.GetAll).Methods("GET")
	protected.HandleFunc("/reports", reportHandler.Create).Methods("POST")
	protected.HandleFunc("/reports/{id}", reportHandler.GetByID).Methods("GET")
	protected.HandleFunc("/reports/{id}", reportHandler.Update).Methods("PUT")
	protected.HandleFunc("/reports/{id}", reportHandler.Delete).Methods("DELETE")
	protected.HandleFunc("/reports/{id}/feedback", reportHandler.AddFeedback).Methods("POST")
	protected.HandleFunc("/reports/intern/{id}", reportHandler.GetInternReport).Methods("GET")
	protected.HandleFunc("/reports/attendance/{id}", reportHandler.GetAttendanceReport).Methods("GET")
	protected.HandleFunc("/reports/assessments/{id}", reportHandler.GetAssessmentReport).Methods("GET")
	protected.HandleFunc("/reports/certificate/{id}", reportHandler.GetCertificate).Methods("GET")
	protected.HandleFunc("/reports/certificate/{id}/generate", reportHandler.GenerateCertificate).Methods("POST")

	// Analytics
	analytics := protected.PathPrefix("/analytics").Subrouter()
	analytics.Use(middleware.RequireRole("admin", "pembimbing", "supervisor", "intern"))
	analytics.HandleFunc("/trends/weekly/{id:[0-9]+}", analyticsHandler.GetWeeklyTrends).Methods("GET")
	analytics.HandleFunc("/patterns/checkin/{id:[0-9]+}", analyticsHandler.GetCheckInPatterns).Methods("GET")
	analytics.HandleFunc("/insights/{id:[0-9]+}", analyticsHandler.GetPerformanceInsights).Methods("GET")

	// Dashboard (all authenticated users)
	dashboard := protected.PathPrefix("/dashboard").Subrouter()
	dashboard.HandleFunc("/intern", dashboardHandler.GetInternDashboard).Methods("GET")
	dashboard.HandleFunc("/admin", dashboardHandler.GetAdminDashboard).Methods("GET")

	// Notifications
	protected.HandleFunc("/notifications", notificationHandler.GetAll).Methods("GET")
	protected.HandleFunc("/notifications/{id}/read", notificationHandler.MarkAsRead).Methods("POST")
	protected.HandleFunc("/notifications/mark-all-read", notificationHandler.MarkAllRead).Methods("POST")
	protected.HandleFunc("/notifications/{id}", notificationHandler.Delete).Methods("DELETE")

	// Settings (admin only)
	settings := protected.PathPrefix("/settings").Subrouter()
	settings.Use(middleware.RequireRole("admin"))
	settings.HandleFunc("", settingHandler.GetAll).Methods("GET")
	settings.HandleFunc("", settingHandler.Update).Methods("POST")

	// Supervisors (admin only)
	admin.HandleFunc("/supervisors", supervisorHandler.GetAll).Methods("GET")
	admin.HandleFunc("/supervisors", supervisorHandler.Create).Methods("POST")
	admin.HandleFunc("/supervisors/{id}", supervisorHandler.GetByID).Methods("GET")
	admin.HandleFunc("/supervisors/{id}", supervisorHandler.Update).Methods("PUT")
	admin.HandleFunc("/supervisors/{id}", supervisorHandler.Delete).Methods("DELETE")
	admin.HandleFunc("/supervisors/{id}/approve", supervisorHandler.Approve).Methods("POST")
	admin.HandleFunc("/supervisors/{id}/reject", supervisorHandler.Reject).Methods("POST")

	// Export/Import (admin & pembimbing)
	manager := protected.PathPrefix("").Subrouter()
	manager.Use(middleware.RequireRole("admin", "pembimbing"))
	manager.HandleFunc("/export/interns", exportImportHandler.ExportInterns).Methods("GET")
	manager.HandleFunc("/export/attendances", exportImportHandler.ExportAttendances).Methods("GET")
	manager.HandleFunc("/export/tasks", exportImportHandler.ExportTasks).Methods("GET")
	manager.HandleFunc("/import/interns", exportImportHandler.ImportInterns).Methods("POST")
	manager.HandleFunc("/import/template", exportImportHandler.DownloadTemplate).Methods("GET")
	manager.HandleFunc("/interns/{id}/download-report", reportHandler.DownloadInternReport).Methods("GET")
	manager.HandleFunc("/interns/{id}/certificate", reportHandler.DownloadCertificate).Methods("GET")

	router.PathPrefix("/uploads/").Handler(
		http.StripPrefix("/uploads/",
			middleware.AuthMiddleware(
				http.FileServer(http.Dir("./uploads")),
			),
		),
	)
}

func healthCheck(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status":"ok","message":"INTERNA API is running"}`))
}
./internal/middleware/auth.go
package middleware

import (
	"context"
	"net/http"
	"strings"

	"dsi_interna_sys/internal/config"
	"dsi_interna_sys/internal/utils"

	"github.com/golang-jwt/jwt/v5"
)

type contextKey string

const UserContextKey contextKey = "user"

// Claims represents JWT claims
type Claims struct {
	UserID int64  `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

// AuthMiddleware validates JWT token
func AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get token from Authorization header
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			utils.RespondUnauthorized(w, "Missing authorization header")
			return
		}

		// Extract token from "Bearer <token>"
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			utils.RespondUnauthorized(w, "Invalid authorization header format")
			return
		}

		tokenString := parts[1]

		// Parse and validate token
		claims := &Claims{}
		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(config.Loaded.JWT.Secret), nil
		})

		if err != nil || !token.Valid {
			utils.RespondUnauthorized(w, "Invalid or expired token")
			return
		}

		// Add claims to request context
		ctx := context.WithValue(r.Context(), UserContextKey, claims)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetUserFromContext extracts user claims from context
func GetUserFromContext(ctx context.Context) (*Claims, bool) {
	claims, ok := ctx.Value(UserContextKey).(*Claims)
	return claims, ok
}

// RequireRole middleware checks if user has required role
func RequireRole(roles ...string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			claims, ok := GetUserFromContext(r.Context())
			if !ok {
				utils.RespondUnauthorized(w, "Unauthorized")
				return
			}

			normalized := NormalizeRole(claims.Role)

			// Check if user has required role
			hasRole := false
			for _, role := range roles {
				if normalized == NormalizeRole(role) {
					hasRole = true
					break
				}
			}

			if !hasRole {
				utils.RespondForbidden(w, "Insufficient permissions")
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// NormalizeRole maps legacy role names to the canonical set.
func NormalizeRole(role string) string {
	if role == "supervisor" {
		return "pembimbing"
	}
	return role
}
./create-admin.go
package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/joho/godotenv"
	"golang.org/x/crypto/bcrypt"
)

type supervisorSeed struct {
	Name  string
	Email string
	NIP   string
}

type internSeed struct {
	ID     int64
	UserID int64
	Status string
}

type taskSeed struct {
	ID       int64
	InternID int64
	Status   string
}

type seedCounts struct {
	Interns                int
	TaskAssignments        int
	AttendanceDays         int
	ReportsMinWeeks        int
	ReportsMaxWeeks        int
	NotificationsPerUser   int
	AssessmentsSampleRatio int
}

var tasksHasTargetDate *bool

var firstNames = []string{
	"Ahmad", "Budi", "Citra", "Dewi", "Eka", "Fadli", "Gita", "Hendra", "Indah", "Joko",
	"Kartika", "Lukman", "Maya", "Naufal", "Olivia", "Prasetyo", "Qori", "Rizki", "Sari", "Taufik",
	"Umi", "Vino", "Wulan", "Yoga", "Zahra", "Aditya", "Bella", "Cahyo", "Diana", "Erwin",
	"Fitri", "Galih", "Hani", "Irfan", "Julia",
}

var lastNames = []string{
	"Pratama", "Wijaya", "Kusuma", "Sari", "Nugroho", "Permana", "Santoso", "Putra", "Wati", "Hidayat",
	"Ramadhan", "Lestari", "Setiawan", "Utami", "Saputra", "Dewi", "Kurniawan", "Putri", "Firmansyah", "Handayani",
	"Ramadhani", "Anggraini", "Prasetya", "Maharani", "Arifin", "Susanti", "Wahyudi", "Puspita", "Haryanto", "Safitri",
}

var schools = []string{
	"SMK Negeri 1 Jakarta",
	"SMK Negeri 2 Bandung",
	"SMK Telkom Malang",
	"SMK Informatika Surabaya",
	"Politeknik Negeri Jakarta",
	"Universitas Indonesia",
	"Institut Teknologi Bandung",
	"Universitas Gadjah Mada",
	"Universitas Brawijaya",
	"Politeknik Elektronika Negeri Surabaya",
	"SMK Negeri 4 Malang",
	"SMK Prakarya Internasional",
	"SMK Wikrama Bogor",
	"Universitas Bina Nusantara",
	"Universitas Telkom",
}

var departments = []string{
	"Rekayasa Perangkat Lunak",
	"Teknik Komputer dan Jaringan",
	"Multimedia",
	"Sistem Informasi",
	"Teknik Informatika",
	"Manajemen Informatika",
	"Desain Grafis",
	"Animasi",
	"Broadcasting",
	"Bisnis Digital",
}

var taskTitles = []string{
	"Membuat Landing Page Website",
	"Develop REST API Authentication",
	"Redesign UI Dashboard Admin",
	"Setup CI/CD Pipeline",
	"Database Migration & Optimization",
	"Implementasi Payment Gateway",
	"Unit Testing Module User",
	"Dokumentasi API Swagger",
	"Mobile App - Login Screen",
	"Integrasi Social Media Login",
	"Develop Chat Feature Real-time",
	"Setup Monitoring & Logging",
	"Optimasi Performance Website",
	"Membuat Report Generator PDF",
	"Implementasi Notifikasi Push",
	"Develop E-commerce Cart System",
	"Setup Email Template",
	"Membuat Data Visualization Dashboard",
	"Develop File Upload System",
	"Implementasi Role-based Access Control",
}

var taskDescriptions = []string{
	"Membuat landing page responsive dengan design modern menggunakan Tailwind CSS dan animasi smooth scroll.",
	"Mengembangkan REST API untuk autentikasi menggunakan JWT dengan fitur login, register, dan refresh token.",
	"Melakukan redesign pada halaman dashboard admin untuk meningkatkan user experience dan accessibility.",
	"Melakukan setup continuous integration dan continuous deployment menggunakan GitHub Actions.",
	"Melakukan migrasi database dan optimasi query untuk meningkatkan performa aplikasi.",
	"Mengintegrasikan payment gateway Midtrans untuk proses pembayaran online.",
	"Menulis unit test untuk module user dengan coverage minimal 80%.",
	"Membuat dokumentasi API lengkap menggunakan Swagger/OpenAPI specification.",
	"Develop tampilan login screen untuk aplikasi mobile dengan Flutter.",
	"Integrasi login menggunakan Google dan Facebook OAuth.",
	"Mengembangkan fitur chat real-time menggunakan WebSocket.",
	"Setup monitoring aplikasi menggunakan Prometheus dan Grafana.",
	"Melakukan optimasi performa website termasuk lazy loading dan caching.",
	"Membuat sistem generate report dalam format PDF yang bisa di-download.",
	"Implementasi push notification untuk web dan mobile application.",
	"Develop sistem keranjang belanja lengkap dengan kalkulasi harga dan diskon.",
	"Membuat email template responsive untuk berbagai keperluan notifikasi.",
	"Membuat dashboard visualisasi data menggunakan Chart.js atau D3.js.",
	"Develop sistem upload file dengan validasi tipe dan ukuran file.",
	"Implementasi sistem role dan permission untuk kontrol akses user.",
}

var supervisorSeeds = []supervisorSeed{
	{Name: "Bambang Agus Herlambang, M.Kom", Email: "bambang.herlambang@internapro.id", NIP: "198501234567891001"},
	{Name: "Noora Qotrun Nada, S.T., M.T.", Email: "noora@internapro.id", NIP: "198601234567891002"},
	{Name: "Mega Novita, Ph.D", Email: "mega.novita@internapro.id", NIP: "198701234567891003"},
}

func main() {
	godotenv.Load()
	rand.Seed(time.Now().UnixNano())

	db := openDB()
	defer db.Close()

	counts := seedCounts{
		Interns:                envInt("SEED_INTERNS", 60),
		TaskAssignments:        envInt("SEED_ASSIGNMENTS", 12),
		AttendanceDays:         envInt("SEED_ATTENDANCE_DAYS", 30),
		ReportsMinWeeks:        envInt("SEED_REPORT_WEEKS_MIN", 2),
		ReportsMaxWeeks:        envInt("SEED_REPORT_WEEKS_MAX", 4),
		NotificationsPerUser:   envInt("SEED_NOTIFICATIONS_PER_USER", 2),
		AssessmentsSampleRatio: envInt("SEED_ASSESSMENT_SAMPLE_RATIO", 3),
	}

	force := envBool("SEED_FORCE", false)
	reuseInterns := envBool("SEED_REUSE_INTERNS", false)

	fmt.Println(" Connected to database")
	fmt.Println("")

	adminID := seedAdmin(db)
	supervisorIDs := seedSupervisors(db)
	institutionIDs := seedInstitutions(db)
	interns := seedInterns(db, supervisorIDs, institutionIDs, counts.Interns, reuseInterns)

	shouldSeedHeavy := force || !hasRows(db, "tasks")
	if !shouldSeedHeavy {
		fmt.Println("  Tasks already exist. Skipping heavy demo data (set SEED_FORCE=true to reseed).")
		printSummary()
		return
	}

	tasks := seedTaskAssignments(db, adminID, interns, counts.TaskAssignments)
	seedAttendances(db, interns, counts.AttendanceDays)
	seedAssessments(db, adminID, tasks, counts.AssessmentsSampleRatio)
	seedReports(db, interns, counts.ReportsMinWeeks, counts.ReportsMaxWeeks)
	seedNotifications(db, adminID, supervisorIDs, interns, counts.NotificationsPerUser)

	printSummary()
}

func openDB() *sql.DB {
	dbUser := env("DB_USER", "root")
	dbPass := os.Getenv("DB_PASSWORD")
	dbHost := env("DB_HOST", "localhost")
	dbPort := env("DB_PORT", "3306")
	dbName := env("DB_NAME", "interna_db")

	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
		dbUser, dbPass, dbHost, dbPort, dbName)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	if err := db.Ping(); err != nil {
		log.Fatal("Failed to ping database:", err)
	}
	return db
}

func seedAdmin(db *sql.DB) int64 {
	fmt.Println("Creating admin account...")
	adminID, err := createOrGetUser(db, "Administrator", "admin@internapro.id", "password", "admin")
	if err != nil {
		log.Fatal("Failed to create admin:", err)
	}
	fmt.Println(" Admin account ready")
	return adminID
}

func seedSupervisors(db *sql.DB) []int64 {
	fmt.Println("Creating supervisor accounts...")
	ids := make([]int64, 0, len(supervisorSeeds))
	for _, sup := range supervisorSeeds {
		userID, err := createOrGetUser(db, sup.Name, sup.Email, "password", "pembimbing")
		if err != nil {
			log.Println("  Supervisor create failed:", err)
			continue
		}
		ids = append(ids, userID)

		ensureSupervisorProfile(db, userID, sup.Name, sup.NIP)
	}
	fmt.Printf(" %d supervisors ready\n", len(ids))
	return ids
}

func seedInstitutions(db *sql.DB) []int64 {
	fmt.Println("Creating institutions...")
	var ids []int64
	for i, name := range schools {
		if i >= 6 {
			break
		}
		address := fmt.Sprintf("Jl. %s No. %d, Jakarta", lastNames[rand.Intn(len(lastNames))], rand.Intn(120)+1)
		phone := fmt.Sprintf("02%d-%07d", rand.Intn(10), rand.Intn(9000000)+1000000)
		email := strings.ToLower(strings.ReplaceAll(name, " ", "")) + "@example.edu"
		id, err := ensureInstitution(db, name, address, phone, email)
		if err == nil {
			ids = append(ids, id)
		}
	}
	fmt.Printf(" %d institutions ready\n", len(ids))
	return ids
}

func seedInterns(db *sql.DB, supervisorIDs []int64, institutionIDs []int64, count int, reuseExisting bool) []internSeed {
	interns := make([]internSeed, 0, count)
	usedEmails := map[string]bool{}

	if reuseExisting {
		existing, existingEmails := loadExistingInterns(db, count)
		for email := range existingEmails {
			usedEmails[email] = true
		}
		interns = append(interns, existing...)
		if len(interns) >= count {
			fmt.Printf(" %d interns ready (reused)\n", len(interns))
			return interns[:count]
		}
	}

	toCreate := count - len(interns)
	fmt.Printf("Creating %d interns...\n", toCreate)

	for i := 0; i < toCreate; i++ {
		first := firstNames[rand.Intn(len(firstNames))]
		last := lastNames[rand.Intn(len(lastNames))]
		fullName := first + " " + last

		email := uniqueEmail(first, last, usedEmails)
		userID, err := createOrGetUser(db, fullName, email, "password", "intern")
		if err != nil {
			log.Println("  Intern user create failed:", err)
			continue
		}

		startDate := time.Now().AddDate(0, -rand.Intn(3)-1, -rand.Intn(30))
		endDate := startDate.AddDate(0, rand.Intn(4)+3, 0)
		status := determineInternStatus(endDate)

		institutionID := pickID(institutionIDs)
		supervisorID := pickID(supervisorIDs)

		internID, err := ensureInternProfile(db, userID, institutionID, supervisorID, len(interns)+1, fullName, status, startDate, endDate)
		if err != nil {
			log.Println("  Intern profile create failed:", err)
			continue
		}

		interns = append(interns, internSeed{ID: internID, UserID: userID, Status: status})
	}

	fmt.Printf(" %d interns ready\n", len(interns))
	return interns
}

func seedTaskAssignments(db *sql.DB, adminID int64, interns []internSeed, assignmentCount int) []taskSeed {
	fmt.Printf("Creating %d task assignments...\n", assignmentCount)
	tasks := make([]taskSeed, 0, assignmentCount*5)

	activeInterns := filterActiveInterns(interns)
	allStatuses := []string{"pending", "in_progress", "submitted", "revision", "completed"}

	for i := 0; i < assignmentCount; i++ {
		title := taskTitles[i%len(taskTitles)]
		desc := taskDescriptions[i%len(taskDescriptions)]
		priority := []string{"low", "medium", "high"}[rand.Intn(3)]

		deadline := time.Now().AddDate(0, 0, rand.Intn(28)-7)
		startDate := time.Now().AddDate(0, 0, rand.Intn(10)-3)
		deadlineTime := fmt.Sprintf("%02d:00:00", rand.Intn(5)+14)
		assignToAll := i < 2

		assignmentID, err := insertTaskAssignment(db, adminID, title, desc, priority, startDate, deadline, deadlineTime, assignToAll)
		if err != nil {
			log.Println("  Task assignment create failed:", err)
			continue
		}

		assigned := pickInterns(activeInterns, assignToAll)
		for _, intern := range assigned {
			_, _ = db.Exec(`
				INSERT IGNORE INTO task_assignment_interns (task_assignment_id, intern_id)
				VALUES (?, ?)
			`, assignmentID, intern.ID)

			status := allStatuses[rand.Intn(len(allStatuses))]
			taskID, err := insertTask(db, assignmentID, intern.ID, adminID, title, desc, priority, status, startDate, deadline, deadlineTime)
			if err != nil {
				log.Println("  Task create failed:", err)
				continue
			}
			tasks = append(tasks, taskSeed{ID: taskID, InternID: intern.ID, Status: status})
		}
	}

	fmt.Printf(" %d task assignments ready\n", assignmentCount)
	return tasks
}

func seedAttendances(db *sql.DB, interns []internSeed, days int) {
	fmt.Printf("Creating attendance records (%d days)...\n", days)
	startDate := time.Now().AddDate(0, 0, -days)
	endDate := time.Now()

	for _, intern := range interns {
		if intern.Status == "cancelled" {
			continue
		}

		for d := startDate; !d.After(endDate); d = d.AddDate(0, 0, 1) {
			weekday := d.Weekday()
			if weekday == time.Saturday || weekday == time.Sunday {
				continue
			}

			status, checkIn, checkOut, lateReason, notes := generateAttendanceData(d)
			_, _ = db.Exec(`
				INSERT INTO attendances (intern_id, date, check_in_time, check_out_time, status, late_reason, notes, distance_meters)
				VALUES (?, ?, ?, ?, ?, ?, ?, ?)
				ON DUPLICATE KEY UPDATE status = VALUES(status), check_in_time = VALUES(check_in_time), check_out_time = VALUES(check_out_time)
			`, intern.ID, d.Format("2006-01-02"), checkIn, checkOut, status, lateReason, notes, rand.Intn(900)+50)
		}
	}

	fmt.Println(" Attendance records created")
}

func seedAssessments(db *sql.DB, adminID int64, tasks []taskSeed, sampleRatio int) {
	fmt.Println("Creating assessments...")
	created := 0
	for _, task := range tasks {
		if task.Status != "completed" {
			continue
		}
		if sampleRatio > 1 && rand.Intn(sampleRatio) != 0 {
			continue
		}

		score := rand.Intn(31) + 70
		assessmentDate := time.Now().AddDate(0, 0, -rand.Intn(20))
		aspect := []string{"discipline", "work_quality", "attitude", "communication"}[rand.Intn(4)]

		_, err := db.Exec(`
			INSERT INTO assessments (
				intern_id, task_id, assessed_by, score, aspect,
				quality_score, speed_score, initiative_score, teamwork_score, communication_score,
				strengths, improvements, comments, assessment_date
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			task.InternID, task.ID, adminID, score, aspect,
			rand.Intn(31)+70, rand.Intn(31)+65, rand.Intn(41)+60, rand.Intn(31)+70, rand.Intn(36)+65,
			randomChoice([]string{"Problem solving yang baik", "Tekun dan teliti", "Komunikatif", "Cepat belajar", "Kreatif"}),
			randomChoice([]string{"Perlu lebih teliti", "Time management", "Dokumentasi bisa ditingkatkan", "Komunikasi lebih aktif"}),
			"Secara keseluruhan menunjukkan perkembangan yang "+randomChoice([]string{"baik", "cukup baik", "sangat baik"})+".",
			assessmentDate.Format("2006-01-02"),
		)
		if err == nil {
			created++
		}
	}
	fmt.Printf(" %d assessments created\n", created)
}

func seedReports(db *sql.DB, interns []internSeed, minWeeks, maxWeeks int) {
	fmt.Println("Creating reports...")
	created := 0
	for _, intern := range interns {
		if intern.Status == "cancelled" {
			continue
		}
		weeksCount := rand.Intn(maxWeeks-minWeeks+1) + minWeeks
		for w := 1; w <= weeksCount; w++ {
			periodStart := time.Now().AddDate(0, 0, -7*w)
			periodEnd := periodStart.AddDate(0, 0, 6)

			_, err := db.Exec(`
				INSERT INTO reports (intern_id, created_by, title, content, type, period_start, period_end, status, feedback)
				VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
			`,
				intern.ID, intern.UserID,
				fmt.Sprintf("Laporan Mingguan - Minggu ke-%d", w),
				"Selama minggu ini saya telah mengerjakan beberapa tugas yang diberikan. Berikut ringkasan pekerjaan yang telah diselesaikan...",
				"weekly",
				periodStart.Format("2006-01-02"),
				periodEnd.Format("2006-01-02"),
				randomChoice([]string{"draft", "submitted", "reviewed"}),
				optionalString("Laporan sudah cukup lengkap. Teruskan!", rand.Intn(2) == 0),
			)
			if err == nil {
				created++
			}
		}
	}
	fmt.Printf(" %d reports created\n", created)
}

func seedNotifications(db *sql.DB, adminID int64, supervisorIDs []int64, interns []internSeed, perUser int) {
	fmt.Println("Creating notifications...")
	userIDs := []int64{adminID}
	userIDs = append(userIDs, supervisorIDs...)
	for _, intern := range interns {
		userIDs = append(userIDs, intern.UserID)
	}

	for _, uid := range userIDs {
		for i := 0; i < perUser; i++ {
			title := randomChoice([]string{"Tugas baru", "Presensi hari ini", "Pengumuman sistem"})
			message := randomChoice([]string{
				"Jangan lupa mengisi presensi hari ini.",
				"Anda mendapatkan tugas baru. Silakan cek halaman penugasan.",
				"Pengaturan sistem telah diperbarui.",
			})
			_, _ = db.Exec(`
				INSERT INTO notifications (user_id, type, title, message, icon, link)
				VALUES (?, ?, ?, ?, ?, ?)
			`, uid, "info", title, message, "bell", "/notifications")
		}
	}
	fmt.Println(" Notifications created")
}

func insertTaskAssignment(
	db *sql.DB,
	adminID int64,
	title, desc, priority string,
	startDate, deadline time.Time,
	deadlineTime string,
	assignToAll bool,
) (int64, error) {
	res, err := db.Exec(`
		INSERT INTO task_assignments (title, description, assigned_by, priority, start_date, deadline, deadline_time, assign_to_all)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`, title, desc, adminID, priority, startDate.Format("2006-01-02"), deadline.Format("2006-01-02"), deadlineTime, assignToAll)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func insertTask(
	db *sql.DB,
	assignmentID, internID, adminID int64,
	title, desc, priority, status string,
	startDate, deadline time.Time,
	deadlineTime string,
) (int64, error) {
	startedAt, submittedAt, completedAt, approvedAt, isLate, linksJSON, score, feedback := generateTaskData(status, deadline)

	var res sql.Result
	var err error
	if hasTaskTargetDate(db) {
		res, err = db.Exec(`
			INSERT INTO tasks (
				task_assignment_id, intern_id, assigned_by, title, description, priority, status,
				start_date, deadline, deadline_time, target_date,
				started_at, submitted_at, completed_at, approved_at,
				is_late, submission_links, score, admin_feedback
			)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			assignmentID, internID, adminID, title, desc, priority, status,
			startDate.Format("2006-01-02"), deadline.Format("2006-01-02"), deadlineTime, deadline.Format("2006-01-02"),
			startedAt, submittedAt, completedAt, approvedAt,
			isLate, linksJSON, score, feedback,
		)
	} else {
		res, err = db.Exec(`
			INSERT INTO tasks (
				task_assignment_id, intern_id, assigned_by, title, description, priority, status,
				start_date, deadline, deadline_time,
				started_at, submitted_at, completed_at, approved_at,
				is_late, submission_links, score, admin_feedback
			)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			assignmentID, internID, adminID, title, desc, priority, status,
			startDate.Format("2006-01-02"), deadline.Format("2006-01-02"), deadlineTime,
			startedAt, submittedAt, completedAt, approvedAt,
			isLate, linksJSON, score, feedback,
		)
	}
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func generateTaskData(status string, deadline time.Time) (started, submitted, completed, approved *time.Time, isLate bool, linksJSON *string, score *int, feedback *string) {
	switch status {
	case "in_progress", "submitted", "revision", "completed":
		t := deadline.AddDate(0, 0, -rand.Intn(8)-3)
		started = &t
	}

	if status == "submitted" || status == "revision" || status == "completed" {
		t := time.Now().AddDate(0, 0, -rand.Intn(4))
		submitted = &t
		isLate = submitted.After(deadline)
		linksJSON = submissionLinksJSON()
	}

	if status == "completed" {
		t := time.Now().AddDate(0, 0, -rand.Intn(7))
		completed = &t
		sub := completed.Add(-time.Duration(rand.Intn(24)+1) * time.Hour)
		submitted = &sub
		app := completed.Add(time.Duration(rand.Intn(48)+1) * time.Hour)
		approved = &app
		isLate = submitted.After(deadline)
		s := rand.Intn(31) + 70
		score = &s
		if s >= 85 {
			msg := "Kerja bagus! Hasilnya sesuai ekspektasi."
			feedback = &msg
		} else {
			msg := "Sudah cukup baik, perlu sedikit improvement untuk kedepannya."
			feedback = &msg
		}
		linksJSON = submissionLinksJSON()
	}

	if status == "revision" {
		msg := "Perlu perbaikan pada bagian " + randomChoice([]string{"UI/UX", "validasi data", "error handling", "dokumentasi"}) + "."
		feedback = &msg
	}

	return started, submitted, completed, approved, isLate, linksJSON, score, feedback
}

func generateAttendanceData(date time.Time) (status string, checkIn *time.Time, checkOut *time.Time, lateReason *string, notes *string) {
	r := rand.Intn(100) + 1
	switch {
	case r <= 75:
		status = "present"
		ci := time.Date(date.Year(), date.Month(), date.Day(), 8, rand.Intn(16), 0, 0, time.Local)
		co := time.Date(date.Year(), date.Month(), date.Day(), rand.Intn(2)+16, rand.Intn(60), 0, 0, time.Local)
		return status, &ci, &co, nil, nil
	case r <= 88:
		status = "late"
		ci := time.Date(date.Year(), date.Month(), date.Day(), rand.Intn(2)+8, rand.Intn(44)+16, 0, 0, time.Local)
		co := time.Date(date.Year(), date.Month(), date.Day(), rand.Intn(2)+16, rand.Intn(60), 0, 0, time.Local)
		reason := randomChoice([]string{"Macet", "Hujan deras", "Kendaraan mogok", "Keperluan keluarga"})
		return status, &ci, &co, &reason, nil
	case r <= 94:
		status = "sick"
		note := "Sakit " + randomChoice([]string{"flu", "demam", "migrain"})
		return status, nil, nil, nil, &note
	case r <= 98:
		status = "permission"
		note := "Keperluan keluarga"
		return status, nil, nil, nil, &note
	default:
		status = "absent"
		return status, nil, nil, nil, nil
	}
}

func submissionLinksJSON() *string {
	data := map[string]string{
		"github": fmt.Sprintf("https://github.com/user/project-%d", rand.Intn(900)+100),
		"demo":   fmt.Sprintf("https://demo.example.com/project-%d", rand.Intn(900)+100),
	}
	b, _ := json.Marshal(data)
	s := string(b)
	return &s
}

func createOrGetUser(db *sql.DB, name, email, password, role string) (int64, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return 0, err
	}
	res, err := db.Exec(`
		INSERT INTO users (name, email, password_hash, role)
		VALUES (?, ?, ?, ?)
		ON DUPLICATE KEY UPDATE name = VALUES(name), password_hash = VALUES(password_hash), role = VALUES(role), id = LAST_INSERT_ID(id)
	`, name, email, string(hash), role)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func ensureSupervisorProfile(db *sql.DB, userID int64, fullName, nip string) {
	var id int64
	err := db.QueryRow("SELECT id FROM supervisors WHERE user_id = ?", userID).Scan(&id)
	if err == sql.ErrNoRows {
		_, _ = db.Exec(`
			INSERT INTO supervisors (user_id, full_name, nip, phone, institution, status)
			VALUES (?, ?, ?, ?, ?, ?)
		`, userID, fullName, nip, randomPhone(), "Direktorat Sistem Informasi", "active")
		return
	}
	if err == nil {
		_, _ = db.Exec(`
			UPDATE supervisors SET full_name = ?, nip = ?, phone = ?, institution = ?, status = ?
			WHERE user_id = ?
		`, fullName, nip, randomPhone(), "Direktorat Sistem Informasi", "active", userID)
	}
}

func ensureInstitution(db *sql.DB, name, address, phone, email string) (int64, error) {
	var id int64
	err := db.QueryRow("SELECT id FROM institutions WHERE name = ?", name).Scan(&id)
	if err == nil {
		return id, nil
	}
	res, err := db.Exec(`
		INSERT INTO institutions (name, address, phone, email)
		VALUES (?, ?, ?, ?)
	`, name, address, phone, email)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func ensureInternProfile(
	db *sql.DB,
	userID, institutionID, supervisorID int64,
	index int,
	fullName, status string,
	startDate, endDate time.Time,
) (int64, error) {
	var id int64
	err := db.QueryRow("SELECT id FROM interns WHERE user_id = ?", userID).Scan(&id)
	if err == nil {
		_, _ = db.Exec(`
			UPDATE interns
			SET institution_id = ?, supervisor_id = ?, full_name = ?, nis = ?, student_id = ?,
			    school = ?, department = ?, date_of_birth = ?, gender = ?, phone = ?, address = ?, start_date = ?, end_date = ?, status = ?
			WHERE user_id = ?
		`,
			institutionID, supervisorID, fullName,
			fmt.Sprintf("NIS%04d", index), fmt.Sprintf("INT%04d", index),
			randomChoice(schools), randomChoice(departments),
			time.Date(2000, time.Month(rand.Intn(12)+1), rand.Intn(28)+1, 0, 0, 0, 0, time.Local),
			randomChoice([]string{"male", "female"}),
			randomPhone(),
			fmt.Sprintf("Jl. %s No. %d, Jakarta", randomChoice(lastNames), rand.Intn(100)+1),
			startDate.Format("2006-01-02"), endDate.Format("2006-01-02"), status,
			userID,
		)
		return id, nil
	}

	res, err := db.Exec(`
		INSERT INTO interns (
			user_id, institution_id, supervisor_id, full_name, nis, student_id, school, department,
			date_of_birth, gender, phone, address, start_date, end_date, status
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`,
		userID, institutionID, supervisorID, fullName,
		fmt.Sprintf("NIS%04d", index), fmt.Sprintf("INT%04d", index),
		randomChoice(schools), randomChoice(departments),
		time.Date(2000, time.Month(rand.Intn(12)+1), rand.Intn(28)+1, 0, 0, 0, 0, time.Local),
		randomChoice([]string{"male", "female"}),
		randomPhone(),
		fmt.Sprintf("Jl. %s No. %d, Jakarta", randomChoice(lastNames), rand.Intn(100)+1),
		startDate.Format("2006-01-02"), endDate.Format("2006-01-02"), status,
	)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func filterActiveInterns(interns []internSeed) []internSeed {
	var active []internSeed
	for _, i := range interns {
		if i.Status == "active" {
			active = append(active, i)
		}
	}
	if len(active) == 0 {
		return interns
	}
	return active
}

func pickInterns(interns []internSeed, assignToAll bool) []internSeed {
	if assignToAll || len(interns) == 0 {
		return interns
	}
	count := rand.Intn(8) + 5
	if count > len(interns) {
		count = len(interns)
	}
	shuffled := append([]internSeed{}, interns...)
	rand.Shuffle(len(shuffled), func(i, j int) { shuffled[i], shuffled[j] = shuffled[j], shuffled[i] })
	return shuffled[:count]
}

func determineInternStatus(endDate time.Time) string {
	if endDate.Before(time.Now()) {
		return "completed"
	}
	if rand.Intn(20) == 0 {
		return "cancelled"
	}
	return "active"
}

func uniqueEmail(first, last string, used map[string]bool) string {
	base := strings.ToLower(first + "." + last)
	email := base + "@student.id"
	counter := 1
	for used[email] {
		email = fmt.Sprintf("%s%d@student.id", base, counter)
		counter++
	}
	used[email] = true
	return email
}

func loadExistingInterns(db *sql.DB, limit int) ([]internSeed, map[string]bool) {
	interns := []internSeed{}
	usedEmails := map[string]bool{}
	rows, err := db.Query(`
		SELECT i.id, i.user_id, COALESCE(i.status, 'active') as status, u.email
		FROM interns i
		JOIN users u ON i.user_id = u.id
		ORDER BY i.id
		LIMIT ?
	`, limit)
	if err != nil {
		return interns, usedEmails
	}
	defer rows.Close()
	for rows.Next() {
		var id, userID int64
		var status, email string
		if err := rows.Scan(&id, &userID, &status, &email); err != nil {
			continue
		}
		usedEmails[email] = true
		interns = append(interns, internSeed{ID: id, UserID: userID, Status: status})
	}
	return interns, usedEmails
}

func hasTaskTargetDate(db *sql.DB) bool {
	if tasksHasTargetDate != nil {
		return *tasksHasTargetDate
	}
	var count int
	err := db.QueryRow(`
		SELECT COUNT(*)
		FROM information_schema.COLUMNS
		WHERE TABLE_SCHEMA = DATABASE()
		  AND TABLE_NAME = 'tasks'
		  AND COLUMN_NAME = 'target_date'
	`).Scan(&count)
	has := err == nil && count > 0
	tasksHasTargetDate = &has
	return has
}

func randomPhone() string {
	return fmt.Sprintf("08%d%07d", rand.Intn(90)+10, rand.Intn(9000000)+1000000)
}

func randomChoice(list []string) string {
	return list[rand.Intn(len(list))]
}

func optionalString(value string, enable bool) interface{} {
	if !enable {
		return nil
	}
	return value
}

func pickID(ids []int64) int64 {
	if len(ids) == 0 {
		return 0
	}
	return ids[rand.Intn(len(ids))]
}

func hasRows(db *sql.DB, table string) bool {
	var count int
	if err := db.QueryRow("SELECT COUNT(*) FROM " + table).Scan(&count); err != nil {
		return false
	}
	return count > 0
}

func env(key, fallback string) string {
	val := os.Getenv(key)
	if val == "" {
		return fallback
	}
	return val
}

func envInt(key string, fallback int) int {
	val := os.Getenv(key)
	if val == "" {
		return fallback
	}
	parsed, err := strconv.Atoi(val)
	if err != nil {
		return fallback
	}
	return parsed
}

func envBool(key string, fallback bool) bool {
	val := strings.ToLower(os.Getenv(key))
	if val == "" {
		return fallback
	}
	return val == "1" || val == "true" || val == "yes"
}

func printSummary() {
	fmt.Println("")
	fmt.Println(" Seed data created successfully!")
	fmt.Println("")
	fmt.Println(" Demo Account Credentials:")
	fmt.Println("")
	fmt.Println("")
	fmt.Println(" Admin Account:")
	fmt.Println("   Email:    admin@internapro.id")
	fmt.Println("   Password: password")
	fmt.Println("")
	fmt.Println(" Supervisor Accounts:")
	fmt.Println("   - bambang.herlambang@internapro.id")
	fmt.Println("   - khamizar@internapro.id")
	fmt.Println("   - mega.novita@internapro.id")
	fmt.Println("   Password: password")
	fmt.Println("")
	fmt.Println(" Intern Accounts:")
	fmt.Println("   Email:    <generated>@student.id")
	fmt.Println("   Password: password")
	fmt.Println("")
	fmt.Println("")
	fmt.Println("Tip: set SEED_FORCE=true to reseed demo data.")
}
