package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"dsi_interna_sys/internal/middleware"
	"dsi_interna_sys/internal/models"
	"dsi_interna_sys/internal/utils"

	"github.com/gorilla/mux"
	"golang.org/x/crypto/bcrypt"
)

type InternHandler struct {
	db *sql.DB
}

func NewInternHandler(db *sql.DB) *InternHandler {
	return &InternHandler{db: db}
}

type createInternRequest struct {
	Email         string `json:"email"`
	Password      string `json:"password,omitempty"`
	FullName      string `json:"full_name"`
	NIS           string `json:"nis,omitempty"`
	StudentID     string `json:"student_id,omitempty"`
	School        string `json:"school"`
	Department    string `json:"department"`
	Phone         string `json:"phone,omitempty"`
	Address       string `json:"address,omitempty"`
	StartDate     string `json:"start_date"` // YYYY-MM-DD
	EndDate       string `json:"end_date"`   // YYYY-MM-DD
	Status        string `json:"status,omitempty"`
	InstitutionID *int64 `json:"institution_id,omitempty"`
	SupervisorID  *int64 `json:"supervisor_id,omitempty"`
}

type updateInternRequest struct {
	Email         *string `json:"email,omitempty"`
	Password      *string `json:"password,omitempty"`
	FullName      *string `json:"full_name,omitempty"`
	NIS           *string `json:"nis,omitempty"`
	StudentID     *string `json:"student_id,omitempty"`
	School        *string `json:"school,omitempty"`
	Department    *string `json:"department,omitempty"`
	Phone         *string `json:"phone,omitempty"`
	Address       *string `json:"address,omitempty"`
	StartDate     *string `json:"start_date,omitempty"`
	EndDate       *string `json:"end_date,omitempty"`
	Status        *string `json:"status,omitempty"`
	InstitutionID *int64  `json:"institution_id,omitempty"`
	SupervisorID  *int64  `json:"supervisor_id,omitempty"`
}

// Register menangani pendaftaran magang mandiri (Public Endpoint)
func (h *InternHandler) Register(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Name   string `json:"name"`
		Email  string `json:"email"`
		School string `json:"school"`
		Major  string `json:"major"` // Maps to Department
		Phone  string `json:"phone"`
	}

	// 1. Decode & Validasi
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Format JSON tidak valid")
		return
	}

	if req.Email == "" || req.Name == "" {
		utils.RespondBadRequest(w, "Nama dan Email wajib diisi")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Gagal memulai transaksi")
		return
	}
	defer tx.Rollback()

	// 2. Cek apakah User sudah ada (misal dari Login Google)
	var userID int64
	err = tx.QueryRow("SELECT id FROM users WHERE email = ?", req.Email).Scan(&userID)
	if err == sql.ErrNoRows {
		// Buat User Baru jika belum ada
		// Password dikosongkan (auth via Google) atau default string jika perlu login manual nanti
		res, err := tx.Exec("INSERT INTO users (name, email, role, created_at) VALUES (?, ?, 'intern', NOW())", req.Name, req.Email)
		if err != nil {
			utils.RespondInternalError(w, "Gagal membuat user: "+err.Error())
			return
		}
		userID, _ = res.LastInsertId()
	} else if err != nil {
		utils.RespondInternalError(w, "Database error checking user")
		return
	}

	// 3. Cek apakah profil Intern sudah ada
	var internID int64
	err = tx.QueryRow("SELECT id FROM interns WHERE user_id = ?", userID).Scan(&internID)
	if err == nil {
		// Sudah terdaftar
		utils.RespondBadRequest(w, "User ini sudah terdaftar sebagai pemagang")
		return
	}

	// 4. Buat Profil Intern (Status: Pending)
	// StartDate/EndDate diset NOW() sementara karena form pendaftaran awal belum meminta tanggal
	// Admin nanti yang akan mengupdate tanggal resmi magang
	_, err = tx.Exec(`
		INSERT INTO interns (
			user_id, full_name, school, department, phone, 
			status, start_date, end_date, created_at
		) VALUES (?, ?, ?, ?, ?, 'pending', NOW(), NOW(), NOW())`,
		userID, req.Name, req.School, req.Major, req.Phone,
	)
	if err != nil {
		utils.RespondInternalError(w, "Gagal menyimpan data magang: "+err.Error())
		return
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Gagal menyimpan transaksi")
		return
	}

	utils.RespondCreated(w, "Pendaftaran berhasil dikirim", map[string]interface{}{"user_id": userID})
}

func (h *InternHandler) GetAll(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	role := normalizeRole(claims.Role)
	if role == "intern" {
		internID, err := h.getInternIDForUser(claims.UserID)
		if err != nil {
			utils.RespondNotFound(w, "Intern not found")
			return
		}
		r = r.Clone(r.Context())
		q := r.URL.Query()
		q.Set("intern_id", strconv.FormatInt(internID, 10))
		r.URL.RawQuery = q.Encode()
		h.GetByID(w, r)
		return
	}

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 15
	}
	offset := (page - 1) * limit

	search := strings.TrimSpace(r.URL.Query().Get("search"))
	status := strings.TrimSpace(r.URL.Query().Get("status"))
	supervisorFilter := strings.TrimSpace(r.URL.Query().Get("supervisor_id"))

	where := []string{}
	args := []interface{}{}

	if status != "" {
		where = append(where, "i.status = ?")
		args = append(args, status)
	}
	if supervisorFilter != "" {
		if id, err := strconv.ParseInt(supervisorFilter, 10, 64); err == nil {
			where = append(where, "i.supervisor_id = ?")
			args = append(args, id)
		}
	}
	if search != "" {
		where = append(where, "(i.full_name LIKE ? OR i.school LIKE ? OR i.department LIKE ? OR u.email LIKE ?)")
		like := "%" + search + "%"
		args = append(args, like, like, like, like)
	}

	whereClause := ""
	if len(where) > 0 {
		whereClause = "WHERE " + strings.Join(where, " AND ")
	}

	baseFrom := `
        FROM interns i
        JOIN users u ON i.user_id = u.id
        LEFT JOIN users su ON i.supervisor_id = su.id
        LEFT JOIN institutions inst ON i.institution_id = inst.id
    `

	var total int64
	countQuery := "SELECT COUNT(*) " + baseFrom + " " + whereClause
	if err := h.db.QueryRow(countQuery, args...).Scan(&total); err != nil {
		utils.RespondInternalError(w, "Failed to count interns")
		return
	}

	query := `
        SELECT i.id, i.user_id, i.institution_id, i.supervisor_id, i.full_name,
               COALESCE(i.nis,''), COALESCE(i.student_id,''), COALESCE(i.school,''), COALESCE(i.department,''),
               i.date_of_birth, COALESCE(i.gender,''), COALESCE(i.phone,''), COALESCE(i.address,''),
               i.start_date, i.end_date, i.status, i.certificate_number, i.certificate_issued_at, i.created_at, i.updated_at,
               u.email, COALESCE(su.name,''), COALESCE(inst.name,'')
    ` + baseFrom + " " + whereClause + " ORDER BY i.created_at DESC LIMIT ? OFFSET ?"

	args = append(args, limit, offset)

	rows, err := h.db.Query(query, args...)
	if err != nil {
		utils.RespondInternalError(w, "Failed to fetch interns")
		return
	}
	defer rows.Close()

	var interns []models.InternWithDetails
	for rows.Next() {
		var i models.Intern
		var email, supervisorName, institutionName string

		if err := rows.Scan(
			&i.ID, &i.UserID, &i.InstitutionID, &i.SupervisorID, &i.FullName,
			&i.NIS, &i.StudentID, &i.School, &i.Department,
			&i.DateOfBirth, &i.Gender, &i.Phone, &i.Address,
			&i.StartDate, &i.EndDate, &i.Status, &i.CertificateNumber, &i.CertificateIssuedAt, &i.CreatedAt, &i.UpdatedAt,
			&email, &supervisorName, &institutionName,
		); err == nil {
			interns = append(interns, models.InternWithDetails{
				Intern:          i,
				SupervisorName:  supervisorName,
				InstitutionName: institutionName,
				Email:           email,
			})
		}
	}

	utils.RespondPaginated(w, interns, utils.CalculatePagination(page, limit, total))
}

func (h *InternHandler) GetByID(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}

	vars := mux.Vars(r)
	idStr := vars["id"]
	if idStr == "" {
		idStr = r.URL.Query().Get("intern_id")
	}
	internID, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid intern id")
		return
	}

	// Interns can only access their own profile
	if normalizeRole(claims.Role) == "intern" {
		myID, err := h.getInternIDForUser(claims.UserID)
		if err != nil || myID != internID {
			utils.RespondForbidden(w, "You do not have access to this intern")
			return
		}
	}

	query := `
        SELECT i.id, i.user_id, i.institution_id, i.supervisor_id, i.full_name,
               COALESCE(i.nis,''), COALESCE(i.student_id,''), COALESCE(i.school,''), COALESCE(i.department,''),
               i.date_of_birth, COALESCE(i.gender,''), COALESCE(i.phone,''), COALESCE(i.address,''),
               i.start_date, i.end_date, i.status, i.certificate_number, i.certificate_issued_at, i.created_at, i.updated_at,
               u.email, COALESCE(su.name,''), COALESCE(inst.name,'')
        FROM interns i
        JOIN users u ON i.user_id = u.id
        LEFT JOIN users su ON i.supervisor_id = su.id
        LEFT JOIN institutions inst ON i.institution_id = inst.id
        WHERE i.id = ?
    `

	var i models.Intern
	var email, supervisorName, institutionName string
	err = h.db.QueryRow(query, internID).Scan(
		&i.ID, &i.UserID, &i.InstitutionID, &i.SupervisorID, &i.FullName,
		&i.NIS, &i.StudentID, &i.School, &i.Department,
		&i.DateOfBirth, &i.Gender, &i.Phone, &i.Address,
		&i.StartDate, &i.EndDate, &i.Status, &i.CertificateNumber, &i.CertificateIssuedAt, &i.CreatedAt, &i.UpdatedAt,
		&email, &supervisorName, &institutionName,
	)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Intern not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	result := models.InternWithDetails{
		Intern:          i,
		SupervisorName:  supervisorName,
		InstitutionName: institutionName,
		Email:           email,
	}

	utils.RespondSuccess(w, "Intern retrieved", result)
}

func (h *InternHandler) Create(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can create interns")
		return
	}

	var req createInternRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	if strings.TrimSpace(req.Email) == "" || strings.TrimSpace(req.FullName) == "" || strings.TrimSpace(req.StartDate) == "" || strings.TrimSpace(req.EndDate) == "" {
		utils.RespondBadRequest(w, "Email, full_name, start_date, and end_date are required")
		return
	}

	startDate, err := time.Parse("2006-01-02", req.StartDate)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid start_date")
		return
	}
	endDate, err := time.Parse("2006-01-02", req.EndDate)
	if err != nil {
		utils.RespondBadRequest(w, "Invalid end_date")
		return
	}

	status := req.Status
	if status == "" {
		status = "active"
	}

	var passwordHash sql.NullString
	if strings.TrimSpace(req.Password) != "" {
		hashed, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
		if err != nil {
			utils.RespondInternalError(w, "Failed to hash password")
			return
		}
		passwordHash = sql.NullString{String: string(hashed), Valid: true}
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	// Insert user
	res, err := tx.Exec(
		"INSERT INTO users (name, email, password_hash, role) VALUES (?, ?, ?, 'intern')",
		req.FullName, req.Email, nullIfEmptySQL(passwordHash),
	)
	if err != nil {
		utils.RespondBadRequest(w, "Email already exists")
		return
	}
	userID, _ := res.LastInsertId()

	_, err = tx.Exec(
		`INSERT INTO interns (user_id, institution_id, supervisor_id, full_name, nis, student_id, school, department,
                              phone, address, start_date, end_date, status)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		userID, nullableInt(req.InstitutionID), nullableInt(req.SupervisorID), req.FullName, req.NIS, req.StudentID,
		req.School, req.Department, req.Phone, req.Address, startDate, endDate, status,
	)
	if err != nil {
		utils.RespondInternalError(w, "Failed to create intern")
		return
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondCreated(w, "Intern created", map[string]interface{}{"user_id": userID})
}

func (h *InternHandler) Update(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can update interns")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	var req updateInternRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondBadRequest(w, "Invalid request body")
		return
	}

	// Get user_id for this intern
	var userID int64
	err := h.db.QueryRow("SELECT user_id FROM interns WHERE id = ?", internID).Scan(&userID)
	if err == sql.ErrNoRows {
		utils.RespondNotFound(w, "Intern not found")
		return
	}
	if err != nil {
		utils.RespondInternalError(w, "Database error")
		return
	}

	tx, err := h.db.Begin()
	if err != nil {
		utils.RespondInternalError(w, "Failed to start transaction")
		return
	}
	defer tx.Rollback()

	userUpdates := []string{}
	userArgs := []interface{}{}
	if req.Email != nil {
		userUpdates = append(userUpdates, "email = ?")
		userArgs = append(userArgs, *req.Email)
	}
	if req.FullName != nil {
		userUpdates = append(userUpdates, "name = ?")
		userArgs = append(userArgs, *req.FullName)
	}
	if req.Password != nil && strings.TrimSpace(*req.Password) != "" {
		hashed, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
		if err != nil {
			utils.RespondInternalError(w, "Failed to hash password")
			return
		}
		userUpdates = append(userUpdates, "password_hash = ?")
		userArgs = append(userArgs, string(hashed))
	}
	if len(userUpdates) > 0 {
		userArgs = append(userArgs, userID)
		if _, err := tx.Exec("UPDATE users SET "+strings.Join(userUpdates, ", ")+" WHERE id = ?", userArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update user")
			return
		}
	}

	internUpdates := []string{}
	internArgs := []interface{}{}
	if req.FullName != nil {
		internUpdates = append(internUpdates, "full_name = ?")
		internArgs = append(internArgs, *req.FullName)
	}
	if req.NIS != nil {
		internUpdates = append(internUpdates, "nis = ?")
		internArgs = append(internArgs, *req.NIS)
	}
	if req.StudentID != nil {
		internUpdates = append(internUpdates, "student_id = ?")
		internArgs = append(internArgs, *req.StudentID)
	}
	if req.School != nil {
		internUpdates = append(internUpdates, "school = ?")
		internArgs = append(internArgs, *req.School)
	}
	if req.Department != nil {
		internUpdates = append(internUpdates, "department = ?")
		internArgs = append(internArgs, *req.Department)
	}
	if req.Phone != nil {
		internUpdates = append(internUpdates, "phone = ?")
		internArgs = append(internArgs, *req.Phone)
	}
	if req.Address != nil {
		internUpdates = append(internUpdates, "address = ?")
		internArgs = append(internArgs, *req.Address)
	}
	if req.StartDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.StartDate); err == nil {
			internUpdates = append(internUpdates, "start_date = ?")
			internArgs = append(internArgs, parsed)
		}
	}
	if req.EndDate != nil {
		if parsed, err := time.Parse("2006-01-02", *req.EndDate); err == nil {
			internUpdates = append(internUpdates, "end_date = ?")
			internArgs = append(internArgs, parsed)
		}
	}
	if req.Status != nil {
		internUpdates = append(internUpdates, "status = ?")
		internArgs = append(internArgs, *req.Status)
	}
	if req.InstitutionID != nil {
		internUpdates = append(internUpdates, "institution_id = ?")
		internArgs = append(internArgs, nullableInt(req.InstitutionID))
	}
	if req.SupervisorID != nil {
		internUpdates = append(internUpdates, "supervisor_id = ?")
		internArgs = append(internArgs, nullableInt(req.SupervisorID))
	}

	if len(internUpdates) > 0 {
		internArgs = append(internArgs, internID)
		if _, err := tx.Exec("UPDATE interns SET "+strings.Join(internUpdates, ", ")+" WHERE id = ?", internArgs...); err != nil {
			utils.RespondInternalError(w, "Failed to update intern")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		utils.RespondInternalError(w, "Failed to commit transaction")
		return
	}

	utils.RespondSuccess(w, "Intern updated", nil)
}

func (h *InternHandler) Delete(w http.ResponseWriter, r *http.Request) {
	claims, ok := middleware.GetUserFromContext(r.Context())
	if !ok {
		utils.RespondUnauthorized(w, "Unauthorized")
		return
	}
	if normalizeRole(claims.Role) == "intern" {
		utils.RespondForbidden(w, "Only admin or pembimbing can delete interns")
		return
	}

	vars := mux.Vars(r)
	internID, _ := strconv.ParseInt(vars["id"], 10, 64)

	if _, err := h.db.Exec("DELETE FROM interns WHERE id = ?", internID); err != nil {
		utils.RespondInternalError(w, "Failed to delete intern")
		return
	}

	utils.RespondSuccess(w, "Intern deleted", nil)
}

// Helpers
func (h *InternHandler) getInternIDForUser(userID int64) (int64, error) {
	var internID int64
	err := h.db.QueryRow("SELECT id FROM interns WHERE user_id = ?", userID).Scan(&internID)
	return internID, err
}

func nullableInt(val *int64) sql.NullInt64 {
	if val == nil {
		return sql.NullInt64{Valid: false}
	}
	return sql.NullInt64{Int64: *val, Valid: *val != 0}
}

func nullIfEmptySQL(val sql.NullString) interface{} {
	if val.Valid {
		return val.String
	}
	return nil
}

func normalizeRole(role string) string {
	return strings.ToLower(role)
}